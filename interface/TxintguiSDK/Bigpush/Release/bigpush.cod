	TITLE	E:\interface\TxintguiSDK\Bigpush\bigpush.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_09NGFP@Vmyxd?4vxd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CH@MLBC@?$HL5C01B124?90194?911d5?9BB3B?94445535@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07IAIL@Release?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@MJCN@Always?5On?5?$CGTop?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@BAAP@Show?5In?5T?$CGray?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@IJGD@An?$CGimate?5Tray?5Icon?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09PFNE@?$CGAbout?4?4?4?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@PCFL@?4?4?2HTMLHelp?2Rcsim?4chm?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05KGKE@?$CGDone?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@JGEF@?$CGCalibrate?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09KBJH@xfile?4exe?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@IKLI@?4?4?2bin?2xfile?4exe?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@PONB@R?1C?5Sim?5Sikorsky?5Error?5Message?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@GJOF@Could?5not?5spawn?5R?1C?5Sim?4?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03OEOK@c?3?2?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@OPGG@http?3?1?1home?4zonnet?4nl?1blackspher@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KHOB@open?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@LCGE@No?5Signal?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09JHMD@No?5Signal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@PAHP@Signal?5Defective?5?5?5?5?5?5?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@CPII@Signal?5Defective?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@LGIH@Signal?5Connected?5?5?5?5?5?5?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@OJAH@Signal?5Connected?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@DHLA@?$CF?43f?5ms?5?5?5?5?5?5?5?5?5?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@DFPO@?$CF?43f?5ms?5?5?5?5?5?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@EPNC@?$CF6?43f?5ms?5?5?5?5?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@KKMC@?$CF7?43f?5ms?5?5?5?5?5?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FJKB@?$CF7?43f?5ms?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@LHJF@R?1C?5Sim?5Transmitter?5Calibration?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09ENKN@Resources?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08LCGJ@Channels?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07LCKD@Mapping?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@FDFJ@Sensitivity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PMPB@QQQ?$CB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MBDE@qqq?$CB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@FNBH@tooltips_class32?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MJBA@STATIC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@DKKO@Show?1Hide?5Values?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@PPNG@Center?5Sliders?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09HOKM@Set?5Color?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CI@DLAF@Could?5not?5get?5Sys?5Dir?0?5Error?5cod@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03IGFH@QQQ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CHPO@?2?2?4?2?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PCFE@?2?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EF@OCJG@VxD?5loaded?5but?5device?5does?5not?5s@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EH@JCD@Could?5not?5find?5VxD?5or?5it?5is?5not?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CG@CLKC@Software?2Blacksphere?2R?1C?5Sim?5Sik@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@OOAA@g_bChInv?$FL1?$FN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@NFPP@g_bChInv?$FL2?$FN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@MDFF@g_bChInv?$FL3?$FN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@KCAA@g_bChInv?$FL4?$FN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@LEKK@g_bChInv?$FL5?$FN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@IPFF@g_bChInv?$FL6?$FN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@JJPP@g_bChInv?$FL7?$FN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@ENPO@g_bChInv?$FL8?$FN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@FLFE@g_bChInv?$FL9?$FN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@COIO@g_bChInv?$FL10?$FN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05LCAF@Class?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@GDON@g_bAlwaysOnTop?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@BLFF@g_bShowInTray?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@DMGJ@g_bAnimateTrayIcon?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@ODK@g_hWndCalibration?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@MCDD@g_hWndSikorsky?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CA@JLAE@R?1C?5Sim?5Transmitter?5Calibration?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CLimitSingleInstance@@QAE@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CLimitSingleInstance@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsAnotherInstanceRunning@CLimitSingleInstance@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E1
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E2
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E3
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _WinMain@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DlgWndProc@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GameLoop@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AboutProc@@YGHPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CenterDialog@@YAXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateTabControl@@YAXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TabChange@@YAXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TabCenter@@YAXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawBarEx@@YAXPAUHWND__@@H_NKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DisplayContextMenu@@YGXPAUHWND__@@UtagPOINT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DisplayContextMenu2@@YGXPAUHWND__@@UtagPOINT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyboardProc@@YGJHIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MessageProc@@YGJHIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoCreateDialogTooltip@@YAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnumChildProc@@YAHPAUHWND__@@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMsgProc@@YGJHIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnWMNotify@@YAXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadVxD@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegistryRead@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegistryWrite@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegistryRead2@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegistryWrite2@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegistryRead3@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegistryWrite3@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegistryRead4@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegistryWrite4@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddTaskBarIcon@@YAXPAUHWND__@@PAUHICON__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeleteTaskBarIcon@@YAXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ModifyTaskBarIcon@@YAXPAUHWND__@@PAUHICON__@@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?g_szClassName@@3PADA				; g_szClassName
PUBLIC	?g_hInst@@3PAUHINSTANCE__@@A			; g_hInst
PUBLIC	?g_hWnd@@3PAUHWND__@@A				; g_hWnd
PUBLIC	?hIcon@@3PAUHICON__@@A				; hIcon
PUBLIC	?hMenu@@3PAUHMENU__@@A				; hMenu
PUBLIC	?pTabPage@@3PAPAUDLGTEMPLATE@@A			; pTabPage
PUBLIC	?g_hTabControl@@3PAUHWND__@@A			; g_hTabControl
PUBLIC	?g_hTabCurrent@@3PAUHWND__@@A			; g_hTabCurrent
PUBLIC	?g_bHorizontal@@3_NA				; g_bHorizontal
PUBLIC	?g_bStop@@3_NA					; g_bStop
PUBLIC	?g_bReady@@3HA					; g_bReady
PUBLIC	?g_bActive@@3HA					; g_bActive
PUBLIC	?hVxD@@3PAXA					; hVxD
PUBLIC	?cbBytesReturned@@3KA				; cbBytesReturned
PUBLIC	?dwErrorCode@@3KA				; dwErrorCode
PUBLIC	?RetInfo@@3PAHA					; RetInfo
PUBLIC	?IntCount@@3HA					; IntCount
PUBLIC	?ChannelTotal@@3HA				; ChannelTotal
PUBLIC	?strVxDFileName@@3PADA				; strVxDFileName
PUBLIC	?lpBuffer@@3PADA				; lpBuffer
PUBLIC	?strVxDFilePath@@3PADA				; strVxDFilePath
PUBLIC	?g_crColor@@3KA					; g_crColor
PUBLIC	?COLOUR_TEXT@@3KA				; COLOUR_TEXT
PUBLIC	?COLOUR_BAR@@3KA				; COLOUR_BAR
PUBLIC	?COLOR_CONNECTED@@3KA				; COLOR_CONNECTED
PUBLIC	?g_crColorBar@@3PAKA				; g_crColorBar
PUBLIC	?wpOrigProgressBar1Proc@@3P6GJPAUHWND__@@IIJ@ZA	; wpOrigProgressBar1Proc
PUBLIC	?wpOrigProgressBar2Proc@@3P6GJPAUHWND__@@IIJ@ZA	; wpOrigProgressBar2Proc
PUBLIC	?wpOrigProgressBar3Proc@@3P6GJPAUHWND__@@IIJ@ZA	; wpOrigProgressBar3Proc
PUBLIC	?wpOrigProgressBar4Proc@@3P6GJPAUHWND__@@IIJ@ZA	; wpOrigProgressBar4Proc
PUBLIC	?wpOrigProgressBar5Proc@@3P6GJPAUHWND__@@IIJ@ZA	; wpOrigProgressBar5Proc
PUBLIC	?wpOrigProgressBar6Proc@@3P6GJPAUHWND__@@IIJ@ZA	; wpOrigProgressBar6Proc
PUBLIC	?wpOrigProgressBar7Proc@@3P6GJPAUHWND__@@IIJ@ZA	; wpOrigProgressBar7Proc
PUBLIC	?wpOrigProgressBar8Proc@@3P6GJPAUHWND__@@IIJ@ZA	; wpOrigProgressBar8Proc
PUBLIC	?wpOrigProgressBar9Proc@@3P6GJPAUHWND__@@IIJ@ZA	; wpOrigProgressBar9Proc
PUBLIC	?wpOrigProgressBar10Proc@@3P6GJPAUHWND__@@IIJ@ZA ; wpOrigProgressBar10Proc
PUBLIC	?wpOrigTrackBar1Proc@@3P6GJPAUHWND__@@IIJ@ZA	; wpOrigTrackBar1Proc
PUBLIC	?wpOrigTrackBar2Proc@@3P6GJPAUHWND__@@IIJ@ZA	; wpOrigTrackBar2Proc
PUBLIC	?wpOrigTrackBar3Proc@@3P6GJPAUHWND__@@IIJ@ZA	; wpOrigTrackBar3Proc
PUBLIC	?wpOrigTrackBar4Proc@@3P6GJPAUHWND__@@IIJ@ZA	; wpOrigTrackBar4Proc
PUBLIC	?wpOrigTrackBar5Proc@@3P6GJPAUHWND__@@IIJ@ZA	; wpOrigTrackBar5Proc
PUBLIC	?wpOrigTrackBar6Proc@@3P6GJPAUHWND__@@IIJ@ZA	; wpOrigTrackBar6Proc
PUBLIC	?wpOrigTrackBar7Proc@@3P6GJPAUHWND__@@IIJ@ZA	; wpOrigTrackBar7Proc
PUBLIC	?wpOrigTrackBar8Proc@@3P6GJPAUHWND__@@IIJ@ZA	; wpOrigTrackBar8Proc
PUBLIC	?wpOrigTrackBar9Proc@@3P6GJPAUHWND__@@IIJ@ZA	; wpOrigTrackBar9Proc
PUBLIC	?wpOrigTrackBar10Proc@@3P6GJPAUHWND__@@IIJ@ZA	; wpOrigTrackBar10Proc
PUBLIC	?hHook@@3PAUHHOOK__@@A				; hHook
PUBLIC	?g_bChMute@@3PA_NA				; g_bChMute
PUBLIC	?g_bChInv@@3PAKA				; g_bChInv
PUBLIC	?g_bChExp@@3PA_NA				; g_bChExp
PUBLIC	?g_iChSens@@3PAHA				; g_iChSens
PUBLIC	?g_bShowPercent@@3_NA				; g_bShowPercent
PUBLIC	?g_bItemFree@@3PA_NA				; g_bItemFree
PUBLIC	?g_iChMap@@3PAHA				; g_iChMap
PUBLIC	?g_hinst@@3PAUHINSTANCE__@@A			; g_hinst
PUBLIC	?g_hwndTT@@3PAUHWND__@@A			; g_hwndTT
PUBLIC	?g_hwndDlg@@3PAUHWND__@@A			; g_hwndDlg
PUBLIC	?g_hhk@@3PAUHHOOK__@@A				; g_hhk
PUBLIC	?g_Calibrate@@3_NA				; g_Calibrate
PUBLIC	?g_bAlwaysOnTop@@3KA				; g_bAlwaysOnTop
PUBLIC	?g_bShowInTray@@3KA				; g_bShowInTray
PUBLIC	?hdcMemory@@3PAUHDC__@@A			; hdcMemory
PUBLIC	?hdcBuffer@@3PAUHDC__@@A			; hdcBuffer
PUBLIC	?hdcDest@@3PAUHDC__@@A				; hdcDest
PUBLIC	?hdcSrc@@3PAUHDC__@@A				; hdcSrc
PUBLIC	?hdcMask@@3PAUHDC__@@A				; hdcMask
PUBLIC	?hBscWnd@@3PAUHWND__@@A				; hBscWnd
PUBLIC	?hbmBack1@@3PAUHBITMAP__@@A			; hbmBack1
PUBLIC	?hbmBack2@@3PAUHBITMAP__@@A			; hbmBack2
PUBLIC	?hbmSrc@@3PAUHBITMAP__@@A			; hbmSrc
PUBLIC	?hbmMask@@3PAUHBITMAP__@@A			; hbmMask
PUBLIC	?x@@3HA						; x
PUBLIC	?y@@3HA						; y
PUBLIC	??_C@_09NGFP@Vmyxd?4vxd?$AA@			; `string'
PUBLIC	?g_bAnimateTrayIcon@@3KA			; g_bAnimateTrayIcon
PUBLIC	?hIcon0@@3PAUHICON__@@A				; hIcon0
PUBLIC	?hIcon1@@3PAUHICON__@@A				; hIcon1
PUBLIC	?hIcon2@@3PAUHICON__@@A				; hIcon2
PUBLIC	?status2@@3PADA					; status2
PUBLIC	?szTip@@3PADA					; szTip
PUBLIC	?iSignalStatus@@3HA				; iSignalStatus
PUBLIC	?g_hmenuTrackPopupTray@@3PAUHMENU__@@A		; g_hmenuTrackPopupTray
PUBLIC	?g_SingleInstanceObj@@3VCLimitSingleInstance@@A	; g_SingleInstanceObj
PUBLIC	?g_hWndCalibration@@3KA				; g_hWndCalibration
PUBLIC	?g_hWndSikorsky@@3KA				; g_hWndSikorsky
_BSS	SEGMENT
_?k@?DP@??GameLoop@@YAXXZ@4HA$S49454 DD 01H DUP (?)
_?count1@?DP@??GameLoop@@YAXXZ@4HA$S49456 DD 01H DUP (?)
_?j@?EF@??GameLoop@@YAXXZ@4HA$S49468 DD 01H DUP (?)
?g_hInst@@3PAUHINSTANCE__@@A DD 01H DUP (?)		; g_hInst
?g_hWnd@@3PAUHWND__@@A DD 01H DUP (?)			; g_hWnd
?hIcon@@3PAUHICON__@@A DD 01H DUP (?)			; hIcon
?hMenu@@3PAUHMENU__@@A DD 01H DUP (?)			; hMenu
?pTabPage@@3PAPAUDLGTEMPLATE@@A DD 05H DUP (?)		; pTabPage
?g_hTabControl@@3PAUHWND__@@A DD 01H DUP (?)		; g_hTabControl
?g_hTabCurrent@@3PAUHWND__@@A DD 01H DUP (?)		; g_hTabCurrent
?g_bHorizontal@@3_NA DB 01H DUP (?)			; g_bHorizontal
	ALIGN	4

?g_bStop@@3_NA DB 01H DUP (?)				; g_bStop
	ALIGN	4

?hVxD@@3PAXA DD	01H DUP (?)				; hVxD
?cbBytesReturned@@3KA DD 01H DUP (?)			; cbBytesReturned
?dwErrorCode@@3KA DD 01H DUP (?)			; dwErrorCode
?RetInfo@@3PAHA DD 058H DUP (?)				; RetInfo
?IntCount@@3HA DD 01H DUP (?)				; IntCount
?ChannelTotal@@3HA DD 01H DUP (?)			; ChannelTotal
?lpBuffer@@3PADA DB 0104H DUP (?)			; lpBuffer
?strVxDFilePath@@3PADA DB 0104H DUP (?)			; strVxDFilePath
?wpOrigProgressBar1Proc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?) ; wpOrigProgressBar1Proc
?wpOrigProgressBar2Proc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?) ; wpOrigProgressBar2Proc
?wpOrigProgressBar3Proc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?) ; wpOrigProgressBar3Proc
?wpOrigProgressBar4Proc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?) ; wpOrigProgressBar4Proc
?wpOrigProgressBar5Proc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?) ; wpOrigProgressBar5Proc
?wpOrigProgressBar6Proc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?) ; wpOrigProgressBar6Proc
?wpOrigProgressBar7Proc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?) ; wpOrigProgressBar7Proc
?wpOrigProgressBar8Proc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?) ; wpOrigProgressBar8Proc
?wpOrigProgressBar9Proc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?) ; wpOrigProgressBar9Proc
?wpOrigProgressBar10Proc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?) ; wpOrigProgressBar10Proc
?wpOrigTrackBar1Proc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?) ; wpOrigTrackBar1Proc
?wpOrigTrackBar2Proc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?) ; wpOrigTrackBar2Proc
?wpOrigTrackBar3Proc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?) ; wpOrigTrackBar3Proc
?wpOrigTrackBar4Proc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?) ; wpOrigTrackBar4Proc
?wpOrigTrackBar5Proc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?) ; wpOrigTrackBar5Proc
?wpOrigTrackBar6Proc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?) ; wpOrigTrackBar6Proc
?wpOrigTrackBar7Proc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?) ; wpOrigTrackBar7Proc
?wpOrigTrackBar8Proc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?) ; wpOrigTrackBar8Proc
?wpOrigTrackBar9Proc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?) ; wpOrigTrackBar9Proc
?wpOrigTrackBar10Proc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?) ; wpOrigTrackBar10Proc
?hHook@@3PAUHHOOK__@@A DD 01H DUP (?)			; hHook
?g_bChMute@@3PA_NA DB 0bH DUP (?)			; g_bChMute
	ALIGN	4

?g_bChInv@@3PAKA DD 0bH DUP (?)				; g_bChInv
?g_bChExp@@3PA_NA DB 0bH DUP (?)			; g_bChExp
	ALIGN	4

?g_bShowPercent@@3_NA DB 01H DUP (?)			; g_bShowPercent
	ALIGN	4

?g_hinst@@3PAUHINSTANCE__@@A DD 01H DUP (?)		; g_hinst
?g_hwndTT@@3PAUHWND__@@A DD 01H DUP (?)			; g_hwndTT
?g_hwndDlg@@3PAUHWND__@@A DD 01H DUP (?)		; g_hwndDlg
?g_hhk@@3PAUHHOOK__@@A DD 01H DUP (?)			; g_hhk
?g_Calibrate@@3_NA DB 01H DUP (?)			; g_Calibrate
	ALIGN	4

?g_bAlwaysOnTop@@3KA DD 01H DUP (?)			; g_bAlwaysOnTop
?hdcMemory@@3PAUHDC__@@A DD 01H DUP (?)			; hdcMemory
?hdcBuffer@@3PAUHDC__@@A DD 01H DUP (?)			; hdcBuffer
?hdcDest@@3PAUHDC__@@A DD 01H DUP (?)			; hdcDest
?hdcSrc@@3PAUHDC__@@A DD 01H DUP (?)			; hdcSrc
?hdcMask@@3PAUHDC__@@A DD 01H DUP (?)			; hdcMask
?hBscWnd@@3PAUHWND__@@A DD 01H DUP (?)			; hBscWnd
?hbmBack1@@3PAUHBITMAP__@@A DD 01H DUP (?)		; hbmBack1
?hbmBack2@@3PAUHBITMAP__@@A DD 01H DUP (?)		; hbmBack2
?hbmSrc@@3PAUHBITMAP__@@A DD 01H DUP (?)		; hbmSrc
?hbmMask@@3PAUHBITMAP__@@A DD 01H DUP (?)		; hbmMask
?x@@3HA	DD	01H DUP (?)				; x
?y@@3HA	DD	01H DUP (?)				; y
?hIcon0@@3PAUHICON__@@A DD 01H DUP (?)			; hIcon0
?hIcon1@@3PAUHICON__@@A DD 01H DUP (?)			; hIcon1
?hIcon2@@3PAUHICON__@@A DD 01H DUP (?)			; hIcon2
?status2@@3PADA DB 080H DUP (?)				; status2
?szTip@@3PADA DB 040H DUP (?)				; szTip
?iSignalStatus@@3HA DD 01H DUP (?)			; iSignalStatus
?g_hmenuTrackPopupTray@@3PAUHMENU__@@A DD 01H DUP (?)	; g_hmenuTrackPopupTray
	ALIGN	8

?g_SingleInstanceObj@@3VCLimitSingleInstance@@A DQ 01H DUP (?) ; g_SingleInstanceObj
?g_hWndCalibration@@3KA DD 01H DUP (?)			; g_hWndCalibration
?g_hWndSikorsky@@3KA DD 01H DUP (?)			; g_hWndSikorsky
_?i@?1??DlgWndProc@@YGJPAUHWND__@@IIJ@Z@4HA$S49048 DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
?g_szClassName@@3PADA DB 'MyWindowClass', 00H		; g_szClassName
	ORG $+2
?g_bReady@@3HA DD 01H					; g_bReady
?g_bActive@@3HA DD 01H					; g_bActive
?strVxDFileName@@3PADA DD FLAT:??_C@_09NGFP@Vmyxd?4vxd?$AA@ ; strVxDFileName
?g_crColor@@3KA DD 0ffffffH				; g_crColor
?COLOUR_TEXT@@3KA DD 0ffffffH				; COLOUR_TEXT
?COLOUR_BAR@@3KA DD 0ff0000H				; COLOUR_BAR
?COLOR_CONNECTED@@3KA DD 0ff0000H			; COLOR_CONNECTED
	ORG $+4
?g_crColorBar@@3PAKA DD 0ff0000H			; g_crColorBar
	DD	0ff0000H
	DD	0ff0000H
	DD	0ff0000H
	DD	0ff0000H
	DD	0ff0000H
	DD	0ff0000H
	DD	0ff0000H
	DD	0ff0000H
	DD	0ff0000H
	DD	0ff0000H
	ORG $+4
?g_iChSens@@3PAHA DD 064H				; g_iChSens
	DD	064H
	DD	064H
	DD	064H
	DD	064H
	DD	064H
	DD	064H
	DD	064H
	DD	064H
	DD	064H
	DD	064H
	ORG $+4
?g_bItemFree@@3PA_NA DB 01H				; g_bItemFree
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	ORG $+4
?g_iChMap@@3PAHA DD 0ffffffffH				; g_iChMap
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
?g_bShowInTray@@3KA DD 01H				; g_bShowInTray
?g_bAnimateTrayIcon@@3KA DD 01H				; g_bAnimateTrayIcon
_DATA	ENDS
CRT$XCU	SEGMENT
_$S5$S48995 DD	FLAT:_$E4
CRT$XCU	ENDS
_DATA	SEGMENT
_?i@?DA@??GameLoop@@YAXXZ@4HA$S49422 DD 0ffffffffH
_DATA	ENDS
;	COMDAT ??_C@_09NGFP@Vmyxd?4vxd?$AA@
_DATA	SEGMENT
??_C@_09NGFP@Vmyxd?4vxd?$AA@ DB 'Vmyxd.vxd', 00H	; `string'
_DATA	ENDS
;	COMDAT _$E4
_TEXT	SEGMENT
_$E4	PROC NEAR					; COMDAT
  00000	e8 00 00 00 00	 call	 _$E1
  00005	e9 00 00 00 00	 jmp	 _$E3
_$E4	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@MLBC@?$HL5C01B124?90194?911d5?9BB3B?94445535@ ; `string'
EXTRN	__imp__CreateMutexA@12:NEAR
EXTRN	__imp__GetLastError@0:NEAR
;	COMDAT ??_C@_0CH@MLBC@?$HL5C01B124?90194?911d5?9BB3B?94445535@
; File E:\interface\TxintguiSDK\Bigpush\LimitSingleInstance.h
_DATA	SEGMENT
??_C@_0CH@MLBC@?$HL5C01B124?90194?911d5?9BB3B?94445535@ DB '{5C01B124-019'
	DB	'4-11d5-BB3B-444553540001}', 00H		; `string'
_DATA	ENDS
;	COMDAT _$E1
_TEXT	SEGMENT
_$E1	PROC NEAR					; COMDAT

; 330  : CLimitSingleInstance g_SingleInstanceObj( TEXT("{5C01B124-0194-11d5-BB3B-444553540001}") );

  00000	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@MLBC@?$HL5C01B124?90194?911d5?9BB3B?94445535@ ; `string'
  00005	6a 00		 push	 0
  00007	6a 00		 push	 0
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12
  0000f	a3 04 00 00 00	 mov	 DWORD PTR ?g_SingleInstanceObj@@3VCLimitSingleInstance@@A+4, eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0001a	a3 00 00 00 00	 mov	 DWORD PTR ?g_SingleInstanceObj@@3VCLimitSingleInstance@@A, eax
  0001f	c3		 ret	 0
_$E1	ENDP
_TEXT	ENDS
EXTRN	_atexit:NEAR
;	COMDAT _$E3
_TEXT	SEGMENT
_$E3	PROC NEAR					; COMDAT
  00000	68 00 00 00 00	 push	 OFFSET FLAT:_$E2
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	83 c4 04	 add	 esp, 4
  0000d	c3		 ret	 0
_$E3	ENDP
_TEXT	ENDS
EXTRN	__imp__CloseHandle@4:NEAR
;	COMDAT _$E2
_TEXT	SEGMENT
_$E2	PROC NEAR					; COMDAT
  00000	a1 04 00 00 00	 mov	 eax, DWORD PTR ?g_SingleInstanceObj@@3VCLimitSingleInstance@@A+4
  00005	85 c0		 test	 eax, eax
  00007	74 11		 je	 SHORT $L50023
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00010	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_SingleInstanceObj@@3VCLimitSingleInstance@@A+4, 0
$L50023:
  0001a	c3		 ret	 0
_$E2	ENDP
_TEXT	ENDS
PUBLIC	_WinMain@16
PUBLIC	?DlgWndProc@@YGJPAUHWND__@@IIJ@Z		; DlgWndProc
PUBLIC	?GameLoop@@YAXXZ				; GameLoop
PUBLIC	?LoadVxD@@YAXXZ					; LoadVxD
PUBLIC	?RegistryRead3@@YAXXZ				; RegistryRead3
PUBLIC	?RegistryWrite3@@YAXXZ				; RegistryWrite3
PUBLIC	??_C@_07IAIL@Release?$AA@			; `string'
EXTRN	__imp__SetCurrentDirectoryA@4:NEAR
EXTRN	__imp__IsDialogMessageA@8:NEAR
EXTRN	__imp__GetMessageA@16:NEAR
EXTRN	__imp__TranslateMessage@4:NEAR
EXTRN	__imp__DispatchMessageA@4:NEAR
EXTRN	__imp__PeekMessageA@20:NEAR
EXTRN	__imp__LoadCursorA@8:NEAR
EXTRN	__imp__LoadIconA@8:NEAR
EXTRN	__imp__RegisterClassExA@4:NEAR
EXTRN	__imp__ShowWindow@8:NEAR
EXTRN	__imp__CreateDialogParamA@20:NEAR
EXTRN	__imp__SetForegroundWindow@4:NEAR
;	COMDAT ??_C@_07IAIL@Release?$AA@
; File E:\interface\TxintguiSDK\Bigpush\LimitSingleInstance.h
_DATA	SEGMENT
??_C@_07IAIL@Release?$AA@ DB 'Release', 00H		; `string'
_DATA	ENDS
;	COMDAT _WinMain@16
_TEXT	SEGMENT
_hInstance$ = 8
_wc$ = -48
_msg$ = -76
_WinMain@16 PROC NEAR					; COMDAT

; 358  : 	
; 359  : 	// allow only one instance
; 360  : 	if ( g_SingleInstanceObj.IsAnotherInstanceRunning() ) {

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_SingleInstanceObj@@3VCLimitSingleInstance@@A
  00005	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00008	3d b7 00 00 00	 cmp	 eax, 183		; 000000b7H
  0000d	75 28		 jne	 SHORT $L49003

; 361  : 
; 362  : 		// get HWND of running instance
; 363  : 		RegistryRead3();

  0000f	e8 00 00 00 00	 call	 ?RegistryRead3@@YAXXZ	; RegistryRead3

; 364  : 
; 365  : 		// Restore/SetForeground the window
; 366  : 		ShowWindow( (HWND)g_hWndCalibration, SW_RESTORE );

  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hWndCalibration@@3KA ; g_hWndCalibration
  00019	6a 09		 push	 9
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 367  : 		SetForegroundWindow( (HWND)g_hWndCalibration );

  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hWndCalibration@@3KA ; g_hWndCalibration
  00028	51		 push	 ecx
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetForegroundWindow@4

; 368  : 
; 369  : 		// get outta here
; 370  : 		return FALSE;

  0002f	33 c0		 xor	 eax, eax

; 468  : }

  00031	83 c4 4c	 add	 esp, 76			; 0000004cH
  00034	c2 10 00	 ret	 16			; 00000010H
$L49003:

; 357  : {

  00037	57		 push	 edi

; 371  : 	}
; 372  : 
; 373  : 
; 374  : 
; 375  : 	WNDCLASSEX wc;
; 376  : 	HWND hWnd;
; 377  : 	MSG msg;
; 378  : 
; 379  : 
; 380  : 	g_hInst = hInstance;
; 381  : 
; 382  : 	wc.cbSize        = sizeof(WNDCLASSEX);
; 383  : 	wc.style         = 0;
; 384  : 	wc.lpfnWndProc   = DlgWndProc;
; 385  : 	wc.cbClsExtra    = 0;
; 386  : 	wc.cbWndExtra    = 0;
; 387  : 	wc.hInstance     = g_hInst;
; 388  : 	wc.hIcon         = LoadIcon(g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1));

  00038	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__LoadIconA@8
  0003e	56		 push	 esi
  0003f	8b 74 24 58	 mov	 esi, DWORD PTR _hInstance$[esp+80]
  00043	53		 push	 ebx
  00044	33 db		 xor	 ebx, ebx
  00046	68 84 00 00 00	 push	 132			; 00000084H
  0004b	56		 push	 esi
  0004c	89 35 00 00 00
	00		 mov	 DWORD PTR ?g_hInst@@3PAUHINSTANCE__@@A, esi ; g_hInst
  00052	c7 44 24 30 30
	00 00 00	 mov	 DWORD PTR _wc$[esp+96], 48 ; 00000030H
  0005a	89 5c 24 34	 mov	 DWORD PTR _wc$[esp+100], ebx
  0005e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR _wc$[esp+104], OFFSET FLAT:?DlgWndProc@@YGJPAUHWND__@@IIJ@Z ; DlgWndProc
  00066	89 5c 24 3c	 mov	 DWORD PTR _wc$[esp+108], ebx
  0006a	89 5c 24 40	 mov	 DWORD PTR _wc$[esp+112], ebx
  0006e	89 74 24 44	 mov	 DWORD PTR _wc$[esp+116], esi
  00072	ff d7		 call	 edi

; 389  : 	wc.hCursor       = LoadCursor(NULL, IDC_ARROW);

  00074	68 00 7f 00 00	 push	 32512			; 00007f00H
  00079	53		 push	 ebx
  0007a	89 44 24 48	 mov	 DWORD PTR _wc$[esp+120], eax
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadCursorA@8

; 390  : 	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
; 391  : 	wc.lpszMenuName  = NULL;
; 392  : 	wc.lpszClassName = g_szClassName;
; 393  : 	wc.hIconSm       = LoadIcon(g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1)); //LoadIcon(NULL, IDI_APPLICATION);

  00084	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hInst@@3PAUHINSTANCE__@@A ; g_hInst
  0008a	68 84 00 00 00	 push	 132			; 00000084H
  0008f	52		 push	 edx
  00090	89 44 24 4c	 mov	 DWORD PTR _wc$[esp+124], eax
  00094	c7 44 24 50 06
	00 00 00	 mov	 DWORD PTR _wc$[esp+128], 6
  0009c	89 5c 24 54	 mov	 DWORD PTR _wc$[esp+132], ebx
  000a0	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR _wc$[esp+136], OFFSET FLAT:?g_szClassName@@3PADA ; g_szClassName
  000a8	ff d7		 call	 edi
  000aa	89 44 24 54	 mov	 DWORD PTR _wc$[esp+132], eax

; 394  : 
; 395  : 	RegisterClassEx(&wc);

  000ae	8d 44 24 28	 lea	 eax, DWORD PTR _wc$[esp+88]
  000b2	50		 push	 eax
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterClassExA@4

; 396  : 
; 397  :  
; 398  : 
; 399  : 	//InitCommonControls();
; 400  : 
; 401  : 	// Dialog-based app: hWndParent = NULL
; 402  : 	// Main Window Proc becomes the Dialog's Callback Proc
; 403  : 	hWnd = CreateDialog( hInstance, MAKEINTRESOURCE(IDD_CONSOLE), (HWND)NULL,
; 404  : 								(DLGPROC)DlgWndProc );

  000b9	53		 push	 ebx
  000ba	68 00 00 00 00	 push	 OFFSET FLAT:?DlgWndProc@@YGJPAUHWND__@@IIJ@Z ; DlgWndProc
  000bf	53		 push	 ebx
  000c0	6a 65		 push	 101			; 00000065H
  000c2	56		 push	 esi
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamA@20
  000c9	8b f0		 mov	 esi, eax

; 405  : 	
; 406  : 	// always handy
; 407  : 	g_hWnd = hWnd;

  000cb	89 35 00 00 00
	00		 mov	 DWORD PTR ?g_hWnd@@3PAUHWND__@@A, esi ; g_hWnd

; 408  : 
; 409  : 	
; 410  : 	// tell registry we are running
; 411  : 	g_hWndCalibration = (DWORD)hWnd;

  000d1	89 35 00 00 00
	00		 mov	 DWORD PTR ?g_hWndCalibration@@3KA, esi ; g_hWndCalibration

; 412  : 	RegistryWrite3();

  000d7	e8 00 00 00 00	 call	 ?RegistryWrite3@@YAXXZ	; RegistryWrite3

; 413  : 
; 414  : 	
; 415  : 	// Load VxD
; 416  : 	LoadVxD();

  000dc	e8 00 00 00 00	 call	 ?LoadVxD@@YAXXZ		; LoadVxD

; 417  : 
; 418  : 
; 419  : 	// kludge to make sure that when executing from DevStudio Help is found.
; 420  : 	// DevStudio has ugly habit to execute from project directory
; 421  : 	SetCurrentDirectory( "Release" );

  000e1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07IAIL@Release?$AA@ ; `string'
  000e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCurrentDirectoryA@4

; 422  : 
; 423  : 
; 424  : /*
; 425  : 	// Standard message pump for dialog based apps
; 426  : 	while(GetMessage(&msg, NULL, 0, 0))
; 427  : 	{
; 428  : 		// like this you dork, because we must still catch other messages when it is no dialog message
; 429  : 		if ( !IsDialogMessage(hWnd, &msg) ) {
; 430  : 			TranslateMessage( &msg );
; 431  : 			DispatchMessage( &msg );
; 432  : 		}
; 433  : 	}
; 434  : */
; 435  : 
; 436  : 
; 437  : 	// Special message pump
; 438  : 	BOOL bGotMsg; 
; 439  : 	PeekMessage( &msg, NULL, 0U, 0U, PM_NOREMOVE );

  000ec	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__PeekMessageA@20
  000f2	53		 push	 ebx
  000f3	53		 push	 ebx
  000f4	53		 push	 ebx
  000f5	8d 4c 24 18	 lea	 ecx, DWORD PTR _msg$[esp+100]
  000f9	53		 push	 ebx
  000fa	51		 push	 ecx
  000fb	ff d7		 call	 edi

; 440  : 
; 441  : 	while( WM_QUIT != msg.message  )

  000fd	83 7c 24 10 12	 cmp	 DWORD PTR _msg$[esp+92], 18 ; 00000012H
  00102	74 70		 je	 SHORT $L49032
  00104	55		 push	 ebp
  00105	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__GetMessageA@16
$L49031:

; 442  : 	{
; 443  : 		// Use PeekMessage() if the app is active, so we can use idle time to
; 444  : 		// render the scene. Else, use GetMessage() to avoid eating CPU time.
; 445  : 		if( g_bActive )

  0010b	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?g_bActive@@3HA, ebx ; g_bActive
  00111	74 0e		 je	 SHORT $L49033

; 446  : 			bGotMsg = PeekMessage( &msg, NULL, 0U, 0U, PM_REMOVE );

  00113	6a 01		 push	 1
  00115	53		 push	 ebx
  00116	53		 push	 ebx
  00117	8d 54 24 1c	 lea	 edx, DWORD PTR _msg$[esp+104]
  0011b	53		 push	 ebx
  0011c	52		 push	 edx
  0011d	ff d7		 call	 edi

; 447  : 		else

  0011f	eb 0a		 jmp	 SHORT $L49034
$L49033:

; 448  : 			bGotMsg = GetMessage( &msg, NULL, 0U, 0U );

  00121	53		 push	 ebx
  00122	53		 push	 ebx
  00123	8d 44 24 18	 lea	 eax, DWORD PTR _msg$[esp+100]
  00127	53		 push	 ebx
  00128	50		 push	 eax
  00129	ff d5		 call	 ebp
$L49034:

; 449  : 		
; 450  : 		if( bGotMsg )

  0012b	3b c3		 cmp	 eax, ebx
  0012d	74 28		 je	 SHORT $L49035

; 451  : 		{      
; 452  : 			if ( !IsDialogMessage(hWnd, &msg) ) {

  0012f	8d 4c 24 10	 lea	 ecx, DWORD PTR _msg$[esp+92]
  00133	51		 push	 ecx
  00134	56		 push	 esi
  00135	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsDialogMessageA@8
  0013b	85 c0		 test	 eax, eax
  0013d	75 2d		 jne	 SHORT $L49038

; 453  : 				TranslateMessage( &msg );

  0013f	8d 54 24 10	 lea	 edx, DWORD PTR _msg$[esp+92]
  00143	52		 push	 edx
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TranslateMessage@4

; 454  : 				DispatchMessage( &msg );

  0014a	8d 44 24 10	 lea	 eax, DWORD PTR _msg$[esp+92]
  0014e	50		 push	 eax
  0014f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DispatchMessageA@4

; 455  : 			}
; 456  : 		}
; 457  : 		else 

  00155	eb 15		 jmp	 SHORT $L49038
$L49035:

; 458  : 		{
; 459  : 			// Render a frame during idle time (no messages are waiting)
; 460  : 			if( g_bActive && g_bReady )

  00157	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?g_bActive@@3HA, ebx ; g_bActive
  0015d	74 0d		 je	 SHORT $L49038
  0015f	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?g_bReady@@3HA, ebx ; g_bReady
  00165	74 05		 je	 SHORT $L49038

; 461  : 				//Render3DEnvironment();
; 462  : 				GameLoop();

  00167	e8 00 00 00 00	 call	 ?GameLoop@@YAXXZ	; GameLoop
$L49038:

; 440  : 
; 441  : 	while( WM_QUIT != msg.message  )

  0016c	83 7c 24 14 12	 cmp	 DWORD PTR _msg$[esp+96], 18 ; 00000012H
  00171	75 98		 jne	 SHORT $L49031

; 357  : {

  00173	5d		 pop	 ebp
$L49032:

; 463  : 		}
; 464  : 	}
; 465  : 	
; 466  : 
; 467  : 	return msg.wParam;

  00174	8b 44 24 14	 mov	 eax, DWORD PTR _msg$[esp+96]
  00178	5b		 pop	 ebx
  00179	5e		 pop	 esi
  0017a	5f		 pop	 edi

; 468  : }

  0017b	83 c4 4c	 add	 esp, 76			; 0000004cH
  0017e	c2 10 00	 ret	 16			; 00000010H
_WinMain@16 ENDP
_TEXT	ENDS
PUBLIC	??_C@_09KBJH@xfile?4exe?$AA@			; `string'
PUBLIC	??_C@_0BB@IKLI@?4?4?2bin?2xfile?4exe?$AA@	; `string'
PUBLIC	??_C@_0BP@PONB@R?1C?5Sim?5Sikorsky?5Error?5Message?$AA@ ; `string'
PUBLIC	??_C@_0BJ@GJOF@Could?5not?5spawn?5R?1C?5Sim?4?$AA@ ; `string'
PUBLIC	??_C@_03OEOK@c?3?2?$AA@				; `string'
PUBLIC	??_C@_00A@?$AA@					; `string'
PUBLIC	??_C@_0CD@OPGG@http?3?1?1home?4zonnet?4nl?1blackspher@ ; `string'
PUBLIC	??_C@_04KHOB@open?$AA@				; `string'
PUBLIC	?AboutProc@@YGHPAUHWND__@@IIJ@Z			; AboutProc
PUBLIC	?CreateTabControl@@YAXPAUHWND__@@@Z		; CreateTabControl
PUBLIC	?TabChange@@YAXPAUHWND__@@@Z			; TabChange
PUBLIC	?RegistryRead2@@YAXXZ				; RegistryRead2
PUBLIC	?RegistryWrite2@@YAXXZ				; RegistryWrite2
PUBLIC	?RegistryRead4@@YAXXZ				; RegistryRead4
PUBLIC	?AddTaskBarIcon@@YAXPAUHWND__@@PAUHICON__@@@Z	; AddTaskBarIcon
PUBLIC	?DeleteTaskBarIcon@@YAXPAUHWND__@@@Z		; DeleteTaskBarIcon
PUBLIC	?ModifyTaskBarIcon@@YAXPAUHWND__@@PAUHICON__@@PAD@Z ; ModifyTaskBarIcon
PUBLIC	?DisplayContextMenu2@@YGXPAUHWND__@@UtagPOINT@@@Z ; DisplayContextMenu2
PUBLIC	??_C@_0P@MJCN@Always?5On?5?$CGTop?$AA@		; `string'
PUBLIC	??_C@_0O@BAAP@Show?5In?5T?$CGray?$AA@		; `string'
PUBLIC	??_C@_0BD@IJGD@An?$CGimate?5Tray?5Icon?$AA@	; `string'
PUBLIC	??_C@_09PFNE@?$CGAbout?4?4?4?$AA@		; `string'
PUBLIC	??_C@_0BG@PCFL@?4?4?2HTMLHelp?2Rcsim?4chm?$AA@	; `string'
PUBLIC	??_C@_05KGKE@?$CGDone?$AA@			; `string'
PUBLIC	??_C@_0L@JGEF@?$CGCalibrate?$AA@		; `string'
EXTRN	_HtmlHelpA@16:NEAR
EXTRN	__imp__GetDlgItem@8:NEAR
EXTRN	__imp__SetDlgItemTextA@12:NEAR
EXTRN	__imp__SelectObject@8:NEAR
EXTRN	__imp__MessageBoxA@16:NEAR
EXTRN	__imp__GetKeyState@4:NEAR
EXTRN	__imp__GetCursorPos@4:NEAR
EXTRN	__imp__SetTimer@16:NEAR
EXTRN	__imp__BitBlt@36:NEAR
EXTRN	__imp__CreateCompatibleDC@4:NEAR
EXTRN	__spawnl:NEAR
EXTRN	__imp__GetSystemMenu@8:NEAR
EXTRN	__imp__CheckMenuItem@12:NEAR
EXTRN	__imp__DeleteDC@4:NEAR
EXTRN	__imp__EnableMenuItem@12:NEAR
EXTRN	__imp__DeleteObject@4:NEAR
EXTRN	__imp__GetMenuItemID@8:NEAR
EXTRN	__imp__InsertMenuA@20:NEAR
EXTRN	__imp__ShellExecuteA@24:NEAR
EXTRN	__imp__SendMessageA@16:NEAR
EXTRN	__imp__LoadBitmapA@8:NEAR
EXTRN	__imp__PostQuitMessage@4:NEAR
EXTRN	__imp__DestroyWindow@4:NEAR
EXTRN	__imp__SetWindowPos@28:NEAR
EXTRN	__imp__IsIconic@4:NEAR
EXTRN	__imp__DialogBoxParamA@20:NEAR
;	COMDAT ??_C@_00A@?$AA@
; File E:\interface\TxintguiSDK\Bigpush\bigpush.cpp
_BSS	SEGMENT
??_C@_00A@?$AA@ DB 01H DUP (?)				; `string'
_BSS	ENDS
;	COMDAT ??_C@_0P@MJCN@Always?5On?5?$CGTop?$AA@
_DATA	SEGMENT
??_C@_0P@MJCN@Always?5On?5?$CGTop?$AA@ DB 'Always On &Top', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@BAAP@Show?5In?5T?$CGray?$AA@
_DATA	SEGMENT
??_C@_0O@BAAP@Show?5In?5T?$CGray?$AA@ DB 'Show In T&ray', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@IJGD@An?$CGimate?5Tray?5Icon?$AA@
_DATA	SEGMENT
??_C@_0BD@IJGD@An?$CGimate?5Tray?5Icon?$AA@ DB 'An&imate Tray Icon', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_09PFNE@?$CGAbout?4?4?4?$AA@
_DATA	SEGMENT
??_C@_09PFNE@?$CGAbout?4?4?4?$AA@ DB '&About...', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@PCFL@?4?4?2HTMLHelp?2Rcsim?4chm?$AA@
_DATA	SEGMENT
??_C@_0BG@PCFL@?4?4?2HTMLHelp?2Rcsim?4chm?$AA@ DB '..\HTMLHelp\Rcsim.chm', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_05KGKE@?$CGDone?$AA@
_DATA	SEGMENT
??_C@_05KGKE@?$CGDone?$AA@ DB '&Done', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@JGEF@?$CGCalibrate?$AA@
_DATA	SEGMENT
??_C@_0L@JGEF@?$CGCalibrate?$AA@ DB '&Calibrate', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09KBJH@xfile?4exe?$AA@
_DATA	SEGMENT
??_C@_09KBJH@xfile?4exe?$AA@ DB 'xfile.exe', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@IKLI@?4?4?2bin?2xfile?4exe?$AA@
_DATA	SEGMENT
??_C@_0BB@IKLI@?4?4?2bin?2xfile?4exe?$AA@ DB '..\bin\xfile.exe', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BP@PONB@R?1C?5Sim?5Sikorsky?5Error?5Message?$AA@
_DATA	SEGMENT
??_C@_0BP@PONB@R?1C?5Sim?5Sikorsky?5Error?5Message?$AA@ DB 'R/C Sim Sikor'
	DB	'sky Error Message', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@GJOF@Could?5not?5spawn?5R?1C?5Sim?4?$AA@
_DATA	SEGMENT
??_C@_0BJ@GJOF@Could?5not?5spawn?5R?1C?5Sim?4?$AA@ DB 'Could not spawn R/'
	DB	'C Sim.', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_03OEOK@c?3?2?$AA@
_DATA	SEGMENT
??_C@_03OEOK@c?3?2?$AA@ DB 'c:\', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CD@OPGG@http?3?1?1home?4zonnet?4nl?1blackspher@
_DATA	SEGMENT
??_C@_0CD@OPGG@http?3?1?1home?4zonnet?4nl?1blackspher@ DB 'http://home.zo'
	DB	'nnet.nl/blacksphere/', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04KHOB@open?$AA@
_DATA	SEGMENT
??_C@_04KHOB@open?$AA@ DB 'open', 00H			; `string'
_DATA	ENDS
;	COMDAT ?DlgWndProc@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_hWnd$ = 8
_uMsg$ = 12
_wParam$ = 16
_lParam$ = 20
_pt$ = -8
?DlgWndProc@@YGJPAUHWND__@@IIJ@Z PROC NEAR		; DlgWndProc, COMDAT

; 485  : 	// loop-the-loop
; 486  : 	//GameLoop(hWnd);
; 487  : 
; 488  : 	//MENUITEMINFO miiAlwaysOnTop;
; 489  : 
; 490  : 	POINT pt;
; 491  : 	//RECT rc;
; 492  : 
; 493  : 	LPMEASUREITEMSTRUCT lpmis;
; 494  : 	LPDRAWITEMSTRUCT lpdis;
; 495  : 
; 496  : 	static int i = 0;
; 497  : 
; 498  : 
; 499  : 
; 500  : 
; 501  : 
; 502  : 	switch (uMsg)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _uMsg$[esp-4]
  00004	83 ec 08	 sub	 esp, 8
  00007	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  0000a	53		 push	 ebx
  0000b	55		 push	 ebp
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	0f 87 21 01 00
	00		 ja	 $L50032
  00014	0f 84 f1 00 00
	00		 je	 $L49075
  0001a	83 e8 2b	 sub	 eax, 43			; 0000002bH
  0001d	74 34		 je	 SHORT $L49122
  0001f	48		 dec	 eax
  00020	0f 85 0f 09 00
	00		 jne	 $L50034

; 735  : 			}
; 736  : 			break;
; 737  : 
; 738  : 		case WM_MEASUREITEM:
; 739  : 			// do the ownnerdraw menu stuff
; 740  : 			if ( 0 == (UINT) wParam ) {

  00026	8b 44 24 24	 mov	 eax, DWORD PTR _wParam$[esp+20]
  0002a	85 c0		 test	 eax, eax
  0002c	0f 85 03 09 00
	00		 jne	 $L50034

; 741  : 				lpmis = (LPMEASUREITEMSTRUCT) lParam;
; 742  : 				lpmis->itemWidth = 5;

  00032	8b 44 24 28	 mov	 eax, DWORD PTR _lParam$[esp+20]
  00036	c7 40 0c 05 00
	00 00		 mov	 DWORD PTR [eax+12], 5

; 743  : 				lpmis->itemHeight = 150; // if smaller than actual menu height this will have no effect

  0003d	c7 40 10 96 00
	00 00		 mov	 DWORD PTR [eax+16], 150	; 00000096H

; 744  : 				
; 745  : 				return TRUE;

  00044	b8 01 00 00 00	 mov	 eax, 1

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5d		 pop	 ebp
  0004c	5b		 pop	 ebx
  0004d	83 c4 08	 add	 esp, 8
  00050	c2 10 00	 ret	 16			; 00000010H
$L49122:

; 746  : 			}
; 747  : 			break;
; 748  : 
; 749  : 		case WM_DRAWITEM:
; 750  : 			// do the ownnerdraw menu stuff
; 751  : 			if ( 0 == (UINT) wParam ) {

  00053	8b 44 24 24	 mov	 eax, DWORD PTR _wParam$[esp+20]
  00057	85 c0		 test	 eax, eax
  00059	0f 85 d6 08 00
	00		 jne	 $L50034

; 752  : 				lpdis = (LPDRAWITEMSTRUCT) lParam;				
; 753  : 
; 754  : 				hdcDest = lpdis->hDC;

  0005f	8b 44 24 28	 mov	 eax, DWORD PTR _lParam$[esp+20]
  00063	8b 40 18	 mov	 eax, DWORD PTR [eax+24]

; 755  : 
; 756  : 				hdcMemory = CreateCompatibleDC(hdcDest);

  00066	50		 push	 eax
  00067	a3 00 00 00 00	 mov	 DWORD PTR ?hdcDest@@3PAUHDC__@@A, eax ; hdcDest
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4

; 757  : 
; 758  : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP3));

  00072	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hInst@@3PAUHINSTANCE__@@A ; g_hInst
  00078	68 83 00 00 00	 push	 131			; 00000083H
  0007d	51		 push	 ecx
  0007e	a3 00 00 00 00	 mov	 DWORD PTR ?hdcMemory@@3PAUHDC__@@A, eax ; hdcMemory
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadBitmapA@8

; 759  : 				SelectObject(hdcMemory, hbmBack1);

  00089	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hdcMemory@@3PAUHDC__@@A ; hdcMemory
  0008f	50		 push	 eax
  00090	52		 push	 edx
  00091	a3 00 00 00 00	 mov	 DWORD PTR ?hbmBack1@@3PAUHBITMAP__@@A, eax ; hbmBack1
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 760  : 
; 761  : 				// Yyyeeeessss!!!!
; 762  : 				// blt to menu owner-drawn menu item
; 763  : 				BitBlt(hdcDest, 0, 14, 21, 150, hdcMemory, 0, 0, SRCCOPY);

  0009c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hdcMemory@@3PAUHDC__@@A ; hdcMemory
  000a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hdcDest@@3PAUHDC__@@A ; hdcDest
  000a7	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  000ac	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__BitBlt@36
  000b2	6a 00		 push	 0
  000b4	6a 00		 push	 0
  000b6	50		 push	 eax
  000b7	68 96 00 00 00	 push	 150			; 00000096H
  000bc	6a 15		 push	 21			; 00000015H
  000be	6a 0e		 push	 14			; 0000000eH
  000c0	6a 00		 push	 0
  000c2	51		 push	 ecx
  000c3	ff d6		 call	 esi

; 764  : 
; 765  : 				// patch
; 766  : 				BitBlt(hdcDest, 0, 0, 21, 30, hdcMemory, 0, 0, BLACKNESS);

  000c5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hdcMemory@@3PAUHDC__@@A ; hdcMemory
  000cb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hdcDest@@3PAUHDC__@@A ; hdcDest
  000d0	6a 42		 push	 66			; 00000042H
  000d2	6a 00		 push	 0
  000d4	6a 00		 push	 0
  000d6	52		 push	 edx
  000d7	6a 1e		 push	 30			; 0000001eH
  000d9	6a 15		 push	 21			; 00000015H
  000db	6a 00		 push	 0
  000dd	6a 00		 push	 0
  000df	50		 push	 eax
  000e0	ff d6		 call	 esi

; 767  : 				
; 768  : 				// Clean up
; 769  : 				DeleteDC( hdcMemory );

  000e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hdcMemory@@3PAUHDC__@@A ; hdcMemory
  000e8	51		 push	 ecx
  000e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4

; 770  : 
; 771  : 				// laat het geheugen niet vollopen...
; 772  : 				DeleteObject(hbmBack1);

  000ef	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hbmBack1@@3PAUHBITMAP__@@A ; hbmBack1
  000f5	52		 push	 edx
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 773  : 
; 774  : 				return TRUE;

  000fc	b8 01 00 00 00	 mov	 eax, 1

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  00101	5f		 pop	 edi
  00102	5e		 pop	 esi
  00103	5d		 pop	 ebp
  00104	5b		 pop	 ebx
  00105	83 c4 08	 add	 esp, 8
  00108	c2 10 00	 ret	 16			; 00000010H
$L49075:

; 616  : 			break;
; 617  : 		/*case WM_LBUTTONDOWN:
; 618  : 			//MessageBox(NULL,"qqq!","QQQ!",MB_OK);
; 619  : 			POINT pt;
; 620  : 			pt.x = LOWORD(lParam);
; 621  : 			pt.y = HIWORD(lParam);
; 622  :  
; 623  : 			// Despite the documentation, the point is in client coordinates
; 624  : 			if ( ChildWindowFromPoint(hWnd, pt) == GetDlgItem(hWnd, IDC_STATICQQQ) )
; 625  : 				MessageBox(NULL,"qqq!","QQQ!",MB_OK);
; 626  : 			return FALSE;
; 627  : 			break;*/
; 628  : 		case WM_NOTIFY:
; 629  : 			// You get this if the user wants to change the tab page
; 630  : 			if ( ((LPNMHDR)lParam)->code == TCN_SELCHANGE ) {

  0010b	8b 44 24 28	 mov	 eax, DWORD PTR _lParam$[esp+20]
  0010f	81 78 08 d9 fd
	ff ff		 cmp	 DWORD PTR [eax+8], -551	; fffffdd9H
  00116	0f 85 19 08 00
	00		 jne	 $L50034

; 631  : 				TabChange(hWnd);

  0011c	8b 4c 24 1c	 mov	 ecx, DWORD PTR _hWnd$[esp+20]
  00120	51		 push	 ecx
  00121	e8 00 00 00 00	 call	 ?TabChange@@YAXPAUHWND__@@@Z ; TabChange
  00126	83 c4 04	 add	 esp, 4

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  00129	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi
  0012d	5d		 pop	 ebp
  0012e	5b		 pop	 ebx
  0012f	83 c4 08	 add	 esp, 8
  00132	c2 10 00	 ret	 16			; 00000010H
$L50032:

; 485  : 	// loop-the-loop
; 486  : 	//GameLoop(hWnd);
; 487  : 
; 488  : 	//MENUITEMINFO miiAlwaysOnTop;
; 489  : 
; 490  : 	POINT pt;
; 491  : 	//RECT rc;
; 492  : 
; 493  : 	LPMEASUREITEMSTRUCT lpmis;
; 494  : 	LPDRAWITEMSTRUCT lpdis;
; 495  : 
; 496  : 	static int i = 0;
; 497  : 
; 498  : 
; 499  : 
; 500  : 
; 501  : 
; 502  : 	switch (uMsg)

  00135	3d 10 01 00 00	 cmp	 eax, 272		; 00000110H
  0013a	0f 87 39 02 00
	00		 ja	 $L50033

; 912  : 					break;
; 913  : 
; 914  : 			}
; 915  : 			break;
; 916  : 
; 917  : 		/*case WM_ACTIVATE:
; 918  : 			//MessageBeep(-1);
; 919  : 			if ( g_bShowInTray ) {
; 920  : 				if (HIWORD(wParam)!= 0) {
; 921  : 					ShowWindow(hWnd, SW_HIDE);
; 922  : 				} 
; 923  : 				//else {
; 924  : 				//	ShowWindow(hWnd, SW_SHOW);
; 925  : 				//}					
; 926  : 			}
; 927  : 			break;*/
; 928  : 
; 929  : 
; 930  : 		/*case WM_QUIT: // krijgt dialog niet
; 931  : 			MessageBox(NULL,"qqq!","QQQ!",MB_OK);
; 932  : 			if (g_bShowInTray) {
; 933  : 				ShowWindow(hWnd, SW_HIDE);
; 934  : 				return 0;
; 935  : 			} else {
; 936  : 				DeleteTaskBarIcon( hWnd );
; 937  : 			}
; 938  : 			break;*/
; 939  : 
; 940  : 		case WM_KEYDOWN: // fuck, why not???
; 941  : 			  // because catching key input in dialogs takes special steps
; 942  : 			  // see: the froggie apps
; 943  : 			  //if (VK_HOME == wParam)
; 944  : 			  //MessageBox(NULL,"qqq!","QQQ!",MB_OK);
; 945  : 
; 946  : 			  return 0;

  00140	0f 85 ef 07 00
	00		 jne	 $L50034
  00146	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hInst@@3PAUHINSTANCE__@@A ; g_hInst
  0014c	68 84 00 00 00	 push	 132			; 00000084H
  00151	52		 push	 edx
  00152	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadIconA@8
  00158	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__SendMessageA@16
  0015e	50		 push	 eax
  0015f	8b 5c 24 20	 mov	 ebx, DWORD PTR _hWnd$[esp+24]
  00163	6a 01		 push	 1
  00165	68 80 00 00 00	 push	 128			; 00000080H
  0016a	53		 push	 ebx
  0016b	a3 00 00 00 00	 mov	 DWORD PTR ?hIcon@@3PAUHICON__@@A, eax ; hIcon
  00170	ff d5		 call	 ebp
  00172	e8 00 00 00 00	 call	 ?RegistryRead2@@YAXXZ	; RegistryRead2
  00177	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_bAlwaysOnTop@@3KA ; g_bAlwaysOnTop
  0017c	6a 03		 push	 3
  0017e	6a 00		 push	 0
  00180	6a 00		 push	 0
  00182	85 c0		 test	 eax, eax
  00184	6a 00		 push	 0
  00186	6a 00		 push	 0
  00188	74 04		 je	 SHORT $L49059

; 503  : 	{
; 504  : 		case WM_INITDIALOG:
; 505  : 			hIcon = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1) );
; 506  : 			SendMessage(hWnd, WM_SETICON, ICON_BIG, (LPARAM)hIcon); // ICON_SMALL geeft geen icon entry in Alt-tab dialog
; 507  : 
; 508  : 			// read some reg values
; 509  : 			RegistryRead2();
; 510  : 
; 511  : 			if (g_bAlwaysOnTop)
; 512  : 				SetWindowPos( hWnd, HWND_TOPMOST, 0,0,0,0, SWP_NOMOVE|SWP_NOSIZE );

  0018a	6a ff		 push	 -1

; 513  : 			else

  0018c	eb 02		 jmp	 SHORT $L50037
$L49059:

; 514  : 				SetWindowPos( hWnd, HWND_NOTOPMOST, 0,0,0,0, SWP_NOMOVE|SWP_NOSIZE );					

  0018e	6a fe		 push	 -2			; fffffffeH
$L50037:
  00190	53		 push	 ebx
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28

; 515  : 		
; 516  : 			if (g_bShowInTray)

  00197	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_bShowInTray@@3KA ; g_bShowInTray
  0019c	85 c0		 test	 eax, eax
  0019e	74 0f		 je	 SHORT $L49063

; 517  : 				AddTaskBarIcon( hWnd, hIcon );

  001a0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hIcon@@3PAUHICON__@@A ; hIcon
  001a5	50		 push	 eax
  001a6	53		 push	 ebx
  001a7	e8 00 00 00 00	 call	 ?AddTaskBarIcon@@YAXPAUHWND__@@PAUHICON__@@@Z ; AddTaskBarIcon
  001ac	83 c4 08	 add	 esp, 8
$L49063:

; 518  : 			//else
; 519  : 			//	DeleteTaskBarIcon( hWnd );
; 520  : 			
; 521  : 			// system menu stuff
; 522  : 			hMenu = GetSystemMenu(hWnd, FALSE);

  001af	6a 00		 push	 0
  001b1	53		 push	 ebx
  001b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMenu@8

; 523  : 			if (hMenu != NULL)  {

  001b8	85 c0		 test	 eax, eax
  001ba	a3 00 00 00 00	 mov	 DWORD PTR ?hMenu@@3PAUHMENU__@@A, eax ; hMenu
  001bf	0f 84 6c 01 00
	00		 je	 $L49074

; 524  : 				EnableMenuItem(hMenu, GetMenuItemID(hMenu,0), MF_GRAYED);

  001c5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetMenuItemID@8
  001cb	6a 01		 push	 1
  001cd	6a 00		 push	 0
  001cf	50		 push	 eax
  001d0	ff d6		 call	 esi
  001d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  001d8	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__EnableMenuItem@12
  001de	50		 push	 eax
  001df	51		 push	 ecx
  001e0	ff d7		 call	 edi

; 525  : 				EnableMenuItem(hMenu, GetMenuItemID(hMenu,2), MF_GRAYED);

  001e2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  001e8	6a 01		 push	 1
  001ea	6a 02		 push	 2
  001ec	52		 push	 edx
  001ed	ff d6		 call	 esi
  001ef	50		 push	 eax
  001f0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  001f5	50		 push	 eax
  001f6	ff d7		 call	 edi

; 526  : 				EnableMenuItem(hMenu, GetMenuItemID(hMenu,4), MF_GRAYED);

  001f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  001fe	6a 01		 push	 1
  00200	6a 04		 push	 4
  00202	51		 push	 ecx
  00203	ff d6		 call	 esi
  00205	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  0020b	50		 push	 eax
  0020c	52		 push	 edx
  0020d	ff d7		 call	 edi

; 527  : 
; 528  : /*
; 529  : 				miiAlwaysOnTop.cbSize = sizeof(MENUITEMINFO);
; 530  : 				miiAlwaysOnTop.fMask = MIIM_CHECKMARKS | MIIM_DATA | MIIM_ID | MIIM_STATE | MIIM_SUBMENU | MIIM_TYPE;
; 531  : 				miiAlwaysOnTop.fType = MFT_STRING;
; 532  : 				miiAlwaysOnTop.fState = MFS_ENABLED | MFS_UNCHECKED; 
; 533  : 				miiAlwaysOnTop.wID = IDM_ALWAYSONTOP; 
; 534  : 				miiAlwaysOnTop.hSubMenu = NULL; 
; 535  : 				miiAlwaysOnTop.hbmpChecked = NULL; 
; 536  : 				miiAlwaysOnTop.hbmpUnchecked = NULL; 
; 537  : 				miiAlwaysOnTop.dwItemData = 0; 
; 538  : 				miiAlwaysOnTop.dwTypeData = "Always On &Top"; 
; 539  : 				miiAlwaysOnTop.cch = sizeof("Always On &Top");
; 540  : 
; 541  : 				//InsertMenuItem(hMenu, 6, TRUE, &miiAlwaysOnTop);
; 542  : */
; 543  : 				
; 544  : 				InsertMenu(hMenu, 5, MF_BYPOSITION|MF_SEPARATOR, 0, NULL);

  0020f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  00214	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__InsertMenuA@20
  0021a	6a 00		 push	 0
  0021c	6a 00		 push	 0
  0021e	68 00 0c 00 00	 push	 3072			; 00000c00H
  00223	6a 05		 push	 5
  00225	50		 push	 eax
  00226	ff d6		 call	 esi

; 545  : 				InsertMenu(hMenu, 6, MF_BYPOSITION|MF_STRING, IDM_ALWAYSONTOP, "Always On &Top");

  00228	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  0022e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@MJCN@Always?5On?5?$CGTop?$AA@ ; `string'
  00233	6a 11		 push	 17			; 00000011H
  00235	68 00 04 00 00	 push	 1024			; 00000400H
  0023a	6a 06		 push	 6
  0023c	51		 push	 ecx
  0023d	ff d6		 call	 esi

; 546  : 				InsertMenu(hMenu, 7, MF_BYPOSITION|MF_SEPARATOR, 0, NULL);

  0023f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  00245	6a 00		 push	 0
  00247	6a 00		 push	 0
  00249	68 00 0c 00 00	 push	 3072			; 00000c00H
  0024e	6a 07		 push	 7
  00250	52		 push	 edx
  00251	ff d6		 call	 esi

; 547  : 				InsertMenu(hMenu, 8, MF_BYPOSITION|MF_STRING, IDM_SHOWINTRAY, "Show In T&ray");

  00253	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  00258	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@BAAP@Show?5In?5T?$CGray?$AA@ ; `string'
  0025d	6a 12		 push	 18			; 00000012H
  0025f	68 00 04 00 00	 push	 1024			; 00000400H
  00264	6a 08		 push	 8
  00266	50		 push	 eax
  00267	ff d6		 call	 esi

; 548  : 				InsertMenu(hMenu, 9, MF_BYPOSITION|MF_STRING, IDM_ANIMATETRAYICON, "An&imate Tray Icon");

  00269	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  0026f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@IJGD@An?$CGimate?5Tray?5Icon?$AA@ ; `string'
  00274	6a 13		 push	 19			; 00000013H
  00276	68 00 04 00 00	 push	 1024			; 00000400H
  0027b	6a 09		 push	 9
  0027d	51		 push	 ecx
  0027e	ff d6		 call	 esi

; 549  : 				InsertMenu(hMenu, 10, MF_BYPOSITION|MF_SEPARATOR, 0, NULL);

  00280	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  00286	6a 00		 push	 0
  00288	6a 00		 push	 0
  0028a	68 00 0c 00 00	 push	 3072			; 00000c00H
  0028f	6a 0a		 push	 10			; 0000000aH
  00291	52		 push	 edx
  00292	ff d6		 call	 esi

; 550  : 				InsertMenu(hMenu, 11, MF_BYPOSITION|MF_STRING, IDM_ABOUTBOX, "&About...");

  00294	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  00299	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09PFNE@?$CGAbout?4?4?4?$AA@ ; `string'
  0029e	6a 10		 push	 16			; 00000010H
  002a0	68 00 04 00 00	 push	 1024			; 00000400H
  002a5	6a 0b		 push	 11			; 0000000bH
  002a7	50		 push	 eax
  002a8	ff d6		 call	 esi

; 551  : 
; 552  : 				if (g_bAlwaysOnTop)

  002aa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_bAlwaysOnTop@@3KA ; g_bAlwaysOnTop
  002af	85 c0		 test	 eax, eax
  002b1	74 0d		 je	 SHORT $L49069

; 553  : 					CheckMenuItem(hMenu, IDM_ALWAYSONTOP, MF_CHECKED);

  002b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  002b9	6a 08		 push	 8
  002bb	6a 11		 push	 17			; 00000011H
  002bd	51		 push	 ecx

; 554  : 				else

  002be	eb 0b		 jmp	 SHORT $L50038
$L49069:

; 555  : 					CheckMenuItem(hMenu, IDM_ALWAYSONTOP, MF_UNCHECKED);

  002c0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  002c6	6a 00		 push	 0
  002c8	6a 11		 push	 17			; 00000011H
  002ca	52		 push	 edx
$L50038:
  002cb	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CheckMenuItem@12
  002d1	ff d6		 call	 esi

; 556  : 
; 557  : 				if (g_bShowInTray) {

  002d3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_bShowInTray@@3KA ; g_bShowInTray
  002d8	85 c0		 test	 eax, eax
  002da	74 19		 je	 SHORT $L49071

; 558  : 					CheckMenuItem(hMenu, IDM_SHOWINTRAY, MF_CHECKED);

  002dc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  002e1	6a 08		 push	 8
  002e3	6a 12		 push	 18			; 00000012H
  002e5	50		 push	 eax
  002e6	ff d6		 call	 esi

; 559  : 					EnableMenuItem(hMenu, IDM_ANIMATETRAYICON, MF_ENABLED);

  002e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  002ee	6a 00		 push	 0
  002f0	6a 13		 push	 19			; 00000013H
  002f2	51		 push	 ecx

; 560  : 				} else {

  002f3	eb 17		 jmp	 SHORT $L50039
$L49071:

; 561  : 					CheckMenuItem(hMenu, IDM_SHOWINTRAY, MF_UNCHECKED);

  002f5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  002fb	6a 00		 push	 0
  002fd	6a 12		 push	 18			; 00000012H
  002ff	52		 push	 edx
  00300	ff d6		 call	 esi

; 562  : 					EnableMenuItem(hMenu, IDM_ANIMATETRAYICON, MF_GRAYED);

  00302	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  00307	6a 01		 push	 1
  00309	6a 13		 push	 19			; 00000013H
  0030b	50		 push	 eax
$L50039:
  0030c	ff d7		 call	 edi

; 563  : 				}
; 564  : 
; 565  : 				if (g_bAnimateTrayIcon)

  0030e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_bAnimateTrayIcon@@3KA ; g_bAnimateTrayIcon
  00313	85 c0		 test	 eax, eax
  00315	74 0d		 je	 SHORT $L49073

; 566  : 					CheckMenuItem(hMenu, IDM_ANIMATETRAYICON, MF_CHECKED);

  00317	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  0031d	6a 08		 push	 8
  0031f	6a 13		 push	 19			; 00000013H
  00321	51		 push	 ecx

; 567  : 				else

  00322	eb 0b		 jmp	 SHORT $L50040
$L49073:

; 568  : 					CheckMenuItem(hMenu, IDM_ANIMATETRAYICON, MF_UNCHECKED);

  00324	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  0032a	6a 00		 push	 0
  0032c	6a 13		 push	 19			; 00000013H
  0032e	52		 push	 edx
$L50040:
  0032f	ff d6		 call	 esi
$L49074:

; 569  : 
; 570  : 				
; 571  : 
; 572  : 				
; 573  : 				//AppendMenu(hMenu, MF_SEPARATOR, 0, NULL);
; 574  : 				//AppendMenu(hMenu, MF_STRING, IDM_ABOUTBOX, "&About...");
; 575  : 			}
; 576  : 
; 577  : 			// get the handle to the tab control
; 578  : 			g_hTabControl = GetDlgItem(hWnd,IDC_TAB1);

  00331	68 17 04 00 00	 push	 1047			; 00000417H
  00336	53		 push	 ebx
  00337	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8

; 579  : 
; 580  : 			// What we need is a tabbed control which contains our prop pages
; 581  : 			CreateTabControl(hWnd);

  0033d	53		 push	 ebx
  0033e	a3 00 00 00 00	 mov	 DWORD PTR ?g_hTabControl@@3PAUHWND__@@A, eax ; g_hTabControl
  00343	e8 00 00 00 00	 call	 ?CreateTabControl@@YAXPAUHWND__@@@Z ; CreateTabControl
  00348	83 c4 04	 add	 esp, 4

; 582  : 
; 583  : 			// Start up tab
; 584  : 			TabChange(hWnd);

  0034b	53		 push	 ebx
  0034c	e8 00 00 00 00	 call	 ?TabChange@@YAXPAUHWND__@@@Z ; TabChange
  00351	83 c4 04	 add	 esp, 4

; 585  : 
; 586  : 			// Set focus to OK button
; 587  : 			// Note: Kan niet met SetFocus()
; 588  : 			SendMessage(hWnd,WM_NEXTDLGCTL,0,FALSE);

  00354	6a 00		 push	 0
  00356	6a 00		 push	 0
  00358	6a 28		 push	 40			; 00000028H
  0035a	53		 push	 ebx
  0035b	ff d5		 call	 ebp

; 589  : 
; 590  : 			// TODO: dotted line focus on first tab so user kan tab
; 591  : 			// to next tab right away: see GetRight Config
; 592  : 			// DONE: by setting Tab Order of Tab Control to 1 we can now
; 593  : 			// use arrows to switch tabs. Still have no focus on tab at start-up
; 594  : 			// though...
; 595  : 			
; 596  : 			 // used for getting keyboard input
; 597  : 			SetTimer( hWnd, 1, 50, NULL );

  0035d	6a 00		 push	 0
  0035f	6a 32		 push	 50			; 00000032H
  00361	6a 01		 push	 1
  00363	53		 push	 ebx
  00364	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16

; 598  : 
; 599  : 			// tooltips
; 600  : 			// NOTE: if we wanted tooltips for the main dialog window we must create
; 601  : 			// another procedure. If we use DoCreateDialogTooltip() and then do a tab change
; 602  : 			// without having unhooked in the main dialog window we'll CRASH.
; 603  : 			// But we can never unhook the main window's tooltips as they must be present
; 604  : 			// at the same time as the tab dialog's tooltips
; 605  : 			// Sollution: create a separate tooltip procedure for the main window
; 606  : 			// BUT: we don't really need tooltips for the main window...
; 607  : 			//g_hinst = g_hInst;
; 608  : 			//g_hwndDlg = hWnd;	
; 609  : 			//DoCreateDialogTooltip();
; 610  : 			
; 611  : 			// MUST be done before doing a new DoCreateDialogTooltip()
; 612  : 			// tooltips unhook, unhook!!!
; 613  : 			//UnhookWindowsHookEx(g_hhk);
; 614  : 
; 615  : 			return TRUE;

  0036a	b8 01 00 00 00	 mov	 eax, 1

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  0036f	5f		 pop	 edi
  00370	5e		 pop	 esi
  00371	5d		 pop	 ebp
  00372	5b		 pop	 ebx
  00373	83 c4 08	 add	 esp, 8
  00376	c2 10 00	 ret	 16			; 00000010H
$L50033:

; 485  : 	// loop-the-loop
; 486  : 	//GameLoop(hWnd);
; 487  : 
; 488  : 	//MENUITEMINFO miiAlwaysOnTop;
; 489  : 
; 490  : 	POINT pt;
; 491  : 	//RECT rc;
; 492  : 
; 493  : 	LPMEASUREITEMSTRUCT lpmis;
; 494  : 	LPDRAWITEMSTRUCT lpdis;
; 495  : 
; 496  : 	static int i = 0;
; 497  : 
; 498  : 
; 499  : 
; 500  : 
; 501  : 
; 502  : 	switch (uMsg)

  00379	3d 01 04 00 00	 cmp	 eax, 1025		; 00000401H
  0037e	0f 87 b1 05 00
	00		 ja	 $L50034
  00384	0f 84 59 05 00
	00		 je	 $L49109
  0038a	05 ef fe ff ff	 add	 eax, -273		; fffffeefH
  0038f	83 f8 05	 cmp	 eax, 5
  00392	0f 87 9d 05 00
	00		 ja	 $L50034
  00398	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L50045[eax*4]
$L49078:

; 632  : 			}
; 633  : 
; 634  : 			// don't need this: put info in help file
; 635  : 			// tooltips for the calibrate button
; 636  : 			//OnWMNotify(lParam);
; 637  : 			break;
; 638  : 
; 639  : 		case WM_SYSCOMMAND:
; 640  : 			switch ( (DWORD)wParam )

  0039f	8b 44 24 24	 mov	 eax, DWORD PTR _wParam$[esp+20]
  003a3	3d 60 f0 00 00	 cmp	 eax, 61536		; 0000f060H
  003a8	0f 87 87 05 00
	00		 ja	 $L50034
  003ae	0f 84 2b 01 00
	00		 je	 $L49084
  003b4	83 c0 f0	 add	 eax, -16		; fffffff0H
  003b7	83 f8 03	 cmp	 eax, 3
  003ba	0f 87 75 05 00
	00		 ja	 $L50034
  003c0	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L50046[eax*4]
$L49087:

; 645  : 						return 0;
; 646  : 					}
; 647  : 						
; 648  : 					// not really necessary
; 649  : 					DeleteTaskBarIcon( hWnd );
; 650  : 
; 651  : 					// write some reg values
; 652  : 					RegistryWrite2();
; 653  : 
; 654  : 					// tell registry we are down
; 655  : 					g_hWndCalibration = (DWORD)NULL;
; 656  : 					RegistryWrite3();
; 657  : 					
; 658  : 					DestroyWindow(hWnd);    // this won't kill the app!! 
; 659  : 					PostQuitMessage(0);     // kill!!!
; 660  : 					break;
; 661  : 
; 662  : 				case IDM_ABOUTBOX:
; 663  : 					DialogBox(g_hInst, MAKEINTRESOURCE(IDD_ABOUT), hWnd,
; 664  : 								(DLGPROC)AboutProc );

  003c7	8b 44 24 1c	 mov	 eax, DWORD PTR _hWnd$[esp+20]
  003cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hInst@@3PAUHINSTANCE__@@A ; g_hInst
  003d1	6a 00		 push	 0
  003d3	68 00 00 00 00	 push	 OFFSET FLAT:?AboutProc@@YGHPAUHWND__@@IIJ@Z ; AboutProc
  003d8	50		 push	 eax
  003d9	6a 6a		 push	 106			; 0000006aH
  003db	51		 push	 ecx
  003dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DialogBoxParamA@20

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  003e2	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  003e4	5f		 pop	 edi
  003e5	5e		 pop	 esi
  003e6	5d		 pop	 ebp
  003e7	5b		 pop	 ebx
  003e8	83 c4 08	 add	 esp, 8
  003eb	c2 10 00	 ret	 16			; 00000010H
$L49092:

; 665  : 					break;
; 666  : 
; 667  : 				case IDM_ALWAYSONTOP:
; 668  : 					//MessageBox(NULL,"qqq!","QQQ!",MB_OK);
; 669  : 					g_bAlwaysOnTop = !g_bAlwaysOnTop;

  003ee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_bAlwaysOnTop@@3KA ; g_bAlwaysOnTop
  003f4	33 c0		 xor	 eax, eax
  003f6	85 d2		 test	 edx, edx

; 670  : 					
; 671  : 					if (g_bAlwaysOnTop)
; 672  : 						SetWindowPos( hWnd, HWND_TOPMOST, 0,0,0,0, SWP_NOMOVE|SWP_NOSIZE );

  003f8	6a 03		 push	 3
  003fa	6a 00		 push	 0
  003fc	0f 94 c0	 sete	 al
  003ff	6a 00		 push	 0
  00401	6a 00		 push	 0
  00403	85 c0		 test	 eax, eax
  00405	a3 00 00 00 00	 mov	 DWORD PTR ?g_bAlwaysOnTop@@3KA, eax ; g_bAlwaysOnTop
  0040a	6a 00		 push	 0
  0040c	74 19		 je	 SHORT $L49093
  0040e	8b 54 24 30	 mov	 edx, DWORD PTR _hWnd$[esp+40]
  00412	6a ff		 push	 -1
  00414	52		 push	 edx
  00415	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  0041b	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  0041d	5f		 pop	 edi
  0041e	5e		 pop	 esi
  0041f	5d		 pop	 ebp
  00420	5b		 pop	 ebx
  00421	83 c4 08	 add	 esp, 8
  00424	c2 10 00	 ret	 16			; 00000010H
$L49093:

; 673  : 					else
; 674  : 						SetWindowPos( hWnd, HWND_NOTOPMOST, 0,0,0,0, SWP_NOMOVE|SWP_NOSIZE );					

  00427	8b 44 24 30	 mov	 eax, DWORD PTR _hWnd$[esp+40]
  0042b	6a fe		 push	 -2			; fffffffeH
  0042d	50		 push	 eax
  0042e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  00434	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  00436	5f		 pop	 edi
  00437	5e		 pop	 esi
  00438	5d		 pop	 ebp
  00439	5b		 pop	 ebx
  0043a	83 c4 08	 add	 esp, 8
  0043d	c2 10 00	 ret	 16			; 00000010H
$L49097:

; 675  : 					break;
; 676  : 
; 677  : 				case IDM_SHOWINTRAY:
; 678  : 					g_bShowInTray = !g_bShowInTray;

  00440	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_bShowInTray@@3KA ; g_bShowInTray
  00446	33 c0		 xor	 eax, eax
  00448	85 d2		 test	 edx, edx
  0044a	0f 94 c0	 sete	 al

; 679  : 
; 680  : 					if (g_bShowInTray)

  0044d	85 c0		 test	 eax, eax
  0044f	a3 00 00 00 00	 mov	 DWORD PTR ?g_bShowInTray@@3KA, eax ; g_bShowInTray
  00454	74 20		 je	 SHORT $L49098

; 681  : 						AddTaskBarIcon( hWnd, hIcon );

  00456	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hIcon@@3PAUHICON__@@A ; hIcon
  0045c	8b 54 24 1c	 mov	 edx, DWORD PTR _hWnd$[esp+20]
  00460	51		 push	 ecx
  00461	52		 push	 edx
  00462	e8 00 00 00 00	 call	 ?AddTaskBarIcon@@YAXPAUHWND__@@PAUHICON__@@@Z ; AddTaskBarIcon
  00467	83 c4 08	 add	 esp, 8

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  0046a	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  0046c	5f		 pop	 edi
  0046d	5e		 pop	 esi
  0046e	5d		 pop	 ebp
  0046f	5b		 pop	 ebx
  00470	83 c4 08	 add	 esp, 8
  00473	c2 10 00	 ret	 16			; 00000010H
$L49098:

; 682  : 					else
; 683  : 						DeleteTaskBarIcon( hWnd );

  00476	8b 44 24 1c	 mov	 eax, DWORD PTR _hWnd$[esp+20]
  0047a	50		 push	 eax
  0047b	e8 00 00 00 00	 call	 ?DeleteTaskBarIcon@@YAXPAUHWND__@@@Z ; DeleteTaskBarIcon
  00480	83 c4 04	 add	 esp, 4

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  00483	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  00485	5f		 pop	 edi
  00486	5e		 pop	 esi
  00487	5d		 pop	 ebp
  00488	5b		 pop	 ebx
  00489	83 c4 08	 add	 esp, 8
  0048c	c2 10 00	 ret	 16			; 00000010H
$L49100:

; 684  : 					break;
; 685  : 
; 686  : 				case IDM_ANIMATETRAYICON:
; 687  : 					g_bAnimateTrayIcon = !g_bAnimateTrayIcon;

  0048f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_bAnimateTrayIcon@@3KA ; g_bAnimateTrayIcon
  00495	33 c0		 xor	 eax, eax
  00497	85 d2		 test	 edx, edx
  00499	0f 94 c0	 sete	 al

; 688  : 
; 689  : 					if (g_bAnimateTrayIcon)

  0049c	85 c0		 test	 eax, eax
  0049e	a3 00 00 00 00	 mov	 DWORD PTR ?g_bAnimateTrayIcon@@3KA, eax ; g_bAnimateTrayIcon
  004a3	74 1d		 je	 SHORT $L49101

; 690  : 						CheckMenuItem(hMenu, IDM_ANIMATETRAYICON, MF_CHECKED);

  004a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  004ab	6a 08		 push	 8
  004ad	6a 13		 push	 19			; 00000013H
  004af	51		 push	 ecx
  004b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CheckMenuItem@12

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  004b6	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  004b8	5f		 pop	 edi
  004b9	5e		 pop	 esi
  004ba	5d		 pop	 ebp
  004bb	5b		 pop	 ebx
  004bc	83 c4 08	 add	 esp, 8
  004bf	c2 10 00	 ret	 16			; 00000010H
$L49101:

; 691  : 					else
; 692  : 						CheckMenuItem(hMenu, IDM_ANIMATETRAYICON, MF_UNCHECKED);

  004c2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  004c8	6a 00		 push	 0
  004ca	6a 13		 push	 19			; 00000013H
  004cc	52		 push	 edx
  004cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CheckMenuItem@12

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  004d3	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  004d5	5f		 pop	 edi
  004d6	5e		 pop	 esi
  004d7	5d		 pop	 ebp
  004d8	5b		 pop	 ebx
  004d9	83 c4 08	 add	 esp, 8
  004dc	c2 10 00	 ret	 16			; 00000010H
$L49084:

; 641  : 			{
; 642  : 				case SC_CLOSE:	// also when Close button clicked
; 643  : 					if (g_bShowInTray) {

  004df	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_bShowInTray@@3KA ; g_bShowInTray
  004e4	85 c0		 test	 eax, eax
  004e6	0f 84 91 01 00
	00		 je	 $L49177

; 644  : 						ShowWindow(hWnd, SW_HIDE);

  004ec	8b 44 24 1c	 mov	 eax, DWORD PTR _hWnd$[esp+20]
  004f0	6a 00		 push	 0
  004f2	50		 push	 eax
  004f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  004f9	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  004fb	5f		 pop	 edi
  004fc	5e		 pop	 esi
  004fd	5d		 pop	 ebp
  004fe	5b		 pop	 ebx
  004ff	83 c4 08	 add	 esp, 8
  00502	c2 10 00	 ret	 16			; 00000010H
$L49103:

; 693  : 					break;
; 694  : 				
; 695  : 			}
; 696  : 			break;
; 697  : 
; 698  : 		case WM_INITMENU:
; 699  : 			//MessageBox(NULL,"qqq!","QQQ!",MB_OK);
; 700  : 			hMenu = (HMENU) wParam; //GetSystemMenu(hWnd, FALSE);
; 701  : 
; 702  : 			if (g_bAlwaysOnTop) 

  00505	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_bAlwaysOnTop@@3KA ; g_bAlwaysOnTop
  0050b	8b 44 24 24	 mov	 eax, DWORD PTR _wParam$[esp+20]
  0050f	85 c9		 test	 ecx, ecx
  00511	a3 00 00 00 00	 mov	 DWORD PTR ?hMenu@@3PAUHMENU__@@A, eax ; hMenu
  00516	74 04		 je	 SHORT $L49105

; 703  : 				CheckMenuItem(hMenu, IDM_ALWAYSONTOP, MF_CHECKED);

  00518	6a 08		 push	 8

; 704  : 			else

  0051a	eb 02		 jmp	 SHORT $L50041
$L49105:

; 705  : 				CheckMenuItem(hMenu, IDM_ALWAYSONTOP, MF_UNCHECKED);

  0051c	6a 00		 push	 0
$L50041:
  0051e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CheckMenuItem@12
  00524	6a 11		 push	 17			; 00000011H
  00526	50		 push	 eax
  00527	ff d6		 call	 esi

; 706  : 
; 707  : 			if (g_bShowInTray) {

  00529	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_bShowInTray@@3KA ; g_bShowInTray
  0052e	85 c0		 test	 eax, eax
  00530	74 2a		 je	 SHORT $L49107

; 708  : 				CheckMenuItem(hMenu, IDM_SHOWINTRAY, MF_CHECKED);

  00532	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  00538	6a 08		 push	 8
  0053a	6a 12		 push	 18			; 00000012H
  0053c	51		 push	 ecx
  0053d	ff d6		 call	 esi

; 709  : 				EnableMenuItem(hMenu, IDM_ANIMATETRAYICON, MF_ENABLED);

  0053f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  00545	6a 00		 push	 0
  00547	6a 13		 push	 19			; 00000013H
  00549	52		 push	 edx
  0054a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableMenuItem@12

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  00550	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  00552	5f		 pop	 edi
  00553	5e		 pop	 esi
  00554	5d		 pop	 ebp
  00555	5b		 pop	 ebx
  00556	83 c4 08	 add	 esp, 8
  00559	c2 10 00	 ret	 16			; 00000010H
$L49107:

; 710  : 			} else {
; 711  : 				CheckMenuItem(hMenu, IDM_SHOWINTRAY, MF_UNCHECKED);

  0055c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  00561	6a 00		 push	 0
  00563	6a 12		 push	 18			; 00000012H
  00565	50		 push	 eax
  00566	ff d6		 call	 esi

; 712  : 				EnableMenuItem(hMenu, IDM_ANIMATETRAYICON, MF_GRAYED);

  00568	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hMenu@@3PAUHMENU__@@A ; hMenu
  0056e	6a 01		 push	 1
  00570	6a 13		 push	 19			; 00000013H
  00572	51		 push	 ecx
  00573	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableMenuItem@12

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  00579	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  0057b	5f		 pop	 edi
  0057c	5e		 pop	 esi
  0057d	5d		 pop	 ebp
  0057e	5b		 pop	 ebx
  0057f	83 c4 08	 add	 esp, 8
  00582	c2 10 00	 ret	 16			; 00000010H
$L49131:

; 775  : 			}
; 776  : 			break;
; 777  : 
; 778  : 		case WM_COMMAND:
; 779  : 			switch ( LOWORD(wParam) )

  00585	8b 44 24 24	 mov	 eax, DWORD PTR _wParam$[esp+20]
  00589	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0058e	3d f8 03 00 00	 cmp	 eax, 1016		; 000003f8H
  00593	7f 77		 jg	 SHORT $L50030
  00595	74 56		 je	 SHORT $L49143
  00597	48		 dec	 eax
  00598	74 2d		 je	 SHORT $L49137
  0059a	48		 dec	 eax
  0059b	0f 85 94 03 00
	00		 jne	 $L50034

; 784  : 						return 0;
; 785  : 					}
; 786  : 
; 787  : 					// not really necessary
; 788  : 					DeleteTaskBarIcon( hWnd );
; 789  : 
; 790  : 					// write some reg values
; 791  : 					RegistryWrite2();
; 792  : 
; 793  : 					// tell registry we are down
; 794  : 					g_hWndCalibration = (DWORD)NULL;
; 795  : 					RegistryWrite3();
; 796  : 
; 797  : 					//EndDialog( hWnd, TRUE );  // this won't kill the app!!!
; 798  : 					DestroyWindow(hWnd);        // this won't kill the app!!!
; 799  : 					PostQuitMessage(0);         // kill!!!
; 800  : 					break;
; 801  : 
; 802  : 				case IDCANCEL:
; 803  : 					if (g_bShowInTray) {

  005a1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_bShowInTray@@3KA ; g_bShowInTray
  005a6	85 c0		 test	 eax, eax
  005a8	0f 84 cf 00 00
	00		 je	 $L49177

; 804  : 						ShowWindow(hWnd, SW_HIDE);

  005ae	8b 54 24 1c	 mov	 edx, DWORD PTR _hWnd$[esp+20]
  005b2	6a 00		 push	 0
  005b4	52		 push	 edx
  005b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  005bb	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  005bd	5f		 pop	 edi
  005be	5e		 pop	 esi
  005bf	5d		 pop	 ebp
  005c0	5b		 pop	 ebx
  005c1	83 c4 08	 add	 esp, 8
  005c4	c2 10 00	 ret	 16			; 00000010H
$L49137:

; 780  : 			{
; 781  : 				case IDOK:
; 782  : 					if (g_bShowInTray) {

  005c7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_bShowInTray@@3KA ; g_bShowInTray
  005cc	85 c0		 test	 eax, eax
  005ce	0f 84 a9 00 00
	00		 je	 $L49177

; 783  : 						ShowWindow(hWnd, SW_HIDE);

  005d4	8b 44 24 1c	 mov	 eax, DWORD PTR _hWnd$[esp+20]
  005d8	6a 00		 push	 0
  005da	50		 push	 eax
  005db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  005e1	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  005e3	5f		 pop	 edi
  005e4	5e		 pop	 esi
  005e5	5d		 pop	 ebp
  005e6	5b		 pop	 ebx
  005e7	83 c4 08	 add	 esp, 8
  005ea	c2 10 00	 ret	 16			; 00000010H
$L49143:

; 805  : 						return 0;
; 806  : 					}
; 807  : 
; 808  : 					// not really necessary
; 809  : 					DeleteTaskBarIcon( hWnd );
; 810  : 
; 811  : 					// write some reg values
; 812  : 					RegistryWrite2();
; 813  : 
; 814  : 					// tell registry we are down
; 815  : 					g_hWndCalibration = (DWORD)NULL;
; 816  : 					RegistryWrite3();
; 817  : 
; 818  : 					//EndDialog( hWnd, FALSE );
; 819  : 					DestroyWindow(hWnd);
; 820  : 					PostQuitMessage(0);
; 821  : 					break;
; 822  : 
; 823  : 				case IDC_BUTTONHELP:
; 824  : 					//WinHelp( hWnd, "..\\Help\\Rcsim.hlp", HELP_CONTEXT, 3 );
; 825  : 					HtmlHelp( hWnd, "..\\HTMLHelp\\Rcsim.chm", HH_DISPLAY_TOPIC, NULL );

  005ed	8b 4c 24 1c	 mov	 ecx, DWORD PTR _hWnd$[esp+20]
  005f1	6a 00		 push	 0
  005f3	6a 00		 push	 0
  005f5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@PCFL@?4?4?2HTMLHelp?2Rcsim?4chm?$AA@ ; `string'
  005fa	51		 push	 ecx
  005fb	e8 00 00 00 00	 call	 _HtmlHelpA@16

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  00600	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  00602	5f		 pop	 edi
  00603	5e		 pop	 esi
  00604	5d		 pop	 ebp
  00605	5b		 pop	 ebx
  00606	83 c4 08	 add	 esp, 8
  00609	c2 10 00	 ret	 16			; 00000010H
$L50030:

; 775  : 			}
; 776  : 			break;
; 777  : 
; 778  : 		case WM_COMMAND:
; 779  : 			switch ( LOWORD(wParam) )

  0060c	3d 49 9c 00 00	 cmp	 eax, 40009		; 00009c49H
  00611	0f 8f a2 00 00
	00		 jg	 $L50031
  00617	74 64		 je	 SHORT $L49177
  00619	3d ba 04 00 00	 cmp	 eax, 1210		; 000004baH
  0061e	0f 85 11 03 00
	00		 jne	 $L50034

; 826  : 					break;
; 827  : 
; 828  : 				case IDC_CALIBRATE:
; 829  : 					//GetDlgItemText()
; 830  : 					if (!g_Calibrate) {

  00624	a0 00 00 00 00	 mov	 al, BYTE PTR ?g_Calibrate@@3_NA ; g_Calibrate
  00629	84 c0		 test	 al, al
  0062b	75 28		 jne	 SHORT $L49146

; 831  : 						g_Calibrate = true;
; 832  : 						SetDlgItemText(hWnd,IDC_CALIBRATE,"&Done");

  0062d	8b 54 24 1c	 mov	 edx, DWORD PTR _hWnd$[esp+20]
  00631	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05KGKE@?$CGDone?$AA@ ; `string'
  00636	68 ba 04 00 00	 push	 1210			; 000004baH
  0063b	52		 push	 edx
  0063c	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?g_Calibrate@@3_NA, 1 ; g_Calibrate
  00643	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetDlgItemTextA@12

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  00649	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  0064b	5f		 pop	 edi
  0064c	5e		 pop	 esi
  0064d	5d		 pop	 ebp
  0064e	5b		 pop	 ebx
  0064f	83 c4 08	 add	 esp, 8
  00652	c2 10 00	 ret	 16			; 00000010H
$L49146:

; 833  : 					} else {
; 834  : 						g_Calibrate = false;
; 835  : 						SetDlgItemText(hWnd,IDC_CALIBRATE,"&Calibrate");

  00655	8b 44 24 1c	 mov	 eax, DWORD PTR _hWnd$[esp+20]
  00659	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@JGEF@?$CGCalibrate?$AA@ ; `string'
  0065e	68 ba 04 00 00	 push	 1210			; 000004baH
  00663	50		 push	 eax
  00664	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?g_Calibrate@@3_NA, 0 ; g_Calibrate
  0066b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetDlgItemTextA@12

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  00671	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  00673	5f		 pop	 edi
  00674	5e		 pop	 esi
  00675	5d		 pop	 ebp
  00676	5b		 pop	 ebx
  00677	83 c4 08	 add	 esp, 8
  0067a	c2 10 00	 ret	 16			; 00000010H
$L49177:

; 896  : 					break;
; 897  : 
; 898  : 				case ID_POPUP_EXIT:
; 899  : 					// not really necessary
; 900  : 					DeleteTaskBarIcon( hWnd );

  0067d	8b 74 24 1c	 mov	 esi, DWORD PTR _hWnd$[esp+20]
  00681	56		 push	 esi
  00682	e8 00 00 00 00	 call	 ?DeleteTaskBarIcon@@YAXPAUHWND__@@@Z ; DeleteTaskBarIcon
  00687	83 c4 04	 add	 esp, 4

; 901  : 
; 902  : 					// write some reg values
; 903  : 					RegistryWrite2();

  0068a	e8 00 00 00 00	 call	 ?RegistryWrite2@@YAXXZ	; RegistryWrite2

; 904  : 
; 905  : 					// tell registry we are down
; 906  : 					g_hWndCalibration = (DWORD)NULL;

  0068f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_hWndCalibration@@3KA, 0 ; g_hWndCalibration

; 907  : 					RegistryWrite3();

  00699	e8 00 00 00 00	 call	 ?RegistryWrite3@@YAXXZ	; RegistryWrite3

; 908  : 
; 909  : 					//EndDialog( hWnd, TRUE );  // this won't kill the app!!!
; 910  : 					DestroyWindow(hWnd);        // this won't kill the app!!!

  0069e	56		 push	 esi
  0069f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4

; 911  : 					PostQuitMessage(0);         // kill!!!

  006a5	6a 00		 push	 0
  006a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQuitMessage@4

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  006ad	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  006af	5f		 pop	 edi
  006b0	5e		 pop	 esi
  006b1	5d		 pop	 ebp
  006b2	5b		 pop	 ebx
  006b3	83 c4 08	 add	 esp, 8
  006b6	c2 10 00	 ret	 16			; 00000010H
$L50031:

; 775  : 			}
; 776  : 			break;
; 777  : 
; 778  : 		case WM_COMMAND:
; 779  : 			switch ( LOWORD(wParam) )

  006b9	05 b6 63 ff ff	 add	 eax, -40010		; ffff63b6H
  006be	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  006c1	0f 87 6e 02 00
	00		 ja	 $L50034
  006c7	33 c9		 xor	 ecx, ecx
  006c9	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR $L50047[eax]
  006cf	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L50048[ecx*4]
$L49151:

; 836  : 					}				
; 837  : 					break;
; 838  : 
; 839  : 				case ID_POPUP_CALIBRATE:
; 840  : 					//ShowWindow(hWnd, SW_SHOW);
; 841  : 					ShowWindow(hWnd, SW_RESTORE);
; 842  : 					SetForegroundWindow(hWnd);
; 843  : 					break;
; 844  : 				
; 845  : 				case ID_POPUP_RCSIMSIKORSKY:
; 846  : 					// TODO: check if rcsim is already running, if so restore/setforeground
; 847  : 					// DONE
; 848  : 					RegistryRead4();

  006d6	e8 00 00 00 00	 call	 ?RegistryRead4@@YAXXZ	; RegistryRead4

; 849  : 					if ( g_hWndSikorsky ) 

  006db	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hWndSikorsky@@3KA ; g_hWndSikorsky
  006e0	85 c0		 test	 eax, eax
  006e2	74 5a		 je	 SHORT $L49152

; 850  : 					{
; 851  : 						if ( IsMinimized((HWND)g_hWndSikorsky) )

  006e4	50		 push	 eax
  006e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsIconic@4
  006eb	85 c0		 test	 eax, eax
  006ed	74 28		 je	 SHORT $L49154

; 852  : 							ShowWindow( (HWND)g_hWndSikorsky, SW_RESTORE );

  006ef	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hWndSikorsky@@3KA ; g_hWndSikorsky
  006f5	6a 09		 push	 9
  006f7	52		 push	 edx

; 853  : 						else
; 854  : 							ShowWindow( (HWND)g_hWndSikorsky, SW_SHOW );

  006f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 855  : 						SetForegroundWindow( (HWND)g_hWndSikorsky );

  006fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hWndSikorsky@@3KA ; g_hWndSikorsky
  00704	51		 push	 ecx
  00705	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetForegroundWindow@4

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  0070b	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  0070d	5f		 pop	 edi
  0070e	5e		 pop	 esi
  0070f	5d		 pop	 ebp
  00710	5b		 pop	 ebx
  00711	83 c4 08	 add	 esp, 8
  00714	c2 10 00	 ret	 16			; 00000010H
$L49154:

; 853  : 						else
; 854  : 							ShowWindow( (HWND)g_hWndSikorsky, SW_SHOW );

  00717	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hWndSikorsky@@3KA ; g_hWndSikorsky
  0071c	6a 05		 push	 5
  0071e	50		 push	 eax
  0071f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 855  : 						SetForegroundWindow( (HWND)g_hWndSikorsky );

  00725	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hWndSikorsky@@3KA ; g_hWndSikorsky
  0072b	51		 push	 ecx
  0072c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetForegroundWindow@4

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  00732	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  00734	5f		 pop	 edi
  00735	5e		 pop	 esi
  00736	5d		 pop	 ebp
  00737	5b		 pop	 ebx
  00738	83 c4 08	 add	 esp, 8
  0073b	c2 10 00	 ret	 16			; 00000010H
$L49152:

; 856  : 					}
; 857  : 					else
; 858  : 					{
; 859  : #ifdef _DEBUG ///////////////
; 860  : 						SetCurrentDirectory("F:\\mssdk\\samples\\Multimedia\\D3DIM\\src\\XFile\\Debug");
; 861  : 						if ( -1 == _spawnl( _P_NOWAIT,
; 862  : 								"F:\\mssdk\\samples\\Multimedia\\D3DIM\\src\\XFile\\Debug\\xfile.exe",
; 863  : 								"xfile.exe", NULL ) )
; 864  : 						{
; 865  : 								MessageBox(hWnd, "Could not spawn R/C Sim.",
; 866  : 									"R/C Sim Sikorsky Error Message", MB_OK|MB_ICONERROR);
; 867  : 						}
; 868  : #else ///////////////////////						
; 869  : 						if ( -1 == _spawnl( _P_NOWAIT, "..\\bin\\xfile.exe", "xfile.exe", NULL ) ) {

  0073e	6a 00		 push	 0
  00740	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09KBJH@xfile?4exe?$AA@ ; `string'
  00745	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@IKLI@?4?4?2bin?2xfile?4exe?$AA@ ; `string'
  0074a	6a 01		 push	 1
  0074c	e8 00 00 00 00	 call	 __spawnl
  00751	83 c4 10	 add	 esp, 16			; 00000010H
  00754	83 f8 ff	 cmp	 eax, -1
  00757	0f 85 d8 01 00
	00		 jne	 $L50034

; 870  : 								MessageBox(hWnd, "Could not spawn R/C Sim.",
; 871  : 									"R/C Sim Sikorsky Error Message", MB_OK|MB_ICONERROR);

  0075d	8b 54 24 1c	 mov	 edx, DWORD PTR _hWnd$[esp+20]
  00761	6a 10		 push	 16			; 00000010H
  00763	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@PONB@R?1C?5Sim?5Sikorsky?5Error?5Message?$AA@ ; `string'
  00768	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@GJOF@Could?5not?5spawn?5R?1C?5Sim?4?$AA@ ; `string'
  0076d	52		 push	 edx
  0076e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  00774	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  00776	5f		 pop	 edi
  00777	5e		 pop	 esi
  00778	5d		 pop	 ebp
  00779	5b		 pop	 ebx
  0077a	83 c4 08	 add	 esp, 8
  0077d	c2 10 00	 ret	 16			; 00000010H
$L49166:

; 872  : 						}					
; 873  : #endif //////////////////////
; 874  : 					}
; 875  : 					break;
; 876  : 					
; 877  : 				case ID_POPUP_GALLAND:
; 878  : 					break;
; 879  : 
; 880  : 				case ID_POPUP_WEBSITE:
; 881  : 					//_spawnl( _P_NOWAIT,	"C:\\Program Files\\Internet Explorer\\IEXPLORE.EXE",
; 882  : 					//	"Iexplore.exe", "http://home.zonnet.nl/blacksphere/", NULL );
; 883  : 
; 884  : 					ShellExecute( NULL, "open", "http://home.zonnet.nl/blacksphere/", "",
; 885  : 						"c:\\", SW_SHOWNORMAL );    

  00780	6a 01		 push	 1
  00782	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03OEOK@c?3?2?$AA@ ; `string'
  00787	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
  0078c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@OPGG@http?3?1?1home?4zonnet?4nl?1blackspher@ ; `string'
  00791	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04KHOB@open?$AA@ ; `string'
  00796	6a 00		 push	 0
  00798	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShellExecuteA@24

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  0079e	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  007a0	5f		 pop	 edi
  007a1	5e		 pop	 esi
  007a2	5d		 pop	 ebp
  007a3	5b		 pop	 ebx
  007a4	83 c4 08	 add	 esp, 8
  007a7	c2 10 00	 ret	 16			; 00000010H
$L49171:

; 886  : 					break;
; 887  : 
; 888  : 				case ID_POPUP_HELP:
; 889  : 					//WinHelp( hWnd, "..\\Help\\Rcsim.hlp", HELP_CONTEXT, 3 );
; 890  : 					HtmlHelp( hWnd, "..\\HTMLHelp\\Rcsim.chm", HH_DISPLAY_TOPIC, NULL );

  007aa	8b 44 24 1c	 mov	 eax, DWORD PTR _hWnd$[esp+20]
  007ae	6a 00		 push	 0
  007b0	6a 00		 push	 0
  007b2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@PCFL@?4?4?2HTMLHelp?2Rcsim?4chm?$AA@ ; `string'
  007b7	50		 push	 eax
  007b8	e8 00 00 00 00	 call	 _HtmlHelpA@16

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  007bd	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  007bf	5f		 pop	 edi
  007c0	5e		 pop	 esi
  007c1	5d		 pop	 ebp
  007c2	5b		 pop	 ebx
  007c3	83 c4 08	 add	 esp, 8
  007c6	c2 10 00	 ret	 16			; 00000010H
$L49172:

; 891  : 					break;
; 892  : 
; 893  : 				case ID_POPUP_ABOUT:
; 894  : 					DialogBox(g_hInst, MAKEINTRESOURCE(IDD_ABOUT), hWnd,
; 895  : 								(DLGPROC)AboutProc );

  007c9	8b 4c 24 1c	 mov	 ecx, DWORD PTR _hWnd$[esp+20]
  007cd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hInst@@3PAUHINSTANCE__@@A ; g_hInst
  007d3	6a 00		 push	 0
  007d5	68 00 00 00 00	 push	 OFFSET FLAT:?AboutProc@@YGHPAUHWND__@@IIJ@Z ; AboutProc
  007da	51		 push	 ecx
  007db	6a 6a		 push	 106			; 0000006aH
  007dd	52		 push	 edx
  007de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DialogBoxParamA@20

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  007e4	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  007e6	5f		 pop	 edi
  007e7	5e		 pop	 esi
  007e8	5d		 pop	 ebp
  007e9	5b		 pop	 ebx
  007ea	83 c4 08	 add	 esp, 8
  007ed	c2 10 00	 ret	 16			; 00000010H
$L49180:

; 947  : 			  break;
; 948  : 
; 949  : 		/*case WM_PAINT:
; 950  : 			PAINTSTRUCT ps;
; 951  : 			BeginPaint(hWnd, &ps);
; 952  : 
; 953  : 			EndPaint(hWnd, &ps);
; 954  : 			return TRUE;
; 955  : 			break;*/
; 956  : 
; 957  : 		case WM_TIMER:	// gets keyboard input
; 958  : 			if (GetKeyState(VK_F1) & 0x80)

  007f0	6a 70		 push	 112			; 00000070H
  007f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetKeyState@4
  007f8	a8 80		 test	 al, -128		; ffffff80H
  007fa	74 13		 je	 SHORT $L49181

; 959  : 				//WinHelp( hWnd, "..\\Help\\Rcsim.hlp", HELP_CONTEXT, 3 );
; 960  : 				HtmlHelp( hWnd, "..\\HTMLHelp\\Rcsim.chm", HH_DISPLAY_TOPIC, NULL );

  007fc	8b 44 24 1c	 mov	 eax, DWORD PTR _hWnd$[esp+20]
  00800	6a 00		 push	 0
  00802	6a 00		 push	 0
  00804	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@PCFL@?4?4?2HTMLHelp?2Rcsim?4chm?$AA@ ; `string'
  00809	50		 push	 eax
  0080a	e8 00 00 00 00	 call	 _HtmlHelpA@16
$L49181:

; 961  : 
; 962  : 
; 963  : 			// We are putting this in timerloop instead of gameloop to prevent fucky
; 964  : 			// system menu behaviour
; 965  : 			if (g_bShowInTray) {

  0080f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_bShowInTray@@3KA ; g_bShowInTray
  00814	85 c0		 test	 eax, eax
  00816	0f 84 19 01 00
	00		 je	 $L50034

; 966  : 				if (!g_bAnimateTrayIcon) 

  0081c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_bAnimateTrayIcon@@3KA ; g_bAnimateTrayIcon
  00821	85 c0		 test	 eax, eax
  00823	0f 85 0c 01 00
	00		 jne	 $L50034

; 967  : 				{
; 968  : 					switch ( iSignalStatus )

  00829	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iSignalStatus@@3HA ; iSignalStatus
  0082e	83 e8 00	 sub	 eax, 0
  00831	74 79		 je	 SHORT $L49188
  00833	48		 dec	 eax
  00834	74 3f		 je	 SHORT $L49193
  00836	48		 dec	 eax
  00837	0f 85 f8 00 00
	00		 jne	 $L50034

; 977  : 							break;
; 978  : 						case 2:
; 979  : 							hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1) );

  0083d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hInst@@3PAUHINSTANCE__@@A ; g_hInst
  00843	68 84 00 00 00	 push	 132			; 00000084H
  00848	51		 push	 ecx
  00849	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadIconA@8

; 980  : 							ModifyTaskBarIcon( g_hWnd, hIcon2, szTip );

  0084f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hWnd@@3PAUHWND__@@A ; g_hWnd
  00855	68 00 00 00 00	 push	 OFFSET FLAT:?szTip@@3PADA ; szTip
  0085a	50		 push	 eax
  0085b	52		 push	 edx
  0085c	a3 00 00 00 00	 mov	 DWORD PTR ?hIcon2@@3PAUHICON__@@A, eax ; hIcon2
  00861	e8 00 00 00 00	 call	 ?ModifyTaskBarIcon@@YAXPAUHWND__@@PAUHICON__@@PAD@Z ; ModifyTaskBarIcon
  00866	83 c4 0c	 add	 esp, 12			; 0000000cH

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  00869	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  0086b	5f		 pop	 edi
  0086c	5e		 pop	 esi
  0086d	5d		 pop	 ebp
  0086e	5b		 pop	 ebx
  0086f	83 c4 08	 add	 esp, 8
  00872	c2 10 00	 ret	 16			; 00000010H
$L49193:

; 973  : 							break;
; 974  : 						case 1:
; 975  : 							hIcon1 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON11) );

  00875	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hInst@@3PAUHINSTANCE__@@A ; g_hInst
  0087a	68 8d 00 00 00	 push	 141			; 0000008dH
  0087f	50		 push	 eax
  00880	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadIconA@8

; 976  : 							ModifyTaskBarIcon( g_hWnd, hIcon1, szTip );

  00886	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hWnd@@3PAUHWND__@@A ; g_hWnd
  0088c	68 00 00 00 00	 push	 OFFSET FLAT:?szTip@@3PADA ; szTip
  00891	50		 push	 eax
  00892	51		 push	 ecx
  00893	a3 00 00 00 00	 mov	 DWORD PTR ?hIcon1@@3PAUHICON__@@A, eax ; hIcon1
  00898	e8 00 00 00 00	 call	 ?ModifyTaskBarIcon@@YAXPAUHWND__@@PAUHICON__@@PAD@Z ; ModifyTaskBarIcon
  0089d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  008a0	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  008a2	5f		 pop	 edi
  008a3	5e		 pop	 esi
  008a4	5d		 pop	 ebp
  008a5	5b		 pop	 ebx
  008a6	83 c4 08	 add	 esp, 8
  008a9	c2 10 00	 ret	 16			; 00000010H
$L49188:

; 969  : 					{ 
; 970  : 						case 0:
; 971  : 							hIcon0 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON10) );

  008ac	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hInst@@3PAUHINSTANCE__@@A ; g_hInst
  008b2	68 8c 00 00 00	 push	 140			; 0000008cH
  008b7	52		 push	 edx
  008b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadIconA@8

; 972  : 							ModifyTaskBarIcon( g_hWnd, hIcon0, szTip );

  008be	68 00 00 00 00	 push	 OFFSET FLAT:?szTip@@3PADA ; szTip
  008c3	a3 00 00 00 00	 mov	 DWORD PTR ?hIcon0@@3PAUHICON__@@A, eax ; hIcon0
  008c8	50		 push	 eax
  008c9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hWnd@@3PAUHWND__@@A ; g_hWnd
  008ce	50		 push	 eax
  008cf	e8 00 00 00 00	 call	 ?ModifyTaskBarIcon@@YAXPAUHWND__@@PAUHICON__@@PAD@Z ; ModifyTaskBarIcon
  008d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  008d7	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  008d9	5f		 pop	 edi
  008da	5e		 pop	 esi
  008db	5d		 pop	 ebp
  008dc	5b		 pop	 ebx
  008dd	83 c4 08	 add	 esp, 8
  008e0	c2 10 00	 ret	 16			; 00000010H
$L49109:

; 713  : 			}
; 714  : 			break;
; 715  : 
; 716  : 		case MYWM_CLICKONTASKBARICON:	// Taskbar-Icon 
; 717  : 			switch (lParam)

  008e3	8b 44 24 28	 mov	 eax, DWORD PTR _lParam$[esp+20]
  008e7	2d 02 02 00 00	 sub	 eax, 514		; 00000202H
  008ec	74 47		 je	 SHORT $L50034
  008ee	48		 dec	 eax
  008ef	74 30		 je	 SHORT $L49116
  008f1	83 e8 02	 sub	 eax, 2

; 731  : 					break;
; 732  : 
; 733  : 				default:
; 734  : 					return FALSE;

  008f4	75 3f		 jne	 SHORT $L50034
  008f6	8d 4c 24 10	 lea	 ecx, DWORD PTR _pt$[esp+24]
  008fa	51		 push	 ecx
  008fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCursorPos@4
  00901	8b 54 24 14	 mov	 edx, DWORD PTR _pt$[esp+28]
  00905	8b 44 24 10	 mov	 eax, DWORD PTR _pt$[esp+24]
  00909	8b 4c 24 1c	 mov	 ecx, DWORD PTR _hWnd$[esp+20]
  0090d	52		 push	 edx
  0090e	50		 push	 eax
  0090f	51		 push	 ecx
  00910	e8 00 00 00 00	 call	 ?DisplayContextMenu2@@YGXPAUHWND__@@UtagPOINT@@@Z ; DisplayContextMenu2

; 981  : 							break;
; 982  : 					}
; 983  : 				}
; 984  : 			}
; 985  : 
; 986  : /*
; 987  : 			// animate tray icon
; 988  : 			hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+i) );
; 989  : 			i++;
; 990  : 			if (i > 3) i = 0;
; 991  : 			
; 992  : 			if (g_bShowInTray) {
; 993  : 				ModifyTaskBarIcon( g_hWnd, hIcon2 );
; 994  : 			}
; 995  : */			
; 996  : /*
; 997  : 			// kludge
; 998  : 			// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 999  : 			// just under menu will not dismiss it. Let's do that ourselves
; 1000 : 			// Don't work...
; 1001 : 			if (g_hmenuTrackPopupTray) {
; 1002 : 				if ( (GetKeyState(VK_LBUTTON) & 0x80) || (GetKeyState(VK_RBUTTON) & 0x80) ) {
; 1003 : 					CloseWindow( (HWND)g_hmenuTrackPopupTray );
; 1004 : 					MessageBeep(-1);
; 1005 : 				}
; 1006 : 			}
; 1007 : */
; 1008 : /*
; 1009 : 			// show bitmap in tray popup menu
; 1010 : 			// Does not work like this: got to create a ownner-draw menu item.
; 1011 : 			// Then handle WM_MEASUREITEM and WM_DRAWITEM
; 1012 : 			if (g_hmenuTrackPopupTray) {
; 1013 : 
; 1014 : 				MessageBeep(-1);
; 1015 : 
; 1016 : 				//hdcDest = GetDC( (HWND)NULL );
; 1017 : 				hdcDest = GetDC( (HWND)g_hmenuTrackPopupTray );
; 1018 : 
; 1019 : 				hdcMemory = CreateCompatibleDC(hdcDest);
; 1020 : 
; 1021 : 				hbmBack1 = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP2));
; 1022 : 				SelectObject(hdcMemory, hbmBack1);
; 1023 : 
; 1024 : 				x = 0;
; 1025 : 				y = 0;
; 1026 : 
; 1027 : 				//GetWindowRect( (HWND)g_hmenuTrackPopupTray, &rc );
; 1028 : 
; 1029 : 				// blt to window
; 1030 : 				//BitBlt(hdcDest, 0, 0, 21, 20, hdcMemory, x, y, SRCCOPY);
; 1031 : 
; 1032 : 				ReleaseDC( (HWND)g_hmenuTrackPopupTray, hdcDest );
; 1033 : 				
; 1034 : 				// Clean up
; 1035 : 				DeleteDC( hdcMemory );
; 1036 : 
; 1037 : 				// laat het geheugen niet vollopen...
; 1038 : 				DeleteObject(hbmBack1);
; 1039 : 			}
; 1040 : */
; 1041 : 			break;
; 1042 : 
; 1043 : 		default:
; 1044 : 			return FALSE;

  00915	33 c0		 xor	 eax, eax

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  00917	5f		 pop	 edi
  00918	5e		 pop	 esi
  00919	5d		 pop	 ebp
  0091a	5b		 pop	 ebx
  0091b	83 c4 08	 add	 esp, 8
  0091e	c2 10 00	 ret	 16			; 00000010H
$L49116:

; 718  : 			{
; 719  : 				case WM_LBUTTONUP:
; 720  : 					break;
; 721  : 
; 722  : 				case WM_RBUTTONUP:
; 723  : 					GetCursorPos(&pt);
; 724  : 					DisplayContextMenu2(hWnd, pt);
; 725  : 					break;
; 726  : 
; 727  : 				case WM_LBUTTONDBLCLK:
; 728  : 					//ShowWindow(hWnd, SW_SHOW);
; 729  : 					ShowWindow(hWnd, SW_RESTORE);

  00921	8b 74 24 1c	 mov	 esi, DWORD PTR _hWnd$[esp+20]
  00925	6a 09		 push	 9
  00927	56		 push	 esi
  00928	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 730  : 					SetForegroundWindow(hWnd);

  0092e	56		 push	 esi
  0092f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetForegroundWindow@4
$L50034:

; 1045 : 	}
; 1046 : 	return FALSE;
; 1047 : }

  00935	5f		 pop	 edi
  00936	5e		 pop	 esi
  00937	5d		 pop	 ebp
  00938	33 c0		 xor	 eax, eax
  0093a	5b		 pop	 ebx
  0093b	83 c4 08	 add	 esp, 8
  0093e	c2 10 00	 ret	 16			; 00000010H
  00941	90		 npad	 1
  00942	8b ff		 npad	 2
$L50045:
  00944	00 00 00 00	 DD	 $L49131
  00948	00 00 00 00	 DD	 $L49078
  0094c	00 00 00 00	 DD	 $L49180
  00950	00 00 00 00	 DD	 $L50034
  00954	00 00 00 00	 DD	 $L50034
  00958	00 00 00 00	 DD	 $L49103
$L50046:
  0095c	00 00 00 00	 DD	 $L49087
  00960	00 00 00 00	 DD	 $L49092
  00964	00 00 00 00	 DD	 $L49097
  00968	00 00 00 00	 DD	 $L49100
$L50048:
  0096c	00 00 00 00	 DD	 $L49172
  00970	00 00 00 00	 DD	 $L49116
  00974	00 00 00 00	 DD	 $L49171
  00978	00 00 00 00	 DD	 $L49151
  0097c	00 00 00 00	 DD	 $L49166
  00980	00 00 00 00	 DD	 $L50034
$L50047:
  00984	00		 DB	 0
  00985	01		 DB	 1
  00986	02		 DB	 2
  00987	05		 DB	 5
  00988	05		 DB	 5
  00989	05		 DB	 5
  0098a	05		 DB	 5
  0098b	05		 DB	 5
  0098c	05		 DB	 5
  0098d	03		 DB	 3
  0098e	05		 DB	 5
  0098f	05		 DB	 5
  00990	05		 DB	 5
  00991	04		 DB	 4
?DlgWndProc@@YGJPAUHWND__@@IIJ@Z ENDP			; DlgWndProc
_TEXT	ENDS
PUBLIC	??_C@_0BM@LCGE@No?5Signal?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$AA@ ; `string'
PUBLIC	??_C@_09JHMD@No?5Signal?$AA@			; `string'
PUBLIC	??_C@_0BI@PAHP@Signal?5Defective?5?5?5?5?5?5?5?$AA@ ; `string'
PUBLIC	??_C@_0BB@CPII@Signal?5Defective?$AA@		; `string'
PUBLIC	??_C@_0BI@LGIH@Signal?5Connected?5?5?5?5?5?5?5?$AA@ ; `string'
PUBLIC	??_C@_0BB@OJAH@Signal?5Connected?$AA@		; `string'
PUBLIC	??_C@_0BC@DHLA@?$CF?43f?5ms?5?5?5?5?5?5?5?5?5?5?$AA@ ; `string'
PUBLIC	??_C@_0O@DFPO@?$CF?43f?5ms?5?5?5?5?5?5?$AA@	; `string'
PUBLIC	??_C@_0O@EPNC@?$CF6?43f?5ms?5?5?5?5?5?$AA@	; `string'
PUBLIC	??_C@_0P@KKMC@?$CF7?43f?5ms?5?5?5?5?5?5?$AA@	; `string'
PUBLIC	??_C@_08FJKB@?$CF7?43f?5ms?$AA@			; `string'
PUBLIC	??_C@_0CD@LHJF@R?1C?5Sim?5Transmitter?5Calibration?5@ ; `string'
PUBLIC	?DrawBarEx@@YAXPAUHWND__@@H_NKK@Z		; DrawBarEx
EXTRN	__imp__SetDlgItemInt@16:NEAR
EXTRN	_sprintf:NEAR
EXTRN	__imp__DestroyIcon@4:NEAR
EXTRN	__imp__Sleep@4:NEAR
EXTRN	__fltused:NEAR
EXTRN	__imp__DeviceIoControl@32:NEAR
;	COMDAT ??_C@_0BM@LCGE@No?5Signal?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$AA@
; File E:\interface\TxintguiSDK\Bigpush\bigpush.cpp
_DATA	SEGMENT
??_C@_0BM@LCGE@No?5Signal?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$AA@ DB 'No'
	DB	' Signal                  ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09JHMD@No?5Signal?$AA@
_DATA	SEGMENT
??_C@_09JHMD@No?5Signal?$AA@ DB 'No Signal', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BI@PAHP@Signal?5Defective?5?5?5?5?5?5?5?$AA@
_DATA	SEGMENT
??_C@_0BI@PAHP@Signal?5Defective?5?5?5?5?5?5?5?$AA@ DB 'Signal Defective '
	DB	'      ', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@CPII@Signal?5Defective?$AA@
_DATA	SEGMENT
??_C@_0BB@CPII@Signal?5Defective?$AA@ DB 'Signal Defective', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BI@LGIH@Signal?5Connected?5?5?5?5?5?5?5?$AA@
_DATA	SEGMENT
??_C@_0BI@LGIH@Signal?5Connected?5?5?5?5?5?5?5?$AA@ DB 'Signal Connected '
	DB	'      ', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@OJAH@Signal?5Connected?$AA@
_DATA	SEGMENT
??_C@_0BB@OJAH@Signal?5Connected?$AA@ DB 'Signal Connected', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@DHLA@?$CF?43f?5ms?5?5?5?5?5?5?5?5?5?5?$AA@
_DATA	SEGMENT
??_C@_0BC@DHLA@?$CF?43f?5ms?5?5?5?5?5?5?5?5?5?5?$AA@ DB '%.3f ms         '
	DB	' ', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@DFPO@?$CF?43f?5ms?5?5?5?5?5?5?$AA@
_DATA	SEGMENT
??_C@_0O@DFPO@?$CF?43f?5ms?5?5?5?5?5?5?$AA@ DB '%.3f ms      ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@EPNC@?$CF6?43f?5ms?5?5?5?5?5?$AA@
_DATA	SEGMENT
??_C@_0O@EPNC@?$CF6?43f?5ms?5?5?5?5?5?$AA@ DB '%6.3f ms     ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@KKMC@?$CF7?43f?5ms?5?5?5?5?5?5?$AA@
_DATA	SEGMENT
??_C@_0P@KKMC@?$CF7?43f?5ms?5?5?5?5?5?5?$AA@ DB '%7.3f ms      ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_08FJKB@?$CF7?43f?5ms?$AA@
_DATA	SEGMENT
??_C@_08FJKB@?$CF7?43f?5ms?$AA@ DB '%7.3f ms', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CD@LHJF@R?1C?5Sim?5Transmitter?5Calibration?5@
_DATA	SEGMENT
??_C@_0CD@LHJF@R?1C?5Sim?5Transmitter?5Calibration?5@ DB 'R/C Sim Transmi'
	DB	'tter Calibration - ', 00H			; `string'
_DATA	ENDS
CONST	SEGMENT
$T50059	DD	03a83126fr			; 0.001
CONST	ENDS
;	COMDAT ?GameLoop@@YAXXZ
_TEXT	SEGMENT
_status$ = -1536
_sync$ = -768
_ch1$ = -1280
_ch2$ = -256
_ch3$ = -1024
_ch4$ = -512
_ch5$ = -1664
_ch6$ = -1408
_ch7$ = -1152
_ch8$ = -896
_ch9$ = -640
_ch10$ = -384
_newint$ = -1797
_fsync$ = -1716
_fch1$ = -1724
_fch2$ = -1772
_fch3$ = -1756
_fch4$ = -1796
_fch5$ = -1788
_fch6$ = -1780
_fch7$ = -1764
_fch8$ = -1732
_fch9$ = -1740
_fch10$ = -1748
_entry$49414 = -1708
_pulselength$49436 = -128
?GameLoop@@YAXXZ PROC NEAR				; GameLoop, COMDAT

; 1057 : {

  00000	81 ec 08 07 00
	00		 sub	 esp, 1800		; 00000708H

; 1058 : 	
; 1059 : 	// Poll the VxD values
; 1060 : 	DeviceIoControl(hVxD, VMYXD_APIFUNC_1,
; 1061 : 		(LPVOID)NULL, 0,
; 1062 : 		(LPVOID)RetInfo, sizeof(RetInfo),
; 1063 : 		&cbBytesReturned, NULL);

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hVxD@@3PAXA ; hVxD
  0000b	53		 push	 ebx
  0000c	55		 push	 ebp
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	33 ff		 xor	 edi, edi
  00011	57		 push	 edi
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?cbBytesReturned@@3KA ; cbBytesReturned
  00017	68 60 01 00 00	 push	 352			; 00000160H
  0001c	68 00 00 00 00	 push	 OFFSET FLAT:?RetInfo@@3PAHA ; RetInfo
  00021	57		 push	 edi
  00022	57		 push	 edi
  00023	6a 01		 push	 1
  00025	50		 push	 eax
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  0002c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?RetInfo@@3PAHA ; RetInfo
$L49208:

; 1088 : 		if (RetInfo[i] != 0) RetInfo[i]-=250; // leave unused channels alone

  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	3b cf		 cmp	 ecx, edi
  00035	74 08		 je	 SHORT $L49211
  00037	81 c1 06 ff ff
	ff		 add	 ecx, -250		; ffffff06H
  0003d	89 08		 mov	 DWORD PTR [eax], ecx
$L49211:

; 1089 : 		// RetInfo[i] must be signed here!!!!!!!!!!!!!!!!!!
; 1090 : 		// We've changed it from DWORD to int so it's OK now
; 1091 : 		if (RetInfo[i] < 0)  RetInfo[i] =  0; // never print negative values

  0003f	39 38		 cmp	 DWORD PTR [eax], edi
  00041	7d 02		 jge	 SHORT $L49209
  00043	89 38		 mov	 DWORD PTR [eax], edi
$L49209:

; 1064 : 
; 1065 : 	
; 1066 : 	// This is the buffer we get from the VxD
; 1067 : 	// RetInfo[0]  == SyncPulse
; 1068 : 
; 1069 : 	// RetInfo[1]  == Ch1
; 1070 : 	// RetInfo[2]  == Ch2
; 1071 : 	// RetInfo[3]  == Ch3
; 1072 : 	// RetInfo[4]  == Ch4
; 1073 : 	// RetInfo[5]  == Ch5
; 1074 : 	// RetInfo[6]  == Ch6
; 1075 : 	// RetInfo[7]  == Ch7			
; 1076 : 	// RetInfo[8]  == Ch8
; 1077 : 	// RetInfo[9]  == Ch9
; 1078 : 	// RetInfo[10] == Ch10
; 1079 : 
; 1080 : 	// RetInfo[11] == IntCount
; 1081 : 	// RetInfo[12] == PulseLength
; 1082 : 	// RetInfo[13] == ChannelCount
; 1083 : 
; 1084 : 
; 1085 : 	
; 1086 : 	// maak 1000-2000 uS
; 1087 : 	for (int i=0; i<=10; i++) {

  00045	83 c0 04	 add	 eax, 4
  00048	3d 28 00 00 00	 cmp	 eax, OFFSET FLAT:?RetInfo@@3PAHA+40
  0004d	7e e2		 jle	 SHORT $L49208

; 1092 : 	}
; 1093 : 
; 1094 : 
; 1095 : 	char status[128];
; 1096 : 	char sync[128];
; 1097 : 	char ch1[128];
; 1098 : 	char ch2[128];
; 1099 : 	char ch3[128];
; 1100 : 	char ch4[128];
; 1101 : 	char ch5[128];
; 1102 : 	char ch6[128];
; 1103 : 	char ch7[128];
; 1104 : 	char ch8[128];
; 1105 : 	char ch9[128];
; 1106 : 	char ch10[128];
; 1107 : 
; 1108 : 
; 1109 : 
; 1110 : 	bool newint = false;
; 1111 : 	// get total number of interrupts
; 1112 : 	if ( RetInfo[11] > IntCount ) {

  0004f	a1 2c 00 00 00	 mov	 eax, DWORD PTR ?RetInfo@@3PAHA+44
  00054	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?IntCount@@3HA ; IntCount
  0005a	3b c1		 cmp	 eax, ecx
  0005c	c6 44 24 13 00	 mov	 BYTE PTR _newint$[esp+1816], 0
  00061	7e 0a		 jle	 SHORT $L49226

; 1113 : 		newint = true;

  00063	c6 44 24 13 01	 mov	 BYTE PTR _newint$[esp+1816], 1

; 1114 : 		IntCount = RetInfo[11];

  00068	a3 00 00 00 00	 mov	 DWORD PTR ?IntCount@@3HA, eax ; IntCount
$L49226:

; 1115 : 	}
; 1116 : 
; 1117 : 	// get total number of channels
; 1118 : 	if ( RetInfo[13] > ChannelTotal )

  0006d	a1 34 00 00 00	 mov	 eax, DWORD PTR ?RetInfo@@3PAHA+52
  00072	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ChannelTotal@@3HA ; ChannelTotal
  00078	3b c2		 cmp	 eax, edx
  0007a	7e 08		 jle	 SHORT $L49227

; 1119 : 					ChannelTotal = RetInfo[13];

  0007c	8b d0		 mov	 edx, eax
  0007e	89 15 00 00 00
	00		 mov	 DWORD PTR ?ChannelTotal@@3HA, edx ; ChannelTotal
$L49227:

; 1120 : 
; 1121 : 	// set unused channels at length 0
; 1122 : 	for (i=10; i>ChannelTotal; i--) {

  00084	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00087	7d 14		 jge	 SHORT $L49230
  00089	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0008e	b8 28 00 00 00	 mov	 eax, OFFSET FLAT:?RetInfo@@3PAHA+40
  00093	2b ca		 sub	 ecx, edx
$L49228:

; 1123 : 		RetInfo[i] = 0;

  00095	89 38		 mov	 DWORD PTR [eax], edi
  00097	83 e8 04	 sub	 eax, 4
  0009a	49		 dec	 ecx
  0009b	75 f8		 jne	 SHORT $L49228
$L49230:

; 1124 : 		//ChL[i] = L[0];
; 1125 : 	}
; 1126 : 
; 1127 : 
; 1128 : 	// TODO: catch Frame Data Defective: dat is wanneer sync pulse of channels
; 1129 : 	// buiten de te verwachten waarden vallen
; 1130 : 	//bool datadef = false;
; 1131 : 	if (RetInfo[0] < 5000 /*|| RetInfo[0] > 15000*/) ChannelTotal = 0;	// check sync

  0009d	81 3d 00 00 00
	00 88 13 00 00	 cmp	 DWORD PTR ?RetInfo@@3PAHA, 5000 ; 00001388H
  000a7	7d 08		 jge	 SHORT $L49231
  000a9	33 d2		 xor	 edx, edx
  000ab	89 15 00 00 00
	00		 mov	 DWORD PTR ?ChannelTotal@@3HA, edx ; ChannelTotal
$L49231:

; 1132 : 	for (i=1; i<=ChannelTotal; i++) {

  000b1	be 01 00 00 00	 mov	 esi, 1
  000b6	3b d6		 cmp	 edx, esi
  000b8	7c 25		 jl	 SHORT $L49234
  000ba	b9 04 00 00 00	 mov	 ecx, OFFSET FLAT:?RetInfo@@3PAHA+4
$L49232:

; 1133 : 		if (RetInfo[i] < 600 || RetInfo[i] > 2400) {		// check channels

  000bf	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c1	3d 58 02 00 00	 cmp	 eax, 600		; 00000258H
  000c6	7c 07		 jl	 SHORT $L49236
  000c8	3d 60 09 00 00	 cmp	 eax, 2400		; 00000960H
  000cd	7e 02		 jle	 SHORT $L49233
$L49236:

; 1134 : 			//datadef = true;
; 1135 : 			ChannelTotal = 0;

  000cf	33 d2		 xor	 edx, edx
$L49233:

; 1132 : 	for (i=1; i<=ChannelTotal; i++) {

  000d1	46		 inc	 esi
  000d2	83 c1 04	 add	 ecx, 4
  000d5	3b f2		 cmp	 esi, edx
  000d7	7e e6		 jle	 SHORT $L49232

; 1134 : 			//datadef = true;
; 1135 : 			ChannelTotal = 0;

  000d9	89 15 00 00 00
	00		 mov	 DWORD PTR ?ChannelTotal@@3HA, edx ; ChannelTotal
$L49234:

; 1136 : 			//ChL[i] = L[0];
; 1137 : 		}
; 1138 : 	}
; 1139 : 	
; 1140 : 	// Als de zender uit wordt gezet zal in
; 1141 : 	// de VxD ChannelCount op blijft lopen (omdat geen Sync Pulse meer zal worden
; 1142 : 	// gevonden die ChannelCount op 0 zet (in de VxD zelf))
; 1143 : 	
; 1144 : 	// We kunnen dus veel beter OOK een hoog oplopende ChannelTotal als indicatie
; 1145 : 	// beschouwen van defective data.
; 1146 : 	// Zeker omdat de sync en channels soms toevallig toch binnen de waardes
; 1147 : 	// vallen, terwijl hoog oplopende ChannelTotal duidelijk betekent: fucky data
; 1148 : 	if (ChannelTotal > 10)

  000df	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  000e2	7e 06		 jle	 SHORT $L49237

; 1149 : 			ChannelTotal = 0;

  000e4	89 3d 00 00 00
	00		 mov	 DWORD PTR ?ChannelTotal@@3HA, edi ; ChannelTotal
$L49237:

; 1150 : 
; 1151 : 
; 1152 : 	
; 1153 : 	// set channels to 0 when they are deactivated by mute button
; 1154 : 	for (i=1; i<=10; i++) {

  000ea	b9 01 00 00 00	 mov	 ecx, 1
  000ef	b8 04 00 00 00	 mov	 eax, OFFSET FLAT:?RetInfo@@3PAHA+4
$L49238:

; 1155 : 		if (g_bChMute[i]) RetInfo[i] = 0;

  000f4	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR ?g_bChMute@@3PA_NA[ecx]
  000fa	84 d2		 test	 dl, dl
  000fc	74 02		 je	 SHORT $L49239
  000fe	89 38		 mov	 DWORD PTR [eax], edi
$L49239:

; 1150 : 
; 1151 : 
; 1152 : 	
; 1153 : 	// set channels to 0 when they are deactivated by mute button
; 1154 : 	for (i=1; i<=10; i++) {

  00100	83 c0 04	 add	 eax, 4
  00103	41		 inc	 ecx
  00104	3d 28 00 00 00	 cmp	 eax, OFFSET FLAT:?RetInfo@@3PAHA+40
  00109	7e e9		 jle	 SHORT $L49238

; 1156 : 	}
; 1157 : 
; 1158 : 
; 1159 : 
; 1160 : 	
; 1161 : 	// values to be printed
; 1162 : 	float fsync = (float)RetInfo[0]/1000 ;

  0010b	db 05 00 00 00
	00		 fild	 DWORD PTR ?RetInfo@@3PAHA

; 1163 : 	float fch1  = (float)RetInfo[1]/1000 ;

  00111	db 05 04 00 00
	00		 fild	 DWORD PTR ?RetInfo@@3PAHA+4

; 1164 : 	float fch2  = (float)RetInfo[2]/1000 ;

  00117	db 05 08 00 00
	00		 fild	 DWORD PTR ?RetInfo@@3PAHA+8
  0011d	d9 ca		 fxch	 ST(2)
  0011f	d8 0d 00 00 00
	00		 fmul	 DWORD PTR $T50059

; 1165 : 	float fch3  = (float)RetInfo[3]/1000 ;

  00125	db 05 0c 00 00
	00		 fild	 DWORD PTR ?RetInfo@@3PAHA+12
  0012b	d9 ca		 fxch	 ST(2)
  0012d	d8 0d 00 00 00
	00		 fmul	 DWORD PTR $T50059

; 1166 : 	float fch4  = (float)RetInfo[4]/1000 ;

  00133	db 05 10 00 00
	00		 fild	 DWORD PTR ?RetInfo@@3PAHA+16
  00139	d9 cc		 fxch	 ST(4)
  0013b	d8 0d 00 00 00
	00		 fmul	 DWORD PTR $T50059

; 1167 : 	float fch5  = (float)RetInfo[5]/1000 ;

  00141	db 05 14 00 00
	00		 fild	 DWORD PTR ?RetInfo@@3PAHA+20
  00147	d9 cc		 fxch	 ST(4)
  00149	d8 0d 00 00 00
	00		 fmul	 DWORD PTR $T50059

; 1168 : 	float fch6  = (float)RetInfo[6]/1000 ;

  0014f	db 05 18 00 00
	00		 fild	 DWORD PTR ?RetInfo@@3PAHA+24
  00155	d9 ce		 fxch	 ST(6)
  00157	d8 0d 00 00 00
	00		 fmul	 DWORD PTR $T50059

; 1169 : 	float fch7  = (float)RetInfo[7]/1000 ;

  0015d	db 05 1c 00 00
	00		 fild	 DWORD PTR ?RetInfo@@3PAHA+28
  00163	d9 ce		 fxch	 ST(6)
  00165	d8 0d 00 00 00
	00		 fmul	 DWORD PTR $T50059
  0016b	d9 cf		 fxch	 ST(7)

; 1170 : 	float fch8  = (float)RetInfo[8]/1000 ;
; 1171 : 	float fch9  = (float)RetInfo[9]/1000 ;
; 1172 : 	float fch10 = (float)RetInfo[10]/1000;
; 1173 : 
; 1174 : 	// klein beetje vertragen anders loopt GameLoop() sneller dan er interrupts
; 1175 : 	// worden ontvangen en zouden we No Signal printen
; 1176 : 	// Dit werkt ook prima tegen text flicker in de static controls: te snel updaten
; 1177 : 	// is niet goed
; 1178 : 	// Probleem is dat we afhankelijk van de CPU snelheid kunnen zijn...
; 1179 : 	Sleep(20);

  0016d	d8 0d 00 00 00
	00		 fmul	 DWORD PTR $T50059
  00173	d9 cd		 fxch	 ST(5)
  00175	d9 5c 24 64	 fstp	 DWORD PTR _fsync$[esp+1816]
  00179	d9 cd		 fxch	 ST(5)
  0017b	d8 0d 00 00 00
	00		 fmul	 DWORD PTR $T50059
  00181	db 05 20 00 00
	00		 fild	 DWORD PTR ?RetInfo@@3PAHA+32
  00187	d9 cc		 fxch	 ST(4)
  00189	d9 5c 24 5c	 fstp	 DWORD PTR _fch1$[esp+1816]
  0018d	db 05 24 00 00
	00		 fild	 DWORD PTR ?RetInfo@@3PAHA+36
  00193	d9 cc		 fxch	 ST(4)
  00195	d8 0d 00 00 00
	00		 fmul	 DWORD PTR $T50059
  0019b	d9 cb		 fxch	 ST(3)
  0019d	d9 5c 24 2c	 fstp	 DWORD PTR _fch2$[esp+1816]
  001a1	d9 cb		 fxch	 ST(3)
  001a3	d8 0d 00 00 00
	00		 fmul	 DWORD PTR $T50059
  001a9	db 05 28 00 00
	00		 fild	 DWORD PTR ?RetInfo@@3PAHA+40
  001af	d9 ca		 fxch	 ST(2)
  001b1	d9 5c 24 3c	 fstp	 DWORD PTR _fch3$[esp+1816]
  001b5	d9 cd		 fxch	 ST(5)
  001b7	d9 5c 24 14	 fstp	 DWORD PTR _fch4$[esp+1816]
  001bb	6a 14		 push	 20			; 00000014H
  001bd	d8 0d 00 00 00
	00		 fmul	 DWORD PTR $T50059
  001c3	d9 cd		 fxch	 ST(5)
  001c5	d9 5c 24 20	 fstp	 DWORD PTR _fch5$[esp+1820]
  001c9	d9 ca		 fxch	 ST(2)
  001cb	d9 5c 24 28	 fstp	 DWORD PTR _fch6$[esp+1820]
  001cf	d9 5c 24 38	 fstp	 DWORD PTR _fch7$[esp+1820]
  001d3	d9 5c 24 58	 fstp	 DWORD PTR _fch8$[esp+1820]
  001d7	d9 5c 24 50	 fstp	 DWORD PTR _fch9$[esp+1820]
  001db	d9 5c 24 48	 fstp	 DWORD PTR _fch10$[esp+1820]
  001df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 1180 : 	
; 1181 : 
; 1182 :     // red status when no/defective signal
; 1183 : 	if (!newint) {

  001e5	8a 44 24 13	 mov	 al, BYTE PTR _newint$[esp+1816]
  001e9	84 c0		 test	 al, al
  001eb	75 3c		 jne	 SHORT $L49264

; 1184 : 		//SetTextColor( GetDC(GetDlgItem(g_hTabCurrent,IDC_STATICSTATUS)), RGB(255,0,0) );
; 1185 : 		g_crColor = COLOR_RED;
; 1186 : 		sprintf( status, "No Signal                  ");

  001ed	8d 8c 24 18 01
	00 00		 lea	 ecx, DWORD PTR _status$[esp+1816]
  001f4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@LCGE@No?5Signal?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$AA@ ; `string'
  001f9	51		 push	 ecx
  001fa	c7 05 00 00 00
	00 ff 00 00 00	 mov	 DWORD PTR ?g_crColor@@3KA, 255 ; g_crColor, 000000ffH
  00204	e8 00 00 00 00	 call	 _sprintf
  00209	83 c4 08	 add	 esp, 8

; 1187 : 		sprintf( status2, "No Signal");

  0020c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09JHMD@No?5Signal?$AA@ ; `string'
  00211	68 00 00 00 00	 push	 OFFSET FLAT:?status2@@3PADA ; status2
  00216	e8 00 00 00 00	 call	 _sprintf
  0021b	83 c4 08	 add	 esp, 8

; 1188 : 		//bSignalConnected = false;
; 1189 : 		iSignalStatus = 0;

  0021e	89 3d 00 00 00
	00		 mov	 DWORD PTR ?iSignalStatus@@3HA, edi ; iSignalStatus

; 1190 : 	} else {

  00224	e9 80 00 00 00	 jmp	 $L49283
$L49264:

; 1191 : 		if (ChannelTotal == 0) {

  00229	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?ChannelTotal@@3HA, edi ; ChannelTotal
  0022f	75 3d		 jne	 SHORT $L49274

; 1192 : 			//SetTextColor( GetDC(GetDlgItem(g_hTabCurrent,IDC_STATICSTATUS)), COLOUR_RED);
; 1193 : 			g_crColor = COLOR_RED;
; 1194 : 			sprintf( status, "Signal Defective       ");

  00231	8d 94 24 18 01
	00 00		 lea	 edx, DWORD PTR _status$[esp+1816]
  00238	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@PAHP@Signal?5Defective?5?5?5?5?5?5?5?$AA@ ; `string'
  0023d	52		 push	 edx
  0023e	c7 05 00 00 00
	00 ff 00 00 00	 mov	 DWORD PTR ?g_crColor@@3KA, 255 ; g_crColor, 000000ffH
  00248	e8 00 00 00 00	 call	 _sprintf
  0024d	83 c4 08	 add	 esp, 8

; 1195 : 			sprintf( status2, "Signal Defective");

  00250	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@CPII@Signal?5Defective?$AA@ ; `string'
  00255	68 00 00 00 00	 push	 OFFSET FLAT:?status2@@3PADA ; status2
  0025a	e8 00 00 00 00	 call	 _sprintf
  0025f	83 c4 08	 add	 esp, 8

; 1196 : 			//bSignalConnected = false;
; 1197 : 			iSignalStatus = 1;

  00262	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?iSignalStatus@@3HA, 1 ; iSignalStatus

; 1198 : 		} else {

  0026c	eb 3b		 jmp	 SHORT $L49283
$L49274:

; 1199 : 			//SetTextColor( GetDC(GetDlgItem(g_hTabCurrent,IDC_STATICSTATUS)), COLOUR_BLACK);
; 1200 : 			g_crColor = COLOR_CONNECTED;//COLOR_BLUE;

  0026e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?COLOR_CONNECTED@@3KA ; COLOR_CONNECTED

; 1201 : 			sprintf( status, "Signal Connected       ");

  00273	8d 8c 24 18 01
	00 00		 lea	 ecx, DWORD PTR _status$[esp+1816]
  0027a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@LGIH@Signal?5Connected?5?5?5?5?5?5?5?$AA@ ; `string'
  0027f	51		 push	 ecx
  00280	a3 00 00 00 00	 mov	 DWORD PTR ?g_crColor@@3KA, eax ; g_crColor
  00285	e8 00 00 00 00	 call	 _sprintf
  0028a	83 c4 08	 add	 esp, 8

; 1202 : 			//sprintf( status2, "Signal Connected - Interrupt Count: %i", IntCount); // helaas, tray icon tooltips zijn maximaal [64]
; 1203 : 			sprintf( status2, "Signal Connected");

  0028d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@OJAH@Signal?5Connected?$AA@ ; `string'
  00292	68 00 00 00 00	 push	 OFFSET FLAT:?status2@@3PADA ; status2
  00297	e8 00 00 00 00	 call	 _sprintf
  0029c	83 c4 08	 add	 esp, 8

; 1204 : 			//bSignalConnected = true;
; 1205 : 			iSignalStatus = 2;

  0029f	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?iSignalStatus@@3HA, 2 ; iSignalStatus
$L49283:

; 1206 : 		}
; 1207 : 	}
; 1208 : 	
; 1209 : 	
; 1210 : 
; 1211 : /*
; 1212 : 	if ( GetKeyState('A') & 0x80 ) {
; 1213 : 		g_bColor = !g_bColor;
; 1214 : 		InvalidateRect( GetDlgItem(g_hTabCurrent,IDC_STATICSTATUS), NULL, TRUE );
; 1215 : 	}
; 1216 : */
; 1217 : 
; 1218 : 
; 1219 : 
; 1220 : 	//SendMessage( GetDlgItem(g_hTabCurrent,IDC_STATICSTATUS),
; 1221 : 	//	WM_CTLCOLORSTATIC, (unsigned int)GetDC(GetDlgItem(g_hTabCurrent,IDC_STATICSTATUS)),
; 1222 : 	//	GetDlgItem(g_hTabCurrent,IDC_STATICSTATUS) );
; 1223 : 
; 1224 : 
; 1225 : 
; 1226 : 
; 1227 : 
; 1228 : 
; 1229 : 	// format
; 1230 : 	sprintf( sync,  "%.3f ms          ", fsync );

  002a9	d9 44 24 64	 fld	 DWORD PTR _fsync$[esp+1816]
  002ad	8d 94 24 18 04
	00 00		 lea	 edx, DWORD PTR _sync$[esp+1816]
  002b4	dd 5c 24 64	 fstp	 QWORD PTR -1716+[esp+1816]
  002b8	8b 7c 24 68	 mov	 edi, DWORD PTR -1716+[esp+1820]
  002bc	8b 6c 24 64	 mov	 ebp, DWORD PTR -1716+[esp+1816]
  002c0	57		 push	 edi
  002c1	55		 push	 ebp
  002c2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@DHLA@?$CF?43f?5ms?5?5?5?5?5?5?5?5?5?5?$AA@ ; `string'
  002c7	52		 push	 edx
  002c8	e8 00 00 00 00	 call	 _sprintf

; 1231 : 	sprintf( ch1,  "%.3f ms      ", fch1 );

  002cd	d9 44 24 6c	 fld	 DWORD PTR _fch1$[esp+1832]
  002d1	83 c4 10	 add	 esp, 16			; 00000010H
  002d4	8d 8c 24 18 02
	00 00		 lea	 ecx, DWORD PTR _ch1$[esp+1816]
  002db	dd 5c 24 5c	 fstp	 QWORD PTR -1724+[esp+1816]
  002df	8b 5c 24 60	 mov	 ebx, DWORD PTR -1724+[esp+1820]
  002e3	8b 44 24 5c	 mov	 eax, DWORD PTR -1724+[esp+1816]
  002e7	53		 push	 ebx
  002e8	50		 push	 eax
  002e9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@DFPO@?$CF?43f?5ms?5?5?5?5?5?5?$AA@ ; `string'
  002ee	51		 push	 ecx
  002ef	e8 00 00 00 00	 call	 _sprintf

; 1232 : 	sprintf( ch2,  "%.3f ms      ", fch2 );

  002f4	d9 44 24 3c	 fld	 DWORD PTR _fch2$[esp+1832]
  002f8	83 c4 10	 add	 esp, 16			; 00000010H
  002fb	8d 8c 24 18 06
	00 00		 lea	 ecx, DWORD PTR _ch2$[esp+1816]
  00302	dd 5c 24 2c	 fstp	 QWORD PTR -1772+[esp+1816]
  00306	8b 54 24 30	 mov	 edx, DWORD PTR -1772+[esp+1820]
  0030a	8b 44 24 2c	 mov	 eax, DWORD PTR -1772+[esp+1816]
  0030e	52		 push	 edx
  0030f	50		 push	 eax
  00310	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@DFPO@?$CF?43f?5ms?5?5?5?5?5?5?$AA@ ; `string'
  00315	51		 push	 ecx
  00316	e8 00 00 00 00	 call	 _sprintf

; 1233 : 	sprintf( ch3,  "%.3f ms      ", fch3 );

  0031b	d9 44 24 4c	 fld	 DWORD PTR _fch3$[esp+1832]
  0031f	83 c4 10	 add	 esp, 16			; 00000010H
  00322	8d 8c 24 18 03
	00 00		 lea	 ecx, DWORD PTR _ch3$[esp+1816]
  00329	dd 5c 24 3c	 fstp	 QWORD PTR -1756+[esp+1816]
  0032d	8b 54 24 40	 mov	 edx, DWORD PTR -1756+[esp+1820]
  00331	8b 44 24 3c	 mov	 eax, DWORD PTR -1756+[esp+1816]
  00335	52		 push	 edx
  00336	50		 push	 eax
  00337	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@DFPO@?$CF?43f?5ms?5?5?5?5?5?5?$AA@ ; `string'
  0033c	51		 push	 ecx
  0033d	e8 00 00 00 00	 call	 _sprintf

; 1234 : 	sprintf( ch4,  "%.3f ms      ", fch4 );

  00342	d9 44 24 24	 fld	 DWORD PTR _fch4$[esp+1832]
  00346	83 c4 10	 add	 esp, 16			; 00000010H
  00349	8d 8c 24 18 05
	00 00		 lea	 ecx, DWORD PTR _ch4$[esp+1816]
  00350	dd 5c 24 14	 fstp	 QWORD PTR -1796+[esp+1816]
  00354	8b 54 24 18	 mov	 edx, DWORD PTR -1796+[esp+1820]
  00358	8b 44 24 14	 mov	 eax, DWORD PTR -1796+[esp+1816]
  0035c	52		 push	 edx
  0035d	50		 push	 eax
  0035e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@DFPO@?$CF?43f?5ms?5?5?5?5?5?5?$AA@ ; `string'
  00363	51		 push	 ecx
  00364	e8 00 00 00 00	 call	 _sprintf

; 1235 : 	sprintf( ch5,  "%.3f ms      ", fch5 );

  00369	d9 44 24 2c	 fld	 DWORD PTR _fch5$[esp+1832]
  0036d	83 c4 10	 add	 esp, 16			; 00000010H
  00370	8d 8c 24 98 00
	00 00		 lea	 ecx, DWORD PTR _ch5$[esp+1816]
  00377	dd 5c 24 1c	 fstp	 QWORD PTR -1788+[esp+1816]
  0037b	8b 54 24 20	 mov	 edx, DWORD PTR -1788+[esp+1820]
  0037f	8b 44 24 1c	 mov	 eax, DWORD PTR -1788+[esp+1816]
  00383	52		 push	 edx
  00384	50		 push	 eax
  00385	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@DFPO@?$CF?43f?5ms?5?5?5?5?5?5?$AA@ ; `string'
  0038a	51		 push	 ecx
  0038b	e8 00 00 00 00	 call	 _sprintf

; 1236 : 	sprintf( ch6,  "%.3f ms      ", fch6 );

  00390	d9 44 24 34	 fld	 DWORD PTR _fch6$[esp+1832]
  00394	83 c4 10	 add	 esp, 16			; 00000010H
  00397	8d 8c 24 98 01
	00 00		 lea	 ecx, DWORD PTR _ch6$[esp+1816]
  0039e	dd 5c 24 24	 fstp	 QWORD PTR -1780+[esp+1816]
  003a2	8b 54 24 28	 mov	 edx, DWORD PTR -1780+[esp+1820]
  003a6	8b 44 24 24	 mov	 eax, DWORD PTR -1780+[esp+1816]
  003aa	52		 push	 edx
  003ab	50		 push	 eax
  003ac	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@DFPO@?$CF?43f?5ms?5?5?5?5?5?5?$AA@ ; `string'
  003b1	51		 push	 ecx
  003b2	e8 00 00 00 00	 call	 _sprintf

; 1237 : 	sprintf( ch7,  "%.3f ms      ", fch7 );

  003b7	d9 44 24 44	 fld	 DWORD PTR _fch7$[esp+1832]
  003bb	83 c4 10	 add	 esp, 16			; 00000010H
  003be	dd 5c 24 34	 fstp	 QWORD PTR -1764+[esp+1816]
  003c2	8b 54 24 38	 mov	 edx, DWORD PTR -1764+[esp+1820]
  003c6	52		 push	 edx
  003c7	8b 44 24 38	 mov	 eax, DWORD PTR -1764+[esp+1820]
  003cb	8d 8c 24 9c 02
	00 00		 lea	 ecx, DWORD PTR _ch7$[esp+1820]
  003d2	50		 push	 eax
  003d3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@DFPO@?$CF?43f?5ms?5?5?5?5?5?5?$AA@ ; `string'
  003d8	51		 push	 ecx
  003d9	e8 00 00 00 00	 call	 _sprintf

; 1238 : 	sprintf( ch8,  "%.3f ms      ", fch8 );

  003de	d9 44 24 64	 fld	 DWORD PTR _fch8$[esp+1832]
  003e2	83 c4 10	 add	 esp, 16			; 00000010H
  003e5	8d 8c 24 98 03
	00 00		 lea	 ecx, DWORD PTR _ch8$[esp+1816]
  003ec	dd 5c 24 54	 fstp	 QWORD PTR -1732+[esp+1816]
  003f0	8b 54 24 58	 mov	 edx, DWORD PTR -1732+[esp+1820]
  003f4	8b 44 24 54	 mov	 eax, DWORD PTR -1732+[esp+1816]
  003f8	52		 push	 edx
  003f9	50		 push	 eax
  003fa	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@DFPO@?$CF?43f?5ms?5?5?5?5?5?5?$AA@ ; `string'
  003ff	51		 push	 ecx
  00400	e8 00 00 00 00	 call	 _sprintf

; 1239 : 	sprintf( ch9,  "%.3f ms      ", fch9 );

  00405	d9 44 24 5c	 fld	 DWORD PTR _fch9$[esp+1832]
  00409	83 c4 10	 add	 esp, 16			; 00000010H
  0040c	8d 8c 24 98 04
	00 00		 lea	 ecx, DWORD PTR _ch9$[esp+1816]
  00413	dd 5c 24 4c	 fstp	 QWORD PTR -1740+[esp+1816]
  00417	8b 54 24 50	 mov	 edx, DWORD PTR -1740+[esp+1820]
  0041b	8b 44 24 4c	 mov	 eax, DWORD PTR -1740+[esp+1816]
  0041f	52		 push	 edx
  00420	50		 push	 eax
  00421	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@DFPO@?$CF?43f?5ms?5?5?5?5?5?5?$AA@ ; `string'
  00426	51		 push	 ecx
  00427	e8 00 00 00 00	 call	 _sprintf

; 1240 : 	sprintf( ch10, "%.3f ms      ", fch10);

  0042c	d9 44 24 54	 fld	 DWORD PTR _fch10$[esp+1832]
  00430	83 c4 10	 add	 esp, 16			; 00000010H
  00433	8d 8c 24 98 05
	00 00		 lea	 ecx, DWORD PTR _ch10$[esp+1816]
  0043a	dd 5c 24 44	 fstp	 QWORD PTR -1748+[esp+1816]
  0043e	8b 54 24 48	 mov	 edx, DWORD PTR -1748+[esp+1820]
  00442	8b 44 24 44	 mov	 eax, DWORD PTR -1748+[esp+1816]
  00446	52		 push	 edx
  00447	50		 push	 eax
  00448	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@DFPO@?$CF?43f?5ms?5?5?5?5?5?5?$AA@ ; `string'
  0044d	51		 push	 ecx
  0044e	e8 00 00 00 00	 call	 _sprintf

; 1241 : 
; 1242 : 	
; 1243 : 	
; 1244 : 	// set the text
; 1245 : 	SetDlgItemText(g_hTabCurrent ,IDC_STATIC1,  ch1 );

  00453	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  00458	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetDlgItemTextA@12
  0045e	83 c4 10	 add	 esp, 16			; 00000010H
  00461	8d 94 24 18 02
	00 00		 lea	 edx, DWORD PTR _ch1$[esp+1816]
  00468	52		 push	 edx
  00469	68 5d 04 00 00	 push	 1117			; 0000045dH
  0046e	50		 push	 eax
  0046f	ff d6		 call	 esi

; 1246 : 	SetDlgItemText(g_hTabCurrent ,IDC_STATIC2,  ch2 );

  00471	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  00477	8d 8c 24 18 06
	00 00		 lea	 ecx, DWORD PTR _ch2$[esp+1816]
  0047e	51		 push	 ecx
  0047f	68 5e 04 00 00	 push	 1118			; 0000045eH
  00484	52		 push	 edx
  00485	ff d6		 call	 esi

; 1247 : 	SetDlgItemText(g_hTabCurrent ,IDC_STATIC3,  ch3 );

  00487	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  0048d	8d 84 24 18 03
	00 00		 lea	 eax, DWORD PTR _ch3$[esp+1816]
  00494	50		 push	 eax
  00495	68 5f 04 00 00	 push	 1119			; 0000045fH
  0049a	51		 push	 ecx
  0049b	ff d6		 call	 esi

; 1248 : 	SetDlgItemText(g_hTabCurrent ,IDC_STATIC4,  ch4 );

  0049d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  004a2	8d 94 24 18 05
	00 00		 lea	 edx, DWORD PTR _ch4$[esp+1816]
  004a9	52		 push	 edx
  004aa	68 60 04 00 00	 push	 1120			; 00000460H
  004af	50		 push	 eax
  004b0	ff d6		 call	 esi

; 1249 : 	SetDlgItemText(g_hTabCurrent ,IDC_STATIC5,  ch5 );

  004b2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  004b8	8d 8c 24 98 00
	00 00		 lea	 ecx, DWORD PTR _ch5$[esp+1816]
  004bf	51		 push	 ecx
  004c0	68 61 04 00 00	 push	 1121			; 00000461H
  004c5	52		 push	 edx
  004c6	ff d6		 call	 esi

; 1250 : 	SetDlgItemText(g_hTabCurrent ,IDC_STATIC6,  ch6 );

  004c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  004ce	8d 84 24 98 01
	00 00		 lea	 eax, DWORD PTR _ch6$[esp+1816]
  004d5	50		 push	 eax
  004d6	68 62 04 00 00	 push	 1122			; 00000462H
  004db	51		 push	 ecx
  004dc	ff d6		 call	 esi

; 1251 : 	SetDlgItemText(g_hTabCurrent ,IDC_STATIC7,  ch7 );

  004de	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  004e3	8d 94 24 98 02
	00 00		 lea	 edx, DWORD PTR _ch7$[esp+1816]
  004ea	52		 push	 edx
  004eb	68 63 04 00 00	 push	 1123			; 00000463H
  004f0	50		 push	 eax
  004f1	ff d6		 call	 esi

; 1252 : 	SetDlgItemText(g_hTabCurrent ,IDC_STATIC8,  ch8 );

  004f3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  004f9	8d 8c 24 98 03
	00 00		 lea	 ecx, DWORD PTR _ch8$[esp+1816]
  00500	51		 push	 ecx
  00501	68 64 04 00 00	 push	 1124			; 00000464H
  00506	52		 push	 edx
  00507	ff d6		 call	 esi

; 1253 : 	SetDlgItemText(g_hTabCurrent ,IDC_STATIC9,  ch9 );

  00509	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  0050f	8d 84 24 98 04
	00 00		 lea	 eax, DWORD PTR _ch9$[esp+1816]
  00516	50		 push	 eax
  00517	68 65 04 00 00	 push	 1125			; 00000465H
  0051c	51		 push	 ecx
  0051d	ff d6		 call	 esi

; 1254 : 	SetDlgItemText(g_hTabCurrent ,IDC_STATIC10, ch10);

  0051f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  00524	8d 94 24 98 05
	00 00		 lea	 edx, DWORD PTR _ch10$[esp+1816]
  0052b	52		 push	 edx
  0052c	68 66 04 00 00	 push	 1126			; 00000466H
  00531	50		 push	 eax
  00532	ff d6		 call	 esi

; 1255 : 
; 1256 : 
; 1257 : 	SetDlgItemText(g_hTabCurrent ,IDC_STATICSTATUS, status );

  00534	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  0053a	8d 8c 24 18 01
	00 00		 lea	 ecx, DWORD PTR _status$[esp+1816]
  00541	51		 push	 ecx
  00542	68 6b 04 00 00	 push	 1131			; 0000046bH
  00547	52		 push	 edx
  00548	ff d6		 call	 esi

; 1258 : 	SetDlgItemText(g_hTabCurrent ,IDC_STATICSYNC, sync );

  0054a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  00550	8d 84 24 18 04
	00 00		 lea	 eax, DWORD PTR _sync$[esp+1816]
  00557	50		 push	 eax
  00558	68 68 04 00 00	 push	 1128			; 00000468H
  0055d	51		 push	 ecx
  0055e	ff d6		 call	 esi

; 1259 : 
; 1260 : 	// ints kun je meteen printen	
; 1261 : 	SetDlgItemInt(g_hTabCurrent ,IDC_STATICINTCOUNT, IntCount, TRUE);	

  00560	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?IntCount@@3HA ; IntCount
  00566	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  0056b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetDlgItemInt@16
  00571	6a 01		 push	 1
  00573	52		 push	 edx
  00574	68 69 04 00 00	 push	 1129			; 00000469H
  00579	50		 push	 eax
  0057a	ff d6		 call	 esi

; 1262 : 	SetDlgItemInt(g_hTabCurrent ,IDC_STATICCHANCOUNT, ChannelTotal, TRUE);

  0057c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ChannelTotal@@3HA ; ChannelTotal
  00582	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  00588	6a 01		 push	 1
  0058a	51		 push	 ecx
  0058b	68 6a 04 00 00	 push	 1130			; 0000046aH
  00590	52		 push	 edx
  00591	ff d6		 call	 esi

; 1263 : 
; 1264 : 	
; 1265 : 	// check if we should draw horizontal of vertical bars
; 1266 : 	if (g_bHorizontal) {

  00593	a0 00 00 00 00	 mov	 al, BYTE PTR ?g_bHorizontal@@3_NA ; g_bHorizontal

; 1267 : 		// draw horizontal bars (1000-2000 uS becomes 0-100 percent)
; 1268 : 		DrawBarEx( GetDlgItem(g_hTabCurrent,IDC_PROGRESSHORZ1), int((RetInfo[1]-1000)/10), true, g_crColorBar[1], COLOR_WHITE );

  00598	68 ff ff ff 00	 push	 16777215		; 00ffffffH
  0059d	84 c0		 test	 al, al
  0059f	a1 04 00 00 00	 mov	 eax, DWORD PTR ?g_crColorBar@@3PAKA+4
  005a4	50		 push	 eax
  005a5	0f 84 82 02 00
	00		 je	 $L49288
  005ab	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?RetInfo@@3PAHA+4
  005b1	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  005b6	81 c1 18 fc ff
	ff		 add	 ecx, -1000		; fffffc18H
  005bc	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  005c2	f7 e9		 imul	 ecx
  005c4	c1 fa 02	 sar	 edx, 2
  005c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  005cd	8b c2		 mov	 eax, edx
  005cf	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  005d2	03 d0		 add	 edx, eax
  005d4	6a 01		 push	 1
  005d6	52		 push	 edx
  005d7	68 e9 03 00 00	 push	 1001			; 000003e9H
  005dc	51		 push	 ecx
  005dd	ff d6		 call	 esi
  005df	50		 push	 eax
  005e0	e8 00 00 00 00	 call	 ?DrawBarEx@@YAXPAUHWND__@@H_NKK@Z ; DrawBarEx

; 1269 : 		DrawBarEx( GetDlgItem(g_hTabCurrent,IDC_PROGRESSHORZ2), int((RetInfo[2]-1000)/10), true, g_crColorBar[2], COLOR_WHITE );

  005e5	a1 08 00 00 00	 mov	 eax, DWORD PTR ?RetInfo@@3PAHA+8
  005ea	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ?g_crColorBar@@3PAKA+8
  005f0	83 c4 14	 add	 esp, 20			; 00000014H
  005f3	8d 88 18 fc ff
	ff		 lea	 ecx, DWORD PTR [eax-1000]
  005f9	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  005fe	68 ff ff ff 00	 push	 16777215		; 00ffffffH
  00603	52		 push	 edx
  00604	f7 e9		 imul	 ecx
  00606	c1 fa 02	 sar	 edx, 2
  00609	8b ca		 mov	 ecx, edx
  0060b	6a 01		 push	 1
  0060d	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00610	03 d1		 add	 edx, ecx
  00612	52		 push	 edx
  00613	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  00619	68 ea 03 00 00	 push	 1002			; 000003eaH
  0061e	52		 push	 edx
  0061f	ff d6		 call	 esi
  00621	50		 push	 eax
  00622	e8 00 00 00 00	 call	 ?DrawBarEx@@YAXPAUHWND__@@H_NKK@Z ; DrawBarEx

; 1270 : 		DrawBarEx( GetDlgItem(g_hTabCurrent,IDC_PROGRESSHORZ3), int((RetInfo[3]-1000)/10), true, g_crColorBar[3], COLOR_WHITE );

  00627	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?g_crColorBar@@3PAKA+12
  0062c	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ?RetInfo@@3PAHA+12
  00632	83 c4 14	 add	 esp, 20			; 00000014H
  00635	81 c1 18 fc ff
	ff		 add	 ecx, -1000		; fffffc18H
  0063b	68 ff ff ff 00	 push	 16777215		; 00ffffffH
  00640	50		 push	 eax
  00641	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00646	6a 01		 push	 1
  00648	f7 e9		 imul	 ecx
  0064a	c1 fa 02	 sar	 edx, 2
  0064d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  00653	8b c2		 mov	 eax, edx
  00655	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00658	03 d0		 add	 edx, eax
  0065a	52		 push	 edx
  0065b	68 eb 03 00 00	 push	 1003			; 000003ebH
  00660	51		 push	 ecx
  00661	ff d6		 call	 esi
  00663	50		 push	 eax
  00664	e8 00 00 00 00	 call	 ?DrawBarEx@@YAXPAUHWND__@@H_NKK@Z ; DrawBarEx

; 1271 : 		DrawBarEx( GetDlgItem(g_hTabCurrent,IDC_PROGRESSHORZ4), int((RetInfo[4]-1000)/10), true, g_crColorBar[4], COLOR_WHITE );

  00669	a1 10 00 00 00	 mov	 eax, DWORD PTR ?RetInfo@@3PAHA+16
  0066e	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR ?g_crColorBar@@3PAKA+16
  00674	83 c4 14	 add	 esp, 20			; 00000014H
  00677	8d 88 18 fc ff
	ff		 lea	 ecx, DWORD PTR [eax-1000]
  0067d	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00682	68 ff ff ff 00	 push	 16777215		; 00ffffffH
  00687	52		 push	 edx
  00688	f7 e9		 imul	 ecx
  0068a	c1 fa 02	 sar	 edx, 2
  0068d	8b ca		 mov	 ecx, edx
  0068f	6a 01		 push	 1
  00691	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00694	03 d1		 add	 edx, ecx
  00696	52		 push	 edx
  00697	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  0069d	68 ec 03 00 00	 push	 1004			; 000003ecH
  006a2	52		 push	 edx
  006a3	ff d6		 call	 esi
  006a5	50		 push	 eax
  006a6	e8 00 00 00 00	 call	 ?DrawBarEx@@YAXPAUHWND__@@H_NKK@Z ; DrawBarEx

; 1272 : 		DrawBarEx( GetDlgItem(g_hTabCurrent,IDC_PROGRESSHORZ5), int((RetInfo[5]-1000)/10), true, g_crColorBar[5], COLOR_WHITE );

  006ab	a1 14 00 00 00	 mov	 eax, DWORD PTR ?g_crColorBar@@3PAKA+20
  006b0	83 c4 14	 add	 esp, 20			; 00000014H
  006b3	68 ff ff ff 00	 push	 16777215		; 00ffffffH
  006b8	50		 push	 eax
  006b9	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?RetInfo@@3PAHA+20
  006bf	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  006c4	81 c1 18 fc ff
	ff		 add	 ecx, -1000		; fffffc18H
  006ca	6a 01		 push	 1
  006cc	f7 e9		 imul	 ecx
  006ce	c1 fa 02	 sar	 edx, 2
  006d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  006d7	8b c2		 mov	 eax, edx
  006d9	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  006dc	03 d0		 add	 edx, eax
  006de	52		 push	 edx
  006df	68 ed 03 00 00	 push	 1005			; 000003edH
  006e4	51		 push	 ecx
  006e5	ff d6		 call	 esi
  006e7	50		 push	 eax
  006e8	e8 00 00 00 00	 call	 ?DrawBarEx@@YAXPAUHWND__@@H_NKK@Z ; DrawBarEx

; 1273 : 		DrawBarEx( GetDlgItem(g_hTabCurrent,IDC_PROGRESSHORZ6), int((RetInfo[6]-1000)/10), true, g_crColorBar[6], COLOR_WHITE );

  006ed	a1 18 00 00 00	 mov	 eax, DWORD PTR ?RetInfo@@3PAHA+24
  006f2	8b 15 18 00 00
	00		 mov	 edx, DWORD PTR ?g_crColorBar@@3PAKA+24
  006f8	83 c4 14	 add	 esp, 20			; 00000014H
  006fb	8d 88 18 fc ff
	ff		 lea	 ecx, DWORD PTR [eax-1000]
  00701	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00706	68 ff ff ff 00	 push	 16777215		; 00ffffffH
  0070b	52		 push	 edx
  0070c	f7 e9		 imul	 ecx
  0070e	c1 fa 02	 sar	 edx, 2
  00711	8b ca		 mov	 ecx, edx
  00713	6a 01		 push	 1
  00715	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00718	03 d1		 add	 edx, ecx
  0071a	52		 push	 edx
  0071b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  00721	68 ee 03 00 00	 push	 1006			; 000003eeH
  00726	52		 push	 edx
  00727	ff d6		 call	 esi
  00729	50		 push	 eax
  0072a	e8 00 00 00 00	 call	 ?DrawBarEx@@YAXPAUHWND__@@H_NKK@Z ; DrawBarEx

; 1274 : 		DrawBarEx( GetDlgItem(g_hTabCurrent,IDC_PROGRESSHORZ7), int((RetInfo[7]-1000)/10), true, g_crColorBar[7], COLOR_WHITE );

  0072f	a1 1c 00 00 00	 mov	 eax, DWORD PTR ?g_crColorBar@@3PAKA+28
  00734	8b 0d 1c 00 00
	00		 mov	 ecx, DWORD PTR ?RetInfo@@3PAHA+28
  0073a	83 c4 14	 add	 esp, 20			; 00000014H
  0073d	81 c1 18 fc ff
	ff		 add	 ecx, -1000		; fffffc18H
  00743	68 ff ff ff 00	 push	 16777215		; 00ffffffH
  00748	50		 push	 eax
  00749	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0074e	6a 01		 push	 1
  00750	f7 e9		 imul	 ecx
  00752	c1 fa 02	 sar	 edx, 2
  00755	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  0075b	8b c2		 mov	 eax, edx
  0075d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00760	03 d0		 add	 edx, eax
  00762	52		 push	 edx
  00763	68 ef 03 00 00	 push	 1007			; 000003efH
  00768	51		 push	 ecx
  00769	ff d6		 call	 esi
  0076b	50		 push	 eax
  0076c	e8 00 00 00 00	 call	 ?DrawBarEx@@YAXPAUHWND__@@H_NKK@Z ; DrawBarEx

; 1275 : 		DrawBarEx( GetDlgItem(g_hTabCurrent,IDC_PROGRESSHORZ8), int((RetInfo[8]-1000)/10), true, g_crColorBar[8], COLOR_WHITE );

  00771	a1 20 00 00 00	 mov	 eax, DWORD PTR ?RetInfo@@3PAHA+32
  00776	8b 15 20 00 00
	00		 mov	 edx, DWORD PTR ?g_crColorBar@@3PAKA+32
  0077c	83 c4 14	 add	 esp, 20			; 00000014H
  0077f	8d 88 18 fc ff
	ff		 lea	 ecx, DWORD PTR [eax-1000]
  00785	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0078a	68 ff ff ff 00	 push	 16777215		; 00ffffffH
  0078f	52		 push	 edx
  00790	f7 e9		 imul	 ecx
  00792	c1 fa 02	 sar	 edx, 2
  00795	8b ca		 mov	 ecx, edx
  00797	6a 01		 push	 1
  00799	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0079c	03 d1		 add	 edx, ecx
  0079e	52		 push	 edx
  0079f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  007a5	68 f0 03 00 00	 push	 1008			; 000003f0H
  007aa	52		 push	 edx
  007ab	ff d6		 call	 esi
  007ad	50		 push	 eax
  007ae	e8 00 00 00 00	 call	 ?DrawBarEx@@YAXPAUHWND__@@H_NKK@Z ; DrawBarEx

; 1276 : 		DrawBarEx( GetDlgItem(g_hTabCurrent,IDC_PROGRESSHORZ9), int((RetInfo[9]-1000)/10), true, g_crColorBar[9], COLOR_WHITE );

  007b3	a1 24 00 00 00	 mov	 eax, DWORD PTR ?g_crColorBar@@3PAKA+36
  007b8	83 c4 14	 add	 esp, 20			; 00000014H
  007bb	68 ff ff ff 00	 push	 16777215		; 00ffffffH
  007c0	50		 push	 eax
  007c1	6a 01		 push	 1
  007c3	8b 0d 24 00 00
	00		 mov	 ecx, DWORD PTR ?RetInfo@@3PAHA+36
  007c9	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  007ce	81 c1 18 fc ff
	ff		 add	 ecx, -1000		; fffffc18H
  007d4	f7 e9		 imul	 ecx
  007d6	c1 fa 02	 sar	 edx, 2
  007d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  007df	8b c2		 mov	 eax, edx
  007e1	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  007e4	03 d0		 add	 edx, eax
  007e6	52		 push	 edx
  007e7	68 f1 03 00 00	 push	 1009			; 000003f1H
  007ec	51		 push	 ecx
  007ed	ff d6		 call	 esi
  007ef	50		 push	 eax
  007f0	e8 00 00 00 00	 call	 ?DrawBarEx@@YAXPAUHWND__@@H_NKK@Z ; DrawBarEx

; 1277 : 		DrawBarEx( GetDlgItem(g_hTabCurrent,IDC_PROGRESSHORZ10), int((RetInfo[10]-1000)/10), true, g_crColorBar[10], COLOR_WHITE );

  007f5	a1 28 00 00 00	 mov	 eax, DWORD PTR ?RetInfo@@3PAHA+40
  007fa	8b 15 28 00 00
	00		 mov	 edx, DWORD PTR ?g_crColorBar@@3PAKA+40
  00800	83 c4 14	 add	 esp, 20			; 00000014H
  00803	8d 88 18 fc ff
	ff		 lea	 ecx, DWORD PTR [eax-1000]
  00809	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0080e	68 ff ff ff 00	 push	 16777215		; 00ffffffH
  00813	52		 push	 edx
  00814	f7 e9		 imul	 ecx
  00816	c1 fa 02	 sar	 edx, 2
  00819	8b ca		 mov	 ecx, edx
  0081b	6a 01		 push	 1
  0081d	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00820	03 d1		 add	 edx, ecx
  00822	52		 push	 edx
  00823	68 f2 03 00 00	 push	 1010			; 000003f2H

; 1278 : 	} else {

  00828	e9 7d 02 00 00	 jmp	 $L50062
$L49288:

; 1279 : 		// draw vertical bars
; 1280 : 		DrawBarEx( GetDlgItem(g_hTabCurrent,IDC_PROGRESSVERT1), int((RetInfo[1]-1000)/10), false, g_crColorBar[1], COLOR_WHITE );

  0082d	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?RetInfo@@3PAHA+4
  00833	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00838	81 c1 18 fc ff
	ff		 add	 ecx, -1000		; fffffc18H
  0083e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  00844	f7 e9		 imul	 ecx
  00846	c1 fa 02	 sar	 edx, 2
  00849	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  0084f	8b c2		 mov	 eax, edx
  00851	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00854	03 d0		 add	 edx, eax
  00856	6a 00		 push	 0
  00858	52		 push	 edx
  00859	68 7f 04 00 00	 push	 1151			; 0000047fH
  0085e	51		 push	 ecx
  0085f	ff d6		 call	 esi
  00861	50		 push	 eax
  00862	e8 00 00 00 00	 call	 ?DrawBarEx@@YAXPAUHWND__@@H_NKK@Z ; DrawBarEx

; 1281 : 		DrawBarEx( GetDlgItem(g_hTabCurrent,IDC_PROGRESSVERT2), int((RetInfo[2]-1000)/10), false, g_crColorBar[2], COLOR_WHITE );

  00867	a1 08 00 00 00	 mov	 eax, DWORD PTR ?RetInfo@@3PAHA+8
  0086c	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ?g_crColorBar@@3PAKA+8
  00872	83 c4 14	 add	 esp, 20			; 00000014H
  00875	8d 88 18 fc ff
	ff		 lea	 ecx, DWORD PTR [eax-1000]
  0087b	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00880	68 ff ff ff 00	 push	 16777215		; 00ffffffH
  00885	52		 push	 edx
  00886	f7 e9		 imul	 ecx
  00888	c1 fa 02	 sar	 edx, 2
  0088b	8b ca		 mov	 ecx, edx
  0088d	6a 00		 push	 0
  0088f	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00892	03 d1		 add	 edx, ecx
  00894	52		 push	 edx
  00895	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  0089b	68 80 04 00 00	 push	 1152			; 00000480H
  008a0	52		 push	 edx
  008a1	ff d6		 call	 esi
  008a3	50		 push	 eax
  008a4	e8 00 00 00 00	 call	 ?DrawBarEx@@YAXPAUHWND__@@H_NKK@Z ; DrawBarEx

; 1282 : 		DrawBarEx( GetDlgItem(g_hTabCurrent,IDC_PROGRESSVERT3), int((RetInfo[3]-1000)/10), false, g_crColorBar[3], COLOR_WHITE );

  008a9	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?g_crColorBar@@3PAKA+12
  008ae	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ?RetInfo@@3PAHA+12
  008b4	83 c4 14	 add	 esp, 20			; 00000014H
  008b7	81 c1 18 fc ff
	ff		 add	 ecx, -1000		; fffffc18H
  008bd	68 ff ff ff 00	 push	 16777215		; 00ffffffH
  008c2	50		 push	 eax
  008c3	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  008c8	6a 00		 push	 0
  008ca	f7 e9		 imul	 ecx
  008cc	c1 fa 02	 sar	 edx, 2
  008cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  008d5	8b c2		 mov	 eax, edx
  008d7	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  008da	03 d0		 add	 edx, eax
  008dc	52		 push	 edx
  008dd	68 81 04 00 00	 push	 1153			; 00000481H
  008e2	51		 push	 ecx
  008e3	ff d6		 call	 esi
  008e5	50		 push	 eax
  008e6	e8 00 00 00 00	 call	 ?DrawBarEx@@YAXPAUHWND__@@H_NKK@Z ; DrawBarEx

; 1283 : 		DrawBarEx( GetDlgItem(g_hTabCurrent,IDC_PROGRESSVERT4), int((RetInfo[4]-1000)/10), false, g_crColorBar[4], COLOR_WHITE );

  008eb	a1 10 00 00 00	 mov	 eax, DWORD PTR ?RetInfo@@3PAHA+16
  008f0	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR ?g_crColorBar@@3PAKA+16
  008f6	83 c4 14	 add	 esp, 20			; 00000014H
  008f9	8d 88 18 fc ff
	ff		 lea	 ecx, DWORD PTR [eax-1000]
  008ff	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00904	68 ff ff ff 00	 push	 16777215		; 00ffffffH
  00909	52		 push	 edx
  0090a	f7 e9		 imul	 ecx
  0090c	c1 fa 02	 sar	 edx, 2
  0090f	8b ca		 mov	 ecx, edx
  00911	6a 00		 push	 0
  00913	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00916	03 d1		 add	 edx, ecx
  00918	52		 push	 edx
  00919	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  0091f	68 82 04 00 00	 push	 1154			; 00000482H
  00924	52		 push	 edx
  00925	ff d6		 call	 esi
  00927	50		 push	 eax
  00928	e8 00 00 00 00	 call	 ?DrawBarEx@@YAXPAUHWND__@@H_NKK@Z ; DrawBarEx

; 1284 : 		DrawBarEx( GetDlgItem(g_hTabCurrent,IDC_PROGRESSVERT5), int((RetInfo[5]-1000)/10), false, g_crColorBar[5], COLOR_WHITE );

  0092d	a1 14 00 00 00	 mov	 eax, DWORD PTR ?g_crColorBar@@3PAKA+20
  00932	83 c4 14	 add	 esp, 20			; 00000014H
  00935	68 ff ff ff 00	 push	 16777215		; 00ffffffH
  0093a	50		 push	 eax
  0093b	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?RetInfo@@3PAHA+20
  00941	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00946	81 c1 18 fc ff
	ff		 add	 ecx, -1000		; fffffc18H
  0094c	6a 00		 push	 0
  0094e	f7 e9		 imul	 ecx
  00950	c1 fa 02	 sar	 edx, 2
  00953	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  00959	8b c2		 mov	 eax, edx
  0095b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0095e	03 d0		 add	 edx, eax
  00960	52		 push	 edx
  00961	68 83 04 00 00	 push	 1155			; 00000483H
  00966	51		 push	 ecx
  00967	ff d6		 call	 esi
  00969	50		 push	 eax
  0096a	e8 00 00 00 00	 call	 ?DrawBarEx@@YAXPAUHWND__@@H_NKK@Z ; DrawBarEx

; 1285 : 		DrawBarEx( GetDlgItem(g_hTabCurrent,IDC_PROGRESSVERT6), int((RetInfo[6]-1000)/10), false, g_crColorBar[6], COLOR_WHITE );

  0096f	a1 18 00 00 00	 mov	 eax, DWORD PTR ?RetInfo@@3PAHA+24
  00974	8b 15 18 00 00
	00		 mov	 edx, DWORD PTR ?g_crColorBar@@3PAKA+24
  0097a	83 c4 14	 add	 esp, 20			; 00000014H
  0097d	8d 88 18 fc ff
	ff		 lea	 ecx, DWORD PTR [eax-1000]
  00983	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00988	68 ff ff ff 00	 push	 16777215		; 00ffffffH
  0098d	52		 push	 edx
  0098e	f7 e9		 imul	 ecx
  00990	c1 fa 02	 sar	 edx, 2
  00993	8b ca		 mov	 ecx, edx
  00995	6a 00		 push	 0
  00997	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0099a	03 d1		 add	 edx, ecx
  0099c	52		 push	 edx
  0099d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  009a3	68 84 04 00 00	 push	 1156			; 00000484H
  009a8	52		 push	 edx
  009a9	ff d6		 call	 esi
  009ab	50		 push	 eax
  009ac	e8 00 00 00 00	 call	 ?DrawBarEx@@YAXPAUHWND__@@H_NKK@Z ; DrawBarEx

; 1286 : 		DrawBarEx( GetDlgItem(g_hTabCurrent,IDC_PROGRESSVERT7), int((RetInfo[7]-1000)/10), false, g_crColorBar[7], COLOR_WHITE );

  009b1	a1 1c 00 00 00	 mov	 eax, DWORD PTR ?g_crColorBar@@3PAKA+28
  009b6	8b 0d 1c 00 00
	00		 mov	 ecx, DWORD PTR ?RetInfo@@3PAHA+28
  009bc	83 c4 14	 add	 esp, 20			; 00000014H
  009bf	81 c1 18 fc ff
	ff		 add	 ecx, -1000		; fffffc18H
  009c5	68 ff ff ff 00	 push	 16777215		; 00ffffffH
  009ca	50		 push	 eax
  009cb	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  009d0	6a 00		 push	 0
  009d2	f7 e9		 imul	 ecx
  009d4	c1 fa 02	 sar	 edx, 2
  009d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  009dd	8b c2		 mov	 eax, edx
  009df	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  009e2	03 d0		 add	 edx, eax
  009e4	52		 push	 edx
  009e5	68 85 04 00 00	 push	 1157			; 00000485H
  009ea	51		 push	 ecx
  009eb	ff d6		 call	 esi
  009ed	50		 push	 eax
  009ee	e8 00 00 00 00	 call	 ?DrawBarEx@@YAXPAUHWND__@@H_NKK@Z ; DrawBarEx

; 1287 : 		DrawBarEx( GetDlgItem(g_hTabCurrent,IDC_PROGRESSVERT8), int((RetInfo[8]-1000)/10), false, g_crColorBar[8], COLOR_WHITE );

  009f3	a1 20 00 00 00	 mov	 eax, DWORD PTR ?RetInfo@@3PAHA+32
  009f8	8b 15 20 00 00
	00		 mov	 edx, DWORD PTR ?g_crColorBar@@3PAKA+32
  009fe	83 c4 14	 add	 esp, 20			; 00000014H
  00a01	8d 88 18 fc ff
	ff		 lea	 ecx, DWORD PTR [eax-1000]
  00a07	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00a0c	68 ff ff ff 00	 push	 16777215		; 00ffffffH
  00a11	52		 push	 edx
  00a12	f7 e9		 imul	 ecx
  00a14	c1 fa 02	 sar	 edx, 2
  00a17	8b ca		 mov	 ecx, edx
  00a19	6a 00		 push	 0
  00a1b	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00a1e	03 d1		 add	 edx, ecx
  00a20	52		 push	 edx
  00a21	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  00a27	68 86 04 00 00	 push	 1158			; 00000486H
  00a2c	52		 push	 edx
  00a2d	ff d6		 call	 esi
  00a2f	50		 push	 eax
  00a30	e8 00 00 00 00	 call	 ?DrawBarEx@@YAXPAUHWND__@@H_NKK@Z ; DrawBarEx

; 1288 : 		DrawBarEx( GetDlgItem(g_hTabCurrent,IDC_PROGRESSVERT9), int((RetInfo[9]-1000)/10), false, g_crColorBar[9], COLOR_WHITE );

  00a35	a1 24 00 00 00	 mov	 eax, DWORD PTR ?g_crColorBar@@3PAKA+36
  00a3a	83 c4 14	 add	 esp, 20			; 00000014H
  00a3d	68 ff ff ff 00	 push	 16777215		; 00ffffffH
  00a42	50		 push	 eax
  00a43	6a 00		 push	 0
  00a45	8b 0d 24 00 00
	00		 mov	 ecx, DWORD PTR ?RetInfo@@3PAHA+36
  00a4b	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00a50	81 c1 18 fc ff
	ff		 add	 ecx, -1000		; fffffc18H
  00a56	f7 e9		 imul	 ecx
  00a58	c1 fa 02	 sar	 edx, 2
  00a5b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  00a61	8b c2		 mov	 eax, edx
  00a63	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00a66	03 d0		 add	 edx, eax
  00a68	52		 push	 edx
  00a69	68 87 04 00 00	 push	 1159			; 00000487H
  00a6e	51		 push	 ecx
  00a6f	ff d6		 call	 esi
  00a71	50		 push	 eax
  00a72	e8 00 00 00 00	 call	 ?DrawBarEx@@YAXPAUHWND__@@H_NKK@Z ; DrawBarEx

; 1289 : 		DrawBarEx( GetDlgItem(g_hTabCurrent,IDC_PROGRESSVERT10), int((RetInfo[10]-1000)/10), false, g_crColorBar[10], COLOR_WHITE );

  00a77	a1 28 00 00 00	 mov	 eax, DWORD PTR ?RetInfo@@3PAHA+40
  00a7c	8b 15 28 00 00
	00		 mov	 edx, DWORD PTR ?g_crColorBar@@3PAKA+40
  00a82	83 c4 14	 add	 esp, 20			; 00000014H
  00a85	8d 88 18 fc ff
	ff		 lea	 ecx, DWORD PTR [eax-1000]
  00a8b	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00a90	68 ff ff ff 00	 push	 16777215		; 00ffffffH
  00a95	52		 push	 edx
  00a96	f7 e9		 imul	 ecx
  00a98	c1 fa 02	 sar	 edx, 2
  00a9b	8b ca		 mov	 ecx, edx
  00a9d	6a 00		 push	 0
  00a9f	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00aa2	03 d1		 add	 edx, ecx
  00aa4	52		 push	 edx
  00aa5	68 88 04 00 00	 push	 1160			; 00000488H
$L50062:
  00aaa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  00ab0	52		 push	 edx
  00ab1	ff d6		 call	 esi
  00ab3	50		 push	 eax
  00ab4	e8 00 00 00 00	 call	 ?DrawBarEx@@YAXPAUHWND__@@H_NKK@Z ; DrawBarEx

; 1290 : 	}
; 1291 : 
; 1292 : /*
; 1293 : 	for (i=1; i<=ChannelTotal; i++) {
; 1294 : 		if (g_bHorizontal)
; 1295 : 			DrawBarEx( GetDlgItem(g_hTabCurrent,(IDC_PROGRESSHORZ1-1)+i), int((RetInfo[i]-1000)/10), true );
; 1296 : 		else
; 1297 : 			DrawBarEx( GetDlgItem(g_hTabCurrent,(IDC_PROGRESSVERT1-1)+i), int((RetInfo[i]-1000)/10), false );
; 1298 : 	}
; 1299 : */
; 1300 : 	
; 1301 : /*	
; 1302 : 	// test with keys
; 1303 : 	if ( GetKeyState('A') & 0x80 ) {
; 1304 : 		//MessageBox(NULL,"qqq!","QQQ!",MB_OK);
; 1305 : 		++nPos;
; 1306 : 
; 1307 : 		//SendMessage( GetDlgItem(g_hTabCurrent,IDC_PROGRESSVERT1), PBM_SETRANGE, 0, MAKELPARAM(0, 100) );
; 1308 : 		//SendMessage( GetDlgItem(g_hTabCurrent,IDC_PROGRESSVERT1), PBM_SETSTEP, 1, 0 );
; 1309 : 		//SendMessage( GetDlgItem(g_hTabCurrent,IDC_PROGRESSVERT1), PBM_SETPOS, nPos, 0 );
; 1310 : 
; 1311 : 		//SendMessage( GetDlgItem(g_hTabCurrent,IDC_PROGRESSHORZ1), PBM_SETRANGE, 0, MAKELPARAM(0, 100) );
; 1312 : 		//SendMessage( GetDlgItem(g_hTabCurrent,IDC_PROGRESSHORZ1), PBM_SETSTEP, 1, 0 );
; 1313 : 		//SendMessage( GetDlgItem(g_hTabCurrent,IDC_PROGRESSHORZ1), PBM_SETPOS, nPos, 0 );
; 1314 : 
; 1315 : 		DrawBar( GetDlgItem(g_hTabCurrent,IDC_PROGRESSHORZ1), nPos );
; 1316 : 
; 1317 : 	}
; 1318 : 	if ( GetKeyState('S') & 0x80 ) {
; 1319 : 		--nPos;
; 1320 : 
; 1321 : 		//SendMessage( GetDlgItem(g_hTabCurrent,IDC_PROGRESSVERT1), PBM_SETRANGE, 0, MAKELPARAM(0, 100) );
; 1322 : 		//SendMessage( GetDlgItem(g_hTabCurrent,IDC_PROGRESSVERT1), PBM_SETSTEP, 1, 0 );
; 1323 : 		//SendMessage( GetDlgItem(g_hTabCurrent,IDC_PROGRESSVERT1), PBM_SETPOS, nPos, 0 );
; 1324 : 
; 1325 : 		//SendMessage( GetDlgItem(g_hTabCurrent,IDC_PROGRESSHORZ1), PBM_SETRANGE, 0, MAKELPARAM(0, 100) );
; 1326 : 		//SendMessage( GetDlgItem(g_hTabCurrent,IDC_PROGRESSHORZ1), PBM_SETSTEP, 10, 0 );
; 1327 : 		//SendMessage( GetDlgItem(g_hTabCurrent,IDC_PROGRESSHORZ1), PBM_SETPOS, nPos, 0 );
; 1328 : 
; 1329 : 		DrawBar( GetDlgItem(g_hTabCurrent,IDC_PROGRESSHORZ1), nPos );
; 1330 : 
; 1331 : 	}
; 1332 : */
; 1333 : 
; 1334 : 
; 1335 : 
; 1336 : 	// fill the pulse length listbox
; 1337 : 	// we krijgen hier synchronisatie problemen tussen GameLoop() en de VxD
; 1338 : 	// daarom kunnen we beter gewoon de sync/channel lengths printen
; 1339 : 	if (!g_bStop) {

  00ab9	a0 00 00 00 00	 mov	 al, BYTE PTR ?g_bStop@@3_NA ; g_bStop
  00abe	83 c4 14	 add	 esp, 20			; 00000014H
  00ac1	84 c0		 test	 al, al
  00ac3	0f 85 d8 02 00
	00		 jne	 $L49435

; 1340 : 		int dIndex;
; 1341 : 
; 1342 : 
; 1343 : 		// new format
; 1344 : 		sprintf( sync,  "%6.3f ms     ", fsync );

  00ac9	57		 push	 edi
  00aca	55		 push	 ebp
  00acb	8d 84 24 20 04
	00 00		 lea	 eax, DWORD PTR _sync$[esp+1824]
  00ad2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@EPNC@?$CF6?43f?5ms?5?5?5?5?5?$AA@ ; `string'
  00ad7	50		 push	 eax
  00ad8	e8 00 00 00 00	 call	 _sprintf

; 1345 : 		sprintf( ch1,  "%7.3f ms      ", fch1 );

  00add	8b 4c 24 6c	 mov	 ecx, DWORD PTR -1724+[esp+1832]
  00ae1	83 c4 10	 add	 esp, 16			; 00000010H
  00ae4	8d 94 24 18 02
	00 00		 lea	 edx, DWORD PTR _ch1$[esp+1816]
  00aeb	53		 push	 ebx
  00aec	51		 push	 ecx
  00aed	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@KKMC@?$CF7?43f?5ms?5?5?5?5?5?5?$AA@ ; `string'
  00af2	52		 push	 edx
  00af3	e8 00 00 00 00	 call	 _sprintf

; 1346 : 		sprintf( ch2,  "%7.3f ms      ", fch2 );

  00af8	8b 44 24 40	 mov	 eax, DWORD PTR -1772+[esp+1836]
  00afc	8b 4c 24 3c	 mov	 ecx, DWORD PTR -1772+[esp+1832]
  00b00	83 c4 10	 add	 esp, 16			; 00000010H
  00b03	8d 94 24 18 06
	00 00		 lea	 edx, DWORD PTR _ch2$[esp+1816]
  00b0a	50		 push	 eax
  00b0b	51		 push	 ecx
  00b0c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@KKMC@?$CF7?43f?5ms?5?5?5?5?5?5?$AA@ ; `string'
  00b11	52		 push	 edx
  00b12	e8 00 00 00 00	 call	 _sprintf

; 1347 : 		sprintf( ch3,  "%7.3f ms      ", fch3 );

  00b17	8b 44 24 50	 mov	 eax, DWORD PTR -1756+[esp+1836]
  00b1b	8b 4c 24 4c	 mov	 ecx, DWORD PTR -1756+[esp+1832]
  00b1f	83 c4 10	 add	 esp, 16			; 00000010H
  00b22	8d 94 24 18 03
	00 00		 lea	 edx, DWORD PTR _ch3$[esp+1816]
  00b29	50		 push	 eax
  00b2a	51		 push	 ecx
  00b2b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@KKMC@?$CF7?43f?5ms?5?5?5?5?5?5?$AA@ ; `string'
  00b30	52		 push	 edx
  00b31	e8 00 00 00 00	 call	 _sprintf

; 1348 : 		sprintf( ch4,  "%7.3f ms      ", fch4 );

  00b36	8b 44 24 28	 mov	 eax, DWORD PTR -1796+[esp+1836]
  00b3a	8b 4c 24 24	 mov	 ecx, DWORD PTR -1796+[esp+1832]
  00b3e	83 c4 10	 add	 esp, 16			; 00000010H
  00b41	8d 94 24 18 05
	00 00		 lea	 edx, DWORD PTR _ch4$[esp+1816]
  00b48	50		 push	 eax
  00b49	51		 push	 ecx
  00b4a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@KKMC@?$CF7?43f?5ms?5?5?5?5?5?5?$AA@ ; `string'
  00b4f	52		 push	 edx
  00b50	e8 00 00 00 00	 call	 _sprintf

; 1349 : 		sprintf( ch5,  "%7.3f ms      ", fch5 );

  00b55	8b 44 24 30	 mov	 eax, DWORD PTR -1788+[esp+1836]
  00b59	8b 4c 24 2c	 mov	 ecx, DWORD PTR -1788+[esp+1832]
  00b5d	83 c4 10	 add	 esp, 16			; 00000010H
  00b60	8d 94 24 98 00
	00 00		 lea	 edx, DWORD PTR _ch5$[esp+1816]
  00b67	50		 push	 eax
  00b68	51		 push	 ecx
  00b69	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@KKMC@?$CF7?43f?5ms?5?5?5?5?5?5?$AA@ ; `string'
  00b6e	52		 push	 edx
  00b6f	e8 00 00 00 00	 call	 _sprintf

; 1350 : 		sprintf( ch6,  "%7.3f ms      ", fch6 );

  00b74	8b 44 24 38	 mov	 eax, DWORD PTR -1780+[esp+1836]
  00b78	8b 4c 24 34	 mov	 ecx, DWORD PTR -1780+[esp+1832]
  00b7c	83 c4 10	 add	 esp, 16			; 00000010H
  00b7f	8d 94 24 98 01
	00 00		 lea	 edx, DWORD PTR _ch6$[esp+1816]
  00b86	50		 push	 eax
  00b87	51		 push	 ecx
  00b88	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@KKMC@?$CF7?43f?5ms?5?5?5?5?5?5?$AA@ ; `string'
  00b8d	52		 push	 edx
  00b8e	e8 00 00 00 00	 call	 _sprintf

; 1351 : 		sprintf( ch7,  "%7.3f ms      ", fch7 );

  00b93	8b 44 24 48	 mov	 eax, DWORD PTR -1764+[esp+1836]
  00b97	8b 4c 24 44	 mov	 ecx, DWORD PTR -1764+[esp+1832]
  00b9b	83 c4 10	 add	 esp, 16			; 00000010H
  00b9e	8d 94 24 98 02
	00 00		 lea	 edx, DWORD PTR _ch7$[esp+1816]
  00ba5	50		 push	 eax
  00ba6	51		 push	 ecx
  00ba7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@KKMC@?$CF7?43f?5ms?5?5?5?5?5?5?$AA@ ; `string'
  00bac	52		 push	 edx
  00bad	e8 00 00 00 00	 call	 _sprintf

; 1352 : 		sprintf( ch8,  "%7.3f ms      ", fch8 );

  00bb2	8b 44 24 68	 mov	 eax, DWORD PTR -1732+[esp+1836]
  00bb6	8b 4c 24 64	 mov	 ecx, DWORD PTR -1732+[esp+1832]
  00bba	83 c4 10	 add	 esp, 16			; 00000010H
  00bbd	8d 94 24 98 03
	00 00		 lea	 edx, DWORD PTR _ch8$[esp+1816]
  00bc4	50		 push	 eax
  00bc5	51		 push	 ecx
  00bc6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@KKMC@?$CF7?43f?5ms?5?5?5?5?5?5?$AA@ ; `string'
  00bcb	52		 push	 edx
  00bcc	e8 00 00 00 00	 call	 _sprintf

; 1353 : 		sprintf( ch9,  "%7.3f ms      ", fch9 );

  00bd1	8b 44 24 60	 mov	 eax, DWORD PTR -1740+[esp+1836]
  00bd5	8b 4c 24 5c	 mov	 ecx, DWORD PTR -1740+[esp+1832]
  00bd9	83 c4 10	 add	 esp, 16			; 00000010H
  00bdc	50		 push	 eax
  00bdd	51		 push	 ecx
  00bde	8d 94 24 a0 04
	00 00		 lea	 edx, DWORD PTR _ch9$[esp+1824]
  00be5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@KKMC@?$CF7?43f?5ms?5?5?5?5?5?5?$AA@ ; `string'
  00bea	52		 push	 edx
  00beb	e8 00 00 00 00	 call	 _sprintf

; 1354 : 		sprintf( ch10, "%7.3f ms      ", fch10);

  00bf0	8b 44 24 58	 mov	 eax, DWORD PTR -1748+[esp+1836]
  00bf4	8b 4c 24 54	 mov	 ecx, DWORD PTR -1748+[esp+1832]
  00bf8	83 c4 10	 add	 esp, 16			; 00000010H
  00bfb	8d 94 24 98 05
	00 00		 lea	 edx, DWORD PTR _ch10$[esp+1816]
  00c02	50		 push	 eax
  00c03	51		 push	 ecx
  00c04	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@KKMC@?$CF7?43f?5ms?5?5?5?5?5?5?$AA@ ; `string'
  00c09	52		 push	 edx
  00c0a	e8 00 00 00 00	 call	 _sprintf

; 1355 : 
; 1356 : 		
; 1357 : 		char* entry[11];
; 1358 : 		entry[0] = sync;
; 1359 : 		entry[1] = ch1;
; 1360 : 		entry[2] = ch2; 

  00c0f	8d 94 24 28 06
	00 00		 lea	 edx, DWORD PTR _ch2$[esp+1832]
  00c16	8d 84 24 28 04
	00 00		 lea	 eax, DWORD PTR _sync$[esp+1832]
  00c1d	8d 8c 24 28 02
	00 00		 lea	 ecx, DWORD PTR _ch1$[esp+1832]
  00c24	89 94 24 84 00
	00 00		 mov	 DWORD PTR _entry$49414[esp+1840], edx
  00c2b	89 44 24 7c	 mov	 DWORD PTR _entry$49414[esp+1832], eax
  00c2f	89 8c 24 80 00
	00 00		 mov	 DWORD PTR _entry$49414[esp+1836], ecx

; 1361 : 		entry[3] = ch3; 
; 1362 : 		entry[4] = ch4; 
; 1363 : 		entry[5] = ch5; 

  00c36	8d 94 24 a8 00
	00 00		 lea	 edx, DWORD PTR _ch5$[esp+1832]
  00c3d	83 c4 10	 add	 esp, 16			; 00000010H
  00c40	8d 84 24 18 03
	00 00		 lea	 eax, DWORD PTR _ch3$[esp+1816]
  00c47	8d 8c 24 18 05
	00 00		 lea	 ecx, DWORD PTR _ch4$[esp+1816]
  00c4e	89 94 24 80 00
	00 00		 mov	 DWORD PTR _entry$49414[esp+1836], edx
  00c55	89 44 24 78	 mov	 DWORD PTR _entry$49414[esp+1828], eax
  00c59	89 4c 24 7c	 mov	 DWORD PTR _entry$49414[esp+1832], ecx

; 1364 : 		entry[6] = ch6; 
; 1365 : 		entry[7] = ch7; 
; 1366 : 		entry[8] = ch8; 

  00c5d	8d 94 24 98 03
	00 00		 lea	 edx, DWORD PTR _ch8$[esp+1816]
  00c64	8d 84 24 98 01
	00 00		 lea	 eax, DWORD PTR _ch6$[esp+1816]
  00c6b	8d 8c 24 98 02
	00 00		 lea	 ecx, DWORD PTR _ch7$[esp+1816]

; 1367 : 		entry[9] = ch9; 
; 1368 : 		entry[10]= ch10;
; 1369 : 
; 1370 : 
; 1371 : #define MAXHISTORY	4096
; 1372 : 
; 1373 : 		// list box can contain max 2^16 items so clear the box from time to time
; 1374 : 		if(ListBox_GetCount( GetDlgItem(g_hTabCurrent,IDC_LIST1) ) == MAXHISTORY)

  00c72	6a 00		 push	 0
  00c74	89 94 24 90 00
	00 00		 mov	 DWORD PTR _entry$49414[esp+1852], edx
  00c7b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  00c81	6a 00		 push	 0
  00c83	89 84 24 8c 00
	00 00		 mov	 DWORD PTR _entry$49414[esp+1848], eax
  00c8a	89 8c 24 90 00
	00 00		 mov	 DWORD PTR _entry$49414[esp+1852], ecx
  00c91	68 8b 01 00 00	 push	 395			; 0000018bH
  00c96	8d 84 24 a4 04
	00 00		 lea	 eax, DWORD PTR _ch9$[esp+1828]
  00c9d	8d 8c 24 a4 05
	00 00		 lea	 ecx, DWORD PTR _ch10$[esp+1828]
  00ca4	68 74 04 00 00	 push	 1140			; 00000474H
  00ca9	52		 push	 edx
  00caa	89 84 24 a4 00
	00 00		 mov	 DWORD PTR _entry$49414[esp+1872], eax
  00cb1	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR _entry$49414[esp+1876], ecx
  00cb8	ff d6		 call	 esi
  00cba	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SendMessageA@16
  00cc0	50		 push	 eax
  00cc1	ff d7		 call	 edi
  00cc3	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00cc8	75 19		 jne	 SHORT $L49418

; 1375 : 			ListBox_ResetContent( GetDlgItem(g_hTabCurrent,IDC_LIST1) );

  00cca	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  00ccf	6a 00		 push	 0
  00cd1	6a 00		 push	 0
  00cd3	68 84 01 00 00	 push	 388			; 00000184H
  00cd8	68 74 04 00 00	 push	 1140			; 00000474H
  00cdd	50		 push	 eax
  00cde	ff d6		 call	 esi
  00ce0	50		 push	 eax
  00ce1	ff d7		 call	 edi
$L49418:

; 1376 : 		
; 1377 : 		// add entries (one per game loop)
; 1378 : 		static int i = -1;
; 1379 : 		++i;

  00ce3	a1 00 00 00 00	 mov	 eax, DWORD PTR _?i@?DA@??GameLoop@@YAXXZ@4HA$S49422

; 1380 : 
; 1381 : 		// print sync/channel lengths if Signal Connected
; 1382 : 		if (ChannelTotal != 0){

  00ce8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ChannelTotal@@3HA ; ChannelTotal
  00cee	40		 inc	 eax
  00cef	85 c9		 test	 ecx, ecx
  00cf1	a3 00 00 00 00	 mov	 DWORD PTR _?i@?DA@??GameLoop@@YAXXZ@4HA$S49422, eax
  00cf6	74 42		 je	 SHORT $L49423

; 1383 : 			if (i<=ChannelTotal) {

  00cf8	3b c1		 cmp	 eax, ecx
  00cfa	7f 32		 jg	 SHORT $L49424

; 1384 : 				dIndex = ListBox_AddString( GetDlgItem(g_hTabCurrent,IDC_LIST1), entry[i] );

  00cfc	8b 4c 84 6c	 mov	 ecx, DWORD PTR _entry$49414[esp+eax*4+1816]
  00d00	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  00d06	51		 push	 ecx
  00d07	6a 00		 push	 0
  00d09	68 80 01 00 00	 push	 384			; 00000180H
  00d0e	68 74 04 00 00	 push	 1140			; 00000474H
  00d13	52		 push	 edx
  00d14	ff d6		 call	 esi
  00d16	50		 push	 eax
  00d17	ff d7		 call	 edi

; 1385 : 				ListBox_SetTopIndex( GetDlgItem(g_hTabCurrent,IDC_LIST1),dIndex );

  00d19	6a 00		 push	 0
  00d1b	50		 push	 eax
  00d1c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  00d21	68 97 01 00 00	 push	 407			; 00000197H
  00d26	68 74 04 00 00	 push	 1140			; 00000474H
  00d2b	50		 push	 eax

; 1386 : 			} else {

  00d2c	eb 6e		 jmp	 SHORT $L50063
$L49424:

; 1387 : 				i = -1;

  00d2e	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _?i@?DA@??GameLoop@@YAXXZ@4HA$S49422, -1

; 1388 : 			}
; 1389 : 		} else {

  00d38	eb 67		 jmp	 SHORT $L49435
$L49423:

; 1390 : 			if (newint) {

  00d3a	8a 44 24 13	 mov	 al, BYTE PTR _newint$[esp+1816]
  00d3e	84 c0		 test	 al, al
  00d40	74 5f		 je	 SHORT $L49435

; 1391 : 				// directly print the pulse length if Signal Defective
; 1392 : 				char pulselength[128];
; 1393 : 				float fpulselength = (float)RetInfo[12]/1000;
; 1394 : 				sprintf( pulselength,  "%7.3f ms", fpulselength );

  00d42	db 05 30 00 00
	00		 fild	 DWORD PTR ?RetInfo@@3PAHA+48
  00d48	83 ec 08	 sub	 esp, 8
  00d4b	8d 8c 24 a0 06
	00 00		 lea	 ecx, DWORD PTR _pulselength$49436[esp+1824]
  00d52	d8 0d 00 00 00
	00		 fmul	 DWORD PTR $T50059
  00d58	dd 1c 24	 fstp	 QWORD PTR [esp]
  00d5b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08FJKB@?$CF7?43f?5ms?$AA@ ; `string'
  00d60	51		 push	 ecx
  00d61	e8 00 00 00 00	 call	 _sprintf

; 1395 : 
; 1396 : 				dIndex = ListBox_AddString( GetDlgItem(g_hTabCurrent,IDC_LIST1), pulselength );

  00d66	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  00d6b	83 c4 10	 add	 esp, 16			; 00000010H
  00d6e	8d 94 24 98 06
	00 00		 lea	 edx, DWORD PTR _pulselength$49436[esp+1816]
  00d75	52		 push	 edx
  00d76	6a 00		 push	 0
  00d78	68 80 01 00 00	 push	 384			; 00000180H
  00d7d	68 74 04 00 00	 push	 1140			; 00000474H
  00d82	50		 push	 eax
  00d83	ff d6		 call	 esi
  00d85	50		 push	 eax
  00d86	ff d7		 call	 edi

; 1397 : 				ListBox_SetTopIndex( GetDlgItem(g_hTabCurrent,IDC_LIST1),dIndex );

  00d88	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  00d8e	6a 00		 push	 0
  00d90	50		 push	 eax
  00d91	68 97 01 00 00	 push	 407			; 00000197H
  00d96	68 74 04 00 00	 push	 1140			; 00000474H
  00d9b	51		 push	 ecx
$L50063:
  00d9c	ff d6		 call	 esi
  00d9e	50		 push	 eax
  00d9f	ff d7		 call	 edi
$L49435:

; 1398 : 			} else {
; 1399 : 				 // print nothing if No Signal
; 1400 : 			}
; 1401 : 		}
; 1402 : 
; 1403 : 
; 1404 : 		//ListBox_SetItemData( GetDlgItem(g_hTabCurrent,IDC_LIST1),dIndex,1 );
; 1405 : 		//ListBox_SetTopIndex( GetDlgItem(g_hTabCurrent,IDC_LIST1),dIndex );
; 1406 : 	}
; 1407 : 
; 1408 : 
; 1409 : 
; 1410 : 	// animate tray icon
; 1411 : 	// Yes!!! How cool a gameloop is: timerloops suck forever.
; 1412 : 	// Artifacts: 
; 1413 : 	// - Start Button flickers
; 1414 : 	// - System menu won't always show when right-clicking on task-bar program icon
; 1415 : 	//   (no probs when right-clicking program caption)
; 1416 : 	// We'll give user option to not animate.
; 1417 : 	// TODO: for Signal Defective: clock-like animation, "waiting for connection"
; 1418 : 	//       bSignalConnected becomes iSignalStatus (0,1,2)
; 1419 : 	// TODO: option colored tray icons: 
; 1420 : 	//		 No Signal and Signal Defective: red rotor
; 1421 : 	//       Signal Connected: blue rotor
; 1422 : 	// TODO: het is beter een array van hIcon's te maken ipv elke keer Load/DestroyIcon
; 1423 : 
; 1424 : 	// No Signal: tray icon
; 1425 : 	hIcon0 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON10) );

  00da1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hInst@@3PAUHINSTANCE__@@A ; g_hInst
  00da7	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__LoadIconA@8
  00dad	68 8c 00 00 00	 push	 140			; 0000008cH
  00db2	52		 push	 edx
  00db3	ff d3		 call	 ebx
  00db5	a3 00 00 00 00	 mov	 DWORD PTR ?hIcon0@@3PAUHICON__@@A, eax ; hIcon0

; 1426 : 
; 1427 : 	// Signal Defective: animated tray icon
; 1428 : 	static k=0;
; 1429 : 	//hIcon1 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+k) );
; 1430 : 	static count1=0;
; 1431 : 	count1++;

  00dba	a1 00 00 00 00	 mov	 eax, DWORD PTR _?count1@?DP@??GameLoop@@YAXXZ@4HA$S49456
  00dbf	40		 inc	 eax
  00dc0	a3 00 00 00 00	 mov	 DWORD PTR _?count1@?DP@??GameLoop@@YAXXZ@4HA$S49456, eax

; 1432 : 	if (count1%32==0) {

  00dc5	99		 cdq
  00dc6	33 c2		 xor	 eax, edx
  00dc8	2b c2		 sub	 eax, edx
  00dca	83 e0 1f	 and	 eax, 31			; 0000001fH
  00dcd	33 c2		 xor	 eax, edx
  00dcf	2b c2		 sub	 eax, edx
  00dd1	75 12		 jne	 SHORT $L49457

; 1433 : 		hIcon1 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON11) );

  00dd3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hInst@@3PAUHINSTANCE__@@A ; g_hInst
  00dd8	68 8d 00 00 00	 push	 141			; 0000008dH
  00ddd	50		 push	 eax
  00dde	ff d3		 call	 ebx
  00de0	a3 00 00 00 00	 mov	 DWORD PTR ?hIcon1@@3PAUHICON__@@A, eax ; hIcon1
$L49457:

; 1434 : 		//k=0;
; 1435 : 	}
; 1436 : 	if (count1%64==0) {

  00de5	a1 00 00 00 00	 mov	 eax, DWORD PTR _?count1@?DP@??GameLoop@@YAXXZ@4HA$S49456
  00dea	99		 cdq
  00deb	33 c2		 xor	 eax, edx
  00ded	2b c2		 sub	 eax, edx
  00def	83 e0 3f	 and	 eax, 63			; 0000003fH
  00df2	33 c2		 xor	 eax, edx
  00df4	2b c2		 sub	 eax, edx
  00df6	75 13		 jne	 SHORT $L49462

; 1437 : 		hIcon1 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON12) );

  00df8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hInst@@3PAUHINSTANCE__@@A ; g_hInst
  00dfe	68 8e 00 00 00	 push	 142			; 0000008eH
  00e03	51		 push	 ecx
  00e04	ff d3		 call	 ebx
  00e06	a3 00 00 00 00	 mov	 DWORD PTR ?hIcon1@@3PAUHICON__@@A, eax ; hIcon1
$L49462:

; 1438 : 		//k=4;
; 1439 : 	}
; 1440 : 	//if (count1%16==0) {	// delay a bit
; 1441 : 	//	k++;
; 1442 : 	//	if (k > 7) k = 0;
; 1443 : 	//}
; 1444 : 
; 1445 : 	
; 1446 : 	// Signal Connected: animated tray icon
; 1447 : 	//static count2=0;
; 1448 : 	//count2++;
; 1449 : 	//if (count2%2==0) {	// delay a bit
; 1450 : 		static j=0;
; 1451 : 		hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1+j) );

  00e0b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _?j@?EF@??GameLoop@@YAXXZ@4HA$S49468
  00e11	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hInst@@3PAUHINSTANCE__@@A ; g_hInst
  00e16	81 c2 84 00 00
	00		 add	 edx, 132		; 00000084H
  00e1c	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00e22	52		 push	 edx
  00e23	50		 push	 eax
  00e24	ff d3		 call	 ebx
  00e26	8b d0		 mov	 edx, eax

; 1452 : 		j++;

  00e28	a1 00 00 00 00	 mov	 eax, DWORD PTR _?j@?EF@??GameLoop@@YAXXZ@4HA$S49468
  00e2d	40		 inc	 eax
  00e2e	89 15 00 00 00
	00		 mov	 DWORD PTR ?hIcon2@@3PAUHICON__@@A, edx ; hIcon2

; 1453 : 		if (j > 7) j = 0;

  00e34	83 f8 07	 cmp	 eax, 7
  00e37	a3 00 00 00 00	 mov	 DWORD PTR _?j@?EF@??GameLoop@@YAXXZ@4HA$S49468, eax
  00e3c	7e 0a		 jle	 SHORT $L49473
  00e3e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _?j@?EF@??GameLoop@@YAXXZ@4HA$S49468, 0
$L49473:

; 1454 : 	//}
; 1455 : 
; 1456 : 	strcpy(szTip, "R/C Sim Transmitter Calibration - ");

  00e48	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:??_C@_0CD@LHJF@R?1C?5Sim?5Transmitter?5Calibration?5@ ; `string'
  00e4d	83 c9 ff	 or	 ecx, -1
  00e50	33 c0		 xor	 eax, eax
  00e52	f2 ae		 repne scasb
  00e54	f7 d1		 not	 ecx
  00e56	2b f9		 sub	 edi, ecx
  00e58	8b c1		 mov	 eax, ecx
  00e5a	8b f7		 mov	 esi, edi
  00e5c	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:?szTip@@3PADA ; szTip
  00e61	c1 e9 02	 shr	 ecx, 2
  00e64	f3 a5		 rep movsd
  00e66	8b c8		 mov	 ecx, eax

; 1457 : 	strcat(szTip, status2);

  00e68	33 c0		 xor	 eax, eax
  00e6a	83 e1 03	 and	 ecx, 3
  00e6d	f3 a4		 rep movsb
  00e6f	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:?status2@@3PADA ; status2
  00e74	83 c9 ff	 or	 ecx, -1
  00e77	f2 ae		 repne scasb
  00e79	f7 d1		 not	 ecx
  00e7b	2b f9		 sub	 edi, ecx
  00e7d	8b f7		 mov	 esi, edi
  00e7f	8b e9		 mov	 ebp, ecx
  00e81	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:?szTip@@3PADA ; szTip
  00e86	83 c9 ff	 or	 ecx, -1
  00e89	f2 ae		 repne scasb
  00e8b	8b cd		 mov	 ecx, ebp
  00e8d	4f		 dec	 edi
  00e8e	c1 e9 02	 shr	 ecx, 2
  00e91	f3 a5		 rep movsd

; 1458 : 	
; 1459 : 	if (g_bShowInTray) {

  00e93	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_bShowInTray@@3KA ; g_bShowInTray
  00e98	8b cd		 mov	 ecx, ebp
  00e9a	83 e1 03	 and	 ecx, 3
  00e9d	85 c0		 test	 eax, eax
  00e9f	f3 a4		 rep movsb
  00ea1	74 64		 je	 SHORT $L49478

; 1460 : 		if (g_bAnimateTrayIcon)

  00ea3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_bAnimateTrayIcon@@3KA ; g_bAnimateTrayIcon
  00ea8	85 c0		 test	 eax, eax
  00eaa	74 5b		 je	 SHORT $L49478

; 1461 : 		{
; 1462 : 			switch ( iSignalStatus )

  00eac	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iSignalStatus@@3HA ; iSignalStatus
  00eb1	83 e8 00	 sub	 eax, 0
  00eb4	74 29		 je	 SHORT $L49481
  00eb6	48		 dec	 eax
  00eb7	74 12		 je	 SHORT $L49486
  00eb9	48		 dec	 eax
  00eba	75 4b		 jne	 SHORT $L49478

; 1471 : 				case 2:
; 1472 : 					ModifyTaskBarIcon( g_hWnd, hIcon2, szTip );

  00ebc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hWnd@@3PAUHWND__@@A ; g_hWnd
  00ec2	68 00 00 00 00	 push	 OFFSET FLAT:?szTip@@3PADA ; szTip
  00ec7	52		 push	 edx
  00ec8	51		 push	 ecx

; 1473 : 					break;

  00ec9	eb 34		 jmp	 SHORT $L50064
$L49486:

; 1467 : 					break;
; 1468 : 				case 1:
; 1469 : 					ModifyTaskBarIcon( g_hWnd, hIcon1, szTip );

  00ecb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hIcon1@@3PAUHICON__@@A ; hIcon1
  00ed1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hWnd@@3PAUHWND__@@A ; g_hWnd
  00ed6	68 00 00 00 00	 push	 OFFSET FLAT:?szTip@@3PADA ; szTip
  00edb	52		 push	 edx
  00edc	50		 push	 eax

; 1470 : 					break;

  00edd	eb 20		 jmp	 SHORT $L50064
$L49481:

; 1463 : 			{ 
; 1464 : 				case 0:
; 1465 : 					hIcon0 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON10) );

  00edf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hInst@@3PAUHINSTANCE__@@A ; g_hInst
  00ee5	68 8c 00 00 00	 push	 140			; 0000008cH
  00eea	51		 push	 ecx
  00eeb	ff d3		 call	 ebx

; 1466 : 					ModifyTaskBarIcon( g_hWnd, hIcon0, szTip );

  00eed	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hWnd@@3PAUHWND__@@A ; g_hWnd
  00ef3	68 00 00 00 00	 push	 OFFSET FLAT:?szTip@@3PADA ; szTip
  00ef8	50		 push	 eax
  00ef9	a3 00 00 00 00	 mov	 DWORD PTR ?hIcon0@@3PAUHICON__@@A, eax ; hIcon0
  00efe	52		 push	 edx
$L50064:
  00eff	e8 00 00 00 00	 call	 ?ModifyTaskBarIcon@@YAXPAUHWND__@@PAUHICON__@@PAD@Z ; ModifyTaskBarIcon
  00f04	83 c4 0c	 add	 esp, 12			; 0000000cH
$L49478:

; 1474 : 			}
; 1475 : 		}
; 1476 : /*
; 1477 : 		// Let's put this in timerloop to get rid of fucky system menu behaviour
; 1478 : 		else 
; 1479 : 		{
; 1480 : 			switch ( iSignalStatus )
; 1481 : 			{ 
; 1482 : 				case 0:
; 1483 : 					hIcon0 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON10) );
; 1484 : 					ModifyTaskBarIcon( g_hWnd, hIcon0, szTip );
; 1485 : 					break;
; 1486 : 				case 1:
; 1487 : 					hIcon1 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON11) );
; 1488 : 					ModifyTaskBarIcon( g_hWnd, hIcon1, szTip );
; 1489 : 					break;
; 1490 : 				case 2:
; 1491 : 					hIcon2 = LoadIcon( g_hInst, (LPCSTR)MAKEINTRESOURCE(IDI_ICON1) );
; 1492 : 					ModifyTaskBarIcon( g_hWnd, hIcon2, szTip );
; 1493 : 					break;
; 1494 : 			}
; 1495 : 		}
; 1496 : */
; 1497 : 	}		
; 1498 : 
; 1499 : 
; 1500 : 
; 1501 : 	// laat het geheugen niet vollopen!!!
; 1502 : 	DestroyIcon(hIcon0);

  00f07	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hIcon0@@3PAUHICON__@@A ; hIcon0
  00f0c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__DestroyIcon@4
  00f12	50		 push	 eax
  00f13	ff d6		 call	 esi

; 1503 : 	DestroyIcon(hIcon1);

  00f15	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hIcon1@@3PAUHICON__@@A ; hIcon1
  00f1b	51		 push	 ecx
  00f1c	ff d6		 call	 esi

; 1504 : 	DestroyIcon(hIcon2);

  00f1e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hIcon2@@3PAUHICON__@@A ; hIcon2
  00f24	52		 push	 edx
  00f25	ff d6		 call	 esi

; 1505 : 
; 1506 : 
; 1507 : }

  00f27	5f		 pop	 edi
  00f28	5e		 pop	 esi
  00f29	5d		 pop	 ebp
  00f2a	5b		 pop	 ebx
  00f2b	81 c4 08 07 00
	00		 add	 esp, 1800		; 00000708H
  00f31	c3		 ret	 0
?GameLoop@@YAXXZ ENDP					; GameLoop
_TEXT	ENDS
EXTRN	__imp__EndDialog@8:NEAR
;	COMDAT ?AboutProc@@YGHPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_hWnd$ = 8
_uMsg$ = 12
_wParam$ = 16
?AboutProc@@YGHPAUHWND__@@IIJ@Z PROC NEAR		; AboutProc, COMDAT

; 1520 : {

  00000	56		 push	 esi

; 1521 : 	switch (uMsg) {
; 1522 : 		case WM_INITDIALOG:
; 1523 : 			//CenterDialog(hWnd);
; 1524 : 			break;
; 1525 : 	}
; 1526 : 		
; 1527 : 	if( WM_COMMAND == uMsg )

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR _uMsg$[esp]
  00005	81 fe 11 01 00
	00		 cmp	 esi, 273		; 00000111H
  0000b	75 1d		 jne	 SHORT $L49501

; 1528 : 		if( IDOK == LOWORD(wParam) || IDCANCEL == LOWORD(wParam) )

  0000d	8b 44 24 10	 mov	 eax, DWORD PTR _wParam$[esp]
  00011	66 3d 01 00	 cmp	 ax, 1
  00015	74 06		 je	 SHORT $L49502
  00017	66 3d 02 00	 cmp	 ax, 2
  0001b	75 0d		 jne	 SHORT $L49501
$L49502:

; 1529 : 			EndDialog( hWnd, TRUE );

  0001d	8b 44 24 08	 mov	 eax, DWORD PTR _hWnd$[esp]
  00021	6a 01		 push	 1
  00023	50		 push	 eax
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndDialog@8
$L49501:

; 1530 : 	
; 1531 : 	 return WM_INITDIALOG == uMsg ? TRUE : FALSE;

  0002a	33 c0		 xor	 eax, eax
  0002c	81 fe 10 01 00
	00		 cmp	 esi, 272		; 00000110H
  00032	0f 94 c0	 sete	 al

; 1532 : }

  00035	5e		 pop	 esi
  00036	c2 10 00	 ret	 16			; 00000010H
?AboutProc@@YGHPAUHWND__@@IIJ@Z ENDP			; AboutProc
_TEXT	ENDS
PUBLIC	?CenterDialog@@YAXPAUHWND__@@@Z			; CenterDialog
EXTRN	__imp__GetWindowRect@8:NEAR
EXTRN	__imp__GetSystemMetrics@4:NEAR
EXTRN	__imp__GetParent@4:NEAR
EXTRN	__imp__MoveWindow@24:NEAR
;	COMDAT ?CenterDialog@@YAXPAUHWND__@@@Z
_TEXT	SEGMENT
_hdlg$ = 8
_rcParent$ = -32
_rcDlg$ = -16
?CenterDialog@@YAXPAUHWND__@@@Z PROC NEAR		; CenterDialog, COMDAT

; 1542 : {

  00000	83 ec 20	 sub	 esp, 32			; 00000020H
  00003	53		 push	 ebx
  00004	55		 push	 ebp

; 1543 : 	RECT  rcParent;                         // Parent window client rect
; 1544 : 	RECT  rcDlg;                            // Dialog window rect
; 1545 : 	int   nLeft, nTop;                      // Top-left coordinates
; 1546 : 	int   cWidth, cHeight;                  // Width and height
; 1547 : 	HWND  hwnd;
; 1548 : 
; 1549 : 	// Get frame window client rect in screen coordinates
; 1550 : 	if((hwnd = GetParent(hdlg)) == NULL || IsIconic(hwnd)) {

  00005	8b 6c 24 2c	 mov	 ebp, DWORD PTR _hdlg$[esp+36]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	55		 push	 ebp
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00012	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetWindowRect@8
  00018	8b f0		 mov	 esi, eax
  0001a	33 db		 xor	 ebx, ebx
  0001c	3b f3		 cmp	 esi, ebx
  0001e	74 15		 je	 SHORT $L49513
  00020	56		 push	 esi
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsIconic@4
  00027	85 c0		 test	 eax, eax
  00029	75 0a		 jne	 SHORT $L49513

; 1554 : 	}
; 1555 : 	else 
; 1556 : 		GetWindowRect(hwnd, &rcParent);

  0002b	8d 44 24 10	 lea	 eax, DWORD PTR _rcParent$[esp+48]
  0002f	50		 push	 eax
  00030	56		 push	 esi
  00031	ff d7		 call	 edi
  00033	eb 1e		 jmp	 SHORT $L49514
$L49513:

; 1551 : 		rcParent.top = rcParent.left = 0;
; 1552 : 		rcParent.right = GetSystemMetrics(SM_CXFULLSCREEN);

  00035	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetSystemMetrics@4
  0003b	6a 10		 push	 16			; 00000010H
  0003d	89 5c 24 14	 mov	 DWORD PTR _rcParent$[esp+52], ebx
  00041	89 5c 24 18	 mov	 DWORD PTR _rcParent$[esp+56], ebx
  00045	ff d6		 call	 esi

; 1553 : 		rcParent.bottom = GetSystemMetrics(SM_CYFULLSCREEN);

  00047	6a 11		 push	 17			; 00000011H
  00049	89 44 24 1c	 mov	 DWORD PTR _rcParent$[esp+60], eax
  0004d	ff d6		 call	 esi
  0004f	89 44 24 1c	 mov	 DWORD PTR _rcParent$[esp+60], eax
$L49514:

; 1557 : 
; 1558 : 	// Determine the top-left point for the dialog to be centered
; 1559 : 	GetWindowRect(hdlg, &rcDlg);

  00053	8d 4c 24 20	 lea	 ecx, DWORD PTR _rcDlg$[esp+48]
  00057	51		 push	 ecx
  00058	55		 push	 ebp
  00059	ff d7		 call	 edi

; 1560 : 	cWidth  = rcDlg.right  - rcDlg.left;

  0005b	8b 74 24 28	 mov	 esi, DWORD PTR _rcDlg$[esp+56]
  0005f	8b 7c 24 20	 mov	 edi, DWORD PTR _rcDlg$[esp+48]

; 1561 : 	cHeight = rcDlg.bottom - rcDlg.top;
; 1562 : 
; 1563 : 	nLeft   = rcParent.left + 
; 1564 : 			(((rcParent.right  - rcParent.left) - cWidth ) / 2);

  00063	8b 44 24 18	 mov	 eax, DWORD PTR _rcParent$[esp+56]
  00067	8b 5c 24 10	 mov	 ebx, DWORD PTR _rcParent$[esp+48]
  0006b	8b 54 24 24	 mov	 edx, DWORD PTR _rcDlg$[esp+52]
  0006f	2b f7		 sub	 esi, edi
  00071	8b 7c 24 2c	 mov	 edi, DWORD PTR _rcDlg$[esp+60]
  00075	2b c3		 sub	 eax, ebx
  00077	2b c6		 sub	 eax, esi
  00079	2b fa		 sub	 edi, edx
  0007b	99		 cdq
  0007c	2b c2		 sub	 eax, edx
  0007e	8b c8		 mov	 ecx, eax

; 1565 : 	nTop    = rcParent.top  +
; 1566 : 			(((rcParent.bottom - rcParent.top ) - cHeight) / 2);

  00080	8b 44 24 1c	 mov	 eax, DWORD PTR _rcParent$[esp+60]
  00084	d1 f9		 sar	 ecx, 1
  00086	03 cb		 add	 ecx, ebx
  00088	8b 5c 24 14	 mov	 ebx, DWORD PTR _rcParent$[esp+52]
  0008c	2b c3		 sub	 eax, ebx
  0008e	2b c7		 sub	 eax, edi
  00090	99		 cdq
  00091	2b c2		 sub	 eax, edx
  00093	d1 f8		 sar	 eax, 1
  00095	03 c3		 add	 eax, ebx

; 1567 : 	if (nLeft < 0) nLeft = 0;

  00097	85 c9		 test	 ecx, ecx
  00099	7d 02		 jge	 SHORT $L49515
  0009b	33 c9		 xor	 ecx, ecx
$L49515:

; 1568 : 	if (nTop  < 0) nTop  = 0;

  0009d	85 c0		 test	 eax, eax
  0009f	7d 02		 jge	 SHORT $L49516
  000a1	33 c0		 xor	 eax, eax
$L49516:

; 1569 : 
; 1570 : 
; 1571 : 	// Place the dialog
; 1572 : 	MoveWindow(hdlg, nLeft, nTop, cWidth, cHeight, TRUE);

  000a3	6a 01		 push	 1
  000a5	57		 push	 edi
  000a6	56		 push	 esi
  000a7	50		 push	 eax
  000a8	51		 push	 ecx
  000a9	55		 push	 ebp
  000aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveWindow@24

; 1573 : 	return;
; 1574 : }

  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	5d		 pop	 ebp
  000b3	5b		 pop	 ebx
  000b4	83 c4 20	 add	 esp, 32			; 00000020H
  000b7	c3		 ret	 0
?CenterDialog@@YAXPAUHWND__@@@Z ENDP			; CenterDialog
_TEXT	ENDS
PUBLIC	??_C@_09ENKN@Resources?$AA@			; `string'
PUBLIC	??_C@_08LCGJ@Channels?$AA@			; `string'
PUBLIC	??_C@_07LCKD@Mapping?$AA@			; `string'
PUBLIC	??_C@_0M@FDFJ@Sensitivity?$AA@			; `string'
;	COMDAT ??_C@_09ENKN@Resources?$AA@
; File E:\interface\TxintguiSDK\Bigpush\bigpush.cpp
_DATA	SEGMENT
??_C@_09ENKN@Resources?$AA@ DB 'Resources', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08LCGJ@Channels?$AA@
_DATA	SEGMENT
??_C@_08LCGJ@Channels?$AA@ DB 'Channels', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07LCKD@Mapping?$AA@
_DATA	SEGMENT
??_C@_07LCKD@Mapping?$AA@ DB 'Mapping', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@FDFJ@Sensitivity?$AA@
_DATA	SEGMENT
??_C@_0M@FDFJ@Sensitivity?$AA@ DB 'Sensitivity', 00H	; `string'
_DATA	ENDS
;	COMDAT ?CreateTabControl@@YAXPAUHWND__@@@Z
_TEXT	SEGMENT
_tcItem$ = -112
?CreateTabControl@@YAXPAUHWND__@@@Z PROC NEAR		; CreateTabControl, COMDAT

; 1584 : {

  00000	83 ec 70	 sub	 esp, 112		; 00000070H

; 1585 : 	TC_ITEM tcItem[4];
; 1586 : 
; 1587 : 	tcItem[0].mask = TCIF_IMAGE|TCIF_TEXT;
; 1588 : 	tcItem[0].pszText = "Resources";
; 1589 : 	tcItem[0].iImage = -1;

  00003	83 c8 ff	 or	 eax, -1
  00006	b9 03 00 00 00	 mov	 ecx, 3
  0000b	89 44 24 14	 mov	 DWORD PTR _tcItem$[esp+132], eax

; 1590 : 
; 1591 : 	tcItem[1].mask = TCIF_IMAGE|TCIF_TEXT;
; 1592 : 	tcItem[1].pszText = "Channels";
; 1593 : 	tcItem[1].iImage = -1;

  0000f	89 44 24 30	 mov	 DWORD PTR _tcItem$[esp+160], eax

; 1594 : 
; 1595 : 	tcItem[2].mask = TCIF_IMAGE|TCIF_TEXT;
; 1596 : 	tcItem[2].pszText = "Mapping";
; 1597 : 	tcItem[2].iImage = -1;

  00013	89 44 24 4c	 mov	 DWORD PTR _tcItem$[esp+188], eax

; 1598 : 
; 1599 : 	tcItem[3].mask = TCIF_IMAGE|TCIF_TEXT;
; 1600 : 	tcItem[3].pszText = "Sensitivity";
; 1601 : 	tcItem[3].iImage = -1;

  00017	89 44 24 68	 mov	 DWORD PTR _tcItem$[esp+216], eax

; 1602 : 
; 1603 : 	// insert the tabs
; 1604 : 	SendMessage( g_hTabControl,TCM_INSERTITEM,0,(LPARAM)&tcItem[0] );

  0001b	8d 44 24 00	 lea	 eax, DWORD PTR _tcItem$[esp+112]
  0001f	56		 push	 esi
  00020	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  00026	89 4c 24 04	 mov	 DWORD PTR _tcItem$[esp+116], ecx
  0002a	89 4c 24 20	 mov	 DWORD PTR _tcItem$[esp+144], ecx
  0002e	89 4c 24 3c	 mov	 DWORD PTR _tcItem$[esp+172], ecx
  00032	89 4c 24 58	 mov	 DWORD PTR _tcItem$[esp+200], ecx
  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hTabControl@@3PAUHWND__@@A ; g_hTabControl
  0003c	50		 push	 eax
  0003d	6a 00		 push	 0
  0003f	68 07 13 00 00	 push	 4871			; 00001307H
  00044	51		 push	 ecx
  00045	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _tcItem$[esp+144], OFFSET FLAT:??_C@_09ENKN@Resources?$AA@ ; `string'
  0004d	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR _tcItem$[esp+172], OFFSET FLAT:??_C@_08LCGJ@Channels?$AA@ ; `string'
  00055	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR _tcItem$[esp+200], OFFSET FLAT:??_C@_07LCKD@Mapping?$AA@ ; `string'
  0005d	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR _tcItem$[esp+228], OFFSET FLAT:??_C@_0M@FDFJ@Sensitivity?$AA@ ; `string'
  00065	ff d6		 call	 esi

; 1605 : 	SendMessage( g_hTabControl,TCM_INSERTITEM,1,(LPARAM)&tcItem[1] );

  00067	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hTabControl@@3PAUHWND__@@A ; g_hTabControl
  0006c	8d 54 24 20	 lea	 edx, DWORD PTR _tcItem$[esp+144]
  00070	52		 push	 edx
  00071	6a 01		 push	 1
  00073	68 07 13 00 00	 push	 4871			; 00001307H
  00078	50		 push	 eax
  00079	ff d6		 call	 esi

; 1606 : 	SendMessage( g_hTabControl,TCM_INSERTITEM,2,(LPARAM)&tcItem[2] );

  0007b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hTabControl@@3PAUHWND__@@A ; g_hTabControl
  00081	8d 4c 24 3c	 lea	 ecx, DWORD PTR _tcItem$[esp+172]
  00085	51		 push	 ecx
  00086	6a 02		 push	 2
  00088	68 07 13 00 00	 push	 4871			; 00001307H
  0008d	52		 push	 edx
  0008e	ff d6		 call	 esi

; 1607 : 	//SendMessage( g_hTabControl,TCM_INSERTITEM,3,(LPARAM)&tcItem[3] );
; 1608 : 
; 1609 : 	
; 1610 : 	// Dit is niet nodig omdat we CreateDialog() gebruiken
; 1611 : 	// Load the dialog pages for the tab control
; 1612 : 	// Note: de dialog pages hebben: Styles->Border->None
; 1613 : 	// Don't use property pages since they have More Styles->Disabled
; 1614 : 	// Let op: pTabPage[0] = Dialog 1
; 1615 : 	//pTabPage[0] = (DLGTEMPLATE*)LockResource( LoadResource(g_hInst, FindResource(NULL,MAKEINTRESOURCE(IDD_DIALOG1),RT_DIALOG)) );
; 1616 :     //pTabPage[1] = (DLGTEMPLATE*)LockResource( LoadResource(g_hInst, FindResource(NULL,MAKEINTRESOURCE(IDD_DIALOG2),RT_DIALOG)) );
; 1617 :     //pTabPage[2] = (DLGTEMPLATE*)LockResource( LoadResource(g_hInst, FindResource(NULL,MAKEINTRESOURCE(IDD_DIALOG3),RT_DIALOG)) );
; 1618 :     //pTabPage[3] = (DLGTEMPLATE*)LockResource( LoadResource(g_hInst, FindResource(NULL,MAKEINTRESOURCE(IDD_DIALOG4),RT_DIALOG)) );
; 1619 : 
; 1620 : }

  00090	5e		 pop	 esi
  00091	83 c4 70	 add	 esp, 112		; 00000070H
  00094	c3		 ret	 0
?CreateTabControl@@YAXPAUHWND__@@@Z ENDP		; CreateTabControl
_TEXT	ENDS
EXTRN	?Tab1DlgProc@@YGHPAUHWND__@@IIJ@Z:NEAR		; Tab1DlgProc
EXTRN	?Tab2DlgProc@@YGHPAUHWND__@@IIJ@Z:NEAR		; Tab2DlgProc
EXTRN	?Tab3DlgProc@@YGHPAUHWND__@@IIJ@Z:NEAR		; Tab3DlgProc
EXTRN	?Tab5DlgProc@@YGHPAUHWND__@@IIJ@Z:NEAR		; Tab5DlgProc
_BSS	SEGMENT
_?NewPage@?1??TabChange@@YAXPAUHWND__@@@Z@4HA$S49530 DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ?TabChange@@YAXPAUHWND__@@@Z
_TEXT	SEGMENT
_hWnd$ = 8
?TabChange@@YAXPAUHWND__@@@Z PROC NEAR			; TabChange, COMDAT

; 1626 :     static int  NewPage;
; 1627 : 
; 1628 : 
; 1629 : 	
; 1630 :     if (g_hTabCurrent != NULL)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  00005	56		 push	 esi
  00006	85 c0		 test	 eax, eax
  00008	57		 push	 edi
  00009	74 07		 je	 SHORT $L49531

; 1631 : 		DestroyWindow(g_hTabCurrent); 

  0000b	50		 push	 eax
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
$L49531:

; 1632 :  
; 1633 :     NewPage = TabCtrl_GetCurSel(g_hTabControl); 

  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hTabControl@@3PAUHWND__@@A ; g_hTabControl
  00017	6a 00		 push	 0
  00019	6a 00		 push	 0
  0001b	68 0b 13 00 00	 push	 4875			; 0000130bH
  00020	50		 push	 eax
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 1634 :  
; 1635 :     // Let op: NewPage 0 is Dialog 1
; 1636 : 	//if(NewPage == 0) g_hTabCurrent = CreateDialogIndirect(g_hInst,pTabPage[NewPage],g_hTabControl,(DLGPROC)Tab1DlgProc); 
; 1637 :     //if(NewPage == 1) g_hTabCurrent = CreateDialogIndirect(g_hInst,pTabPage[NewPage],g_hTabControl,(DLGPROC)Tab2DlgProc); 
; 1638 :     //if(NewPage == 2) g_hTabCurrent = CreateDialogIndirect(g_hInst,pTabPage[NewPage],g_hTabControl,(DLGPROC)Tab3DlgProc); 
; 1639 :     //if(NewPage == 3) g_hTabCurrent = CreateDialogIndirect(g_hInst,pTabPage[NewPage],g_hTabControl,(DLGPROC)Tab4DlgProc);
; 1640 : 
; 1641 : 	// Dit is veel beter: geen arrays en pointers!!!!!!!!!
; 1642 : 	// Note: make main dialog (hWnd) owner of tab dialogs
; 1643 : 	if(NewPage == 0) g_hTabCurrent = CreateDialog(g_hInst,MAKEINTRESOURCE(IDD_DIALOG1),hWnd,(DLGPROC)Tab1DlgProc); 

  00027	8b 74 24 0c	 mov	 esi, DWORD PTR _hWnd$[esp+4]
  0002b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CreateDialogParamA@20
  00031	85 c0		 test	 eax, eax
  00033	a3 00 00 00 00	 mov	 DWORD PTR _?NewPage@?1??TabChange@@YAXPAUHWND__@@@Z@4HA$S49530, eax
  00038	75 18		 jne	 SHORT $L49533
  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hInst@@3PAUHINSTANCE__@@A ; g_hInst
  00040	6a 00		 push	 0
  00042	68 00 00 00 00	 push	 OFFSET FLAT:?Tab1DlgProc@@YGHPAUHWND__@@IIJ@Z ; Tab1DlgProc
  00047	56		 push	 esi
  00048	6a 6b		 push	 107			; 0000006bH
  0004a	51		 push	 ecx
  0004b	ff d7		 call	 edi
  0004d	a3 00 00 00 00	 mov	 DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A, eax ; g_hTabCurrent
$L49533:

; 1644 : 	if(NewPage == 1)

  00052	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _?NewPage@?1??TabChange@@YAXPAUHWND__@@@Z@4HA$S49530, 1
  00059	75 31		 jne	 SHORT $L49544

; 1645 : 		if (g_bHorizontal)

  0005b	a0 00 00 00 00	 mov	 al, BYTE PTR ?g_bHorizontal@@3_NA ; g_bHorizontal

; 1646 : 			g_hTabCurrent = CreateDialog(g_hInst,MAKEINTRESOURCE(IDD_DIALOG5),hWnd,(DLGPROC)Tab5DlgProc);

  00060	6a 00		 push	 0
  00062	84 c0		 test	 al, al
  00064	74 11		 je	 SHORT $L49539
  00066	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hInst@@3PAUHINSTANCE__@@A ; g_hInst
  0006c	68 00 00 00 00	 push	 OFFSET FLAT:?Tab5DlgProc@@YGHPAUHWND__@@IIJ@Z ; Tab5DlgProc
  00071	56		 push	 esi
  00072	6a 70		 push	 112			; 00000070H
  00074	52		 push	 edx

; 1647 : 		else

  00075	eb 0e		 jmp	 SHORT $L50073
$L49539:

; 1648 : 			g_hTabCurrent = CreateDialog(g_hInst,MAKEINTRESOURCE(IDD_DIALOG2),hWnd,(DLGPROC)Tab2DlgProc);

  00077	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hInst@@3PAUHINSTANCE__@@A ; g_hInst
  0007c	68 00 00 00 00	 push	 OFFSET FLAT:?Tab2DlgProc@@YGHPAUHWND__@@IIJ@Z ; Tab2DlgProc
  00081	56		 push	 esi
  00082	6a 6d		 push	 109			; 0000006dH
  00084	50		 push	 eax
$L50073:
  00085	ff d7		 call	 edi
  00087	a3 00 00 00 00	 mov	 DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A, eax ; g_hTabCurrent
$L49544:

; 1649 : 	if(NewPage == 2) g_hTabCurrent = CreateDialog(g_hInst,MAKEINTRESOURCE(IDD_DIALOG3),hWnd,(DLGPROC)Tab3DlgProc); 

  0008c	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _?NewPage@?1??TabChange@@YAXPAUHWND__@@@Z@4HA$S49530, 2
  00093	75 18		 jne	 SHORT $L49549
  00095	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hInst@@3PAUHINSTANCE__@@A ; g_hInst
  0009b	6a 00		 push	 0
  0009d	68 00 00 00 00	 push	 OFFSET FLAT:?Tab3DlgProc@@YGHPAUHWND__@@IIJ@Z ; Tab3DlgProc
  000a2	56		 push	 esi
  000a3	6a 6e		 push	 110			; 0000006eH
  000a5	51		 push	 ecx
  000a6	ff d7		 call	 edi
  000a8	a3 00 00 00 00	 mov	 DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A, eax ; g_hTabCurrent
$L49549:

; 1650 : 	//if(NewPage == 3) g_hTabCurrent = CreateDialog(g_hInst,MAKEINTRESOURCE(IDD_DIALOG4),g_hTabControl,(DLGPROC)Tab4DlgProc); 
; 1651 :  
; 1652 : 
; 1653 :     ShowWindow(g_hTabCurrent, SW_SHOW);

  000ad	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hTabCurrent@@3PAUHWND__@@A ; g_hTabCurrent
  000b3	6a 05		 push	 5
  000b5	52		 push	 edx
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 1654 : 
; 1655 : }

  000bc	5f		 pop	 edi
  000bd	5e		 pop	 esi
  000be	c3		 ret	 0
?TabChange@@YAXPAUHWND__@@@Z ENDP			; TabChange
_TEXT	ENDS
PUBLIC	?TabCenter@@YAXPAUHWND__@@@Z			; TabCenter
_BSS	SEGMENT
_?WinRect@?1??TabCenter@@YAXPAUHWND__@@@Z@4UtagRECT@@A$S49557 DB 010H DUP (?)
_?TabRect@?1??TabCenter@@YAXPAUHWND__@@@Z@4UtagRECT@@A$S49559 DB 010H DUP (?)
_BSS	ENDS
;	COMDAT ?TabCenter@@YAXPAUHWND__@@@Z
_TEXT	SEGMENT
_hWnd$ = 8
?TabCenter@@YAXPAUHWND__@@@Z PROC NEAR			; TabCenter, COMDAT

; 1662 : 	static RECT WinRect;
; 1663 : 	static RECT TabRect;
; 1664 : 
; 1665 : 	GetWindowRect(g_hTabControl, &TabRect);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hTabControl@@3PAUHWND__@@A ; g_hTabControl
  00005	56		 push	 esi
  00006	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetWindowRect@8
  0000c	57		 push	 edi
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:_?TabRect@?1??TabCenter@@YAXPAUHWND__@@@Z@4UtagRECT@@A$S49559
  00012	50		 push	 eax
  00013	ff d6		 call	 esi

; 1666 : 	GetWindowRect(GetParent(hWnd), &WinRect);

  00015	8b 7c 24 0c	 mov	 edi, DWORD PTR _hWnd$[esp+4]
  00019	68 00 00 00 00	 push	 OFFSET FLAT:_?WinRect@?1??TabCenter@@YAXPAUHWND__@@@Z@4UtagRECT@@A$S49557
  0001e	57		 push	 edi
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00025	50		 push	 eax
  00026	ff d6		 call	 esi

; 1667 : 
; 1668 : 	WinRect.left = TabRect.left - WinRect.left;

  00028	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _?TabRect@?1??TabCenter@@YAXPAUHWND__@@@Z@4UtagRECT@@A$S49559
  0002e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _?WinRect@?1??TabCenter@@YAXPAUHWND__@@@Z@4UtagRECT@@A$S49557
  00034	2b ca		 sub	 ecx, edx

; 1669 : 	WinRect.top  = (TabRect.top  - WinRect.top) - GetSystemMetrics(SM_CYCAPTION);

  00036	6a 04		 push	 4
  00038	89 0d 00 00 00
	00		 mov	 DWORD PTR _?WinRect@?1??TabCenter@@YAXPAUHWND__@@@Z@4UtagRECT@@A$S49557, ecx
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  00044	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _?TabRect@?1??TabCenter@@YAXPAUHWND__@@@Z@4UtagRECT@@A$S49559+4
  0004a	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _?WinRect@?1??TabCenter@@YAXPAUHWND__@@@Z@4UtagRECT@@A$S49557+4
  00050	2b d6		 sub	 edx, esi

; 1670 :  
; 1671 : 	TabCtrl_AdjustRect(g_hTabControl, FALSE, &WinRect); 

  00052	68 00 00 00 00	 push	 OFFSET FLAT:_?WinRect@?1??TabCenter@@YAXPAUHWND__@@@Z@4UtagRECT@@A$S49557
  00057	2b d0		 sub	 edx, eax
  00059	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hTabControl@@3PAUHWND__@@A ; g_hTabControl
  0005e	6a 00		 push	 0
  00060	68 28 13 00 00	 push	 4904			; 00001328H
  00065	50		 push	 eax
  00066	89 15 04 00 00
	00		 mov	 DWORD PTR _?WinRect@?1??TabCenter@@YAXPAUHWND__@@@Z@4UtagRECT@@A$S49557+4, edx
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 1672 :  
; 1673 : 	SetWindowPos(hWnd, HWND_TOP, WinRect.left, WinRect.top, 0, 0, SWP_NOSIZE);

  00072	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _?WinRect@?1??TabCenter@@YAXPAUHWND__@@@Z@4UtagRECT@@A$S49557+4
  00078	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _?WinRect@?1??TabCenter@@YAXPAUHWND__@@@Z@4UtagRECT@@A$S49557
  0007e	6a 01		 push	 1
  00080	6a 00		 push	 0
  00082	6a 00		 push	 0
  00084	51		 push	 ecx
  00085	52		 push	 edx
  00086	6a 00		 push	 0
  00088	57		 push	 edi
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28

; 1674 : }

  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	c3		 ret	 0
?TabCenter@@YAXPAUHWND__@@@Z ENDP			; TabCenter
_TEXT	ENDS
EXTRN	__imp__MulDiv@12:NEAR
EXTRN	__imp__SetBkColor@8:NEAR
EXTRN	__imp__GetClientRect@8:NEAR
EXTRN	__imp__wsprintfA:NEAR
EXTRN	__imp__SetTextColor@8:NEAR
EXTRN	__imp__SetTextAlign@8:NEAR
EXTRN	__imp__SetRect@20:NEAR
EXTRN	__imp__ExtTextOutA@32:NEAR
EXTRN	__ftol:NEAR
EXTRN	__imp__GetDC@4:NEAR
EXTRN	__imp__ReleaseDC@8:NEAR
CONST	SEGMENT
	ORG $+4
$T50077	DQ	03feccccccccccccdr		; 0.9
CONST	ENDS
;	COMDAT ?DrawBarEx@@YAXPAUHWND__@@H_NKK@Z
_TEXT	SEGMENT
_hwnd$ = 8
_percent$ = 12
_horz$ = 16
_crColorBar$ = 20
_crColorText$ = 24
_rect$ = -68
_rectfull$ = -52
_rectempty$ = -36
_buffer$ = -20
?DrawBarEx@@YAXPAUHWND__@@H_NKK@Z PROC NEAR		; DrawBarEx, COMDAT

; 1734 : {

  00000	83 ec 44	 sub	 esp, 68			; 00000044H

; 1735 : //#define COLOUR_TEXT		RGB(255,255,255)
; 1736 : //#define COLOUR_BAR		RGB(0,0,255)
; 1737 : 
; 1738 :     RECT rect;
; 1739 :     GetClientRect(hwnd,&rect);

  00003	8d 44 24 00	 lea	 eax, DWORD PTR _rect$[esp+68]
  00007	56		 push	 esi
  00008	8b 74 24 4c	 mov	 esi, DWORD PTR _hwnd$[esp+68]
  0000c	50		 push	 eax
  0000d	56		 push	 esi
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8

; 1740 : 	int divider;
; 1741 : 
; 1742 : 	// omit this and big bars might be drawn anywhere...
; 1743 : 	if (hwnd == NULL)

  00014	85 f6		 test	 esi, esi
  00016	0f 84 8c 01 00
	00		 je	 $L49571
  0001c	57		 push	 edi
  0001d	55		 push	 ebp
  0001e	53		 push	 ebx

; 1744 : 		return;
; 1745 : 
; 1746 : 	if (horz) {

  0001f	8a 5c 24 60	 mov	 bl, BYTE PTR _horz$[esp+80]
  00023	84 db		 test	 bl, bl

; 1747 : 		divider=MulDiv(percent,rect.right,100);

  00025	6a 64		 push	 100			; 00000064H
  00027	74 14		 je	 SHORT $L49575
  00029	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rect$[esp+96]
  0002d	8b 7c 24 60	 mov	 edi, DWORD PTR _percent$[esp+84]
  00031	51		 push	 ecx
  00032	57		 push	 edi
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MulDiv@12
  00039	8b f0		 mov	 esi, eax

; 1748 : 	} else {

  0003b	eb 16		 jmp	 SHORT $L49576
$L49575:

; 1749 : 		divider=MulDiv(percent,rect.bottom,100);

  0003d	8b 54 24 20	 mov	 edx, DWORD PTR _rect$[esp+100]
  00041	8b 7c 24 60	 mov	 edi, DWORD PTR _percent$[esp+84]
  00045	52		 push	 edx
  00046	57		 push	 edi
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MulDiv@12

; 1750 : 		divider=rect.bottom-divider;

  0004d	8b 74 24 1c	 mov	 esi, DWORD PTR _rect$[esp+96]
  00051	2b f0		 sub	 esi, eax
$L49576:

; 1751 : 	}
; 1752 :  
; 1753 :     RECT rectfull,rectempty;
; 1754 : 	if (horz) {

  00053	84 db		 test	 bl, bl
  00055	74 2b		 je	 SHORT $L49579

; 1755 : 		SetRect(&rectfull,0,0,divider,rect.bottom);

  00057	8b 44 24 1c	 mov	 eax, DWORD PTR _rect$[esp+96]
  0005b	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__SetRect@20
  00061	50		 push	 eax
  00062	56		 push	 esi
  00063	6a 00		 push	 0
  00065	8d 4c 24 2c	 lea	 ecx, DWORD PTR _rectfull$[esp+96]
  00069	6a 00		 push	 0
  0006b	51		 push	 ecx
  0006c	ff d5		 call	 ebp

; 1756 : 		SetRect(&rectempty,divider,0,rect.right,rect.bottom);

  0006e	8b 54 24 1c	 mov	 edx, DWORD PTR _rect$[esp+96]
  00072	8b 44 24 18	 mov	 eax, DWORD PTR _rect$[esp+92]
  00076	52		 push	 edx
  00077	50		 push	 eax
  00078	6a 00		 push	 0
  0007a	8d 4c 24 3c	 lea	 ecx, DWORD PTR _rectempty$[esp+96]
  0007e	56		 push	 esi
  0007f	51		 push	 ecx

; 1757 : 	} else {

  00080	eb 29		 jmp	 SHORT $L50078
$L49579:

; 1758 : 		SetRect(&rectempty,0,0,rect.right,divider);

  00082	8b 54 24 18	 mov	 edx, DWORD PTR _rect$[esp+92]
  00086	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__SetRect@20
  0008c	56		 push	 esi
  0008d	52		 push	 edx
  0008e	6a 00		 push	 0
  00090	8d 44 24 3c	 lea	 eax, DWORD PTR _rectempty$[esp+96]
  00094	6a 00		 push	 0
  00096	50		 push	 eax
  00097	ff d5		 call	 ebp

; 1759 : 		SetRect(&rectfull,0,divider,rect.right,rect.bottom);

  00099	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rect$[esp+96]
  0009d	8b 54 24 18	 mov	 edx, DWORD PTR _rect$[esp+92]
  000a1	51		 push	 ecx
  000a2	52		 push	 edx
  000a3	56		 push	 esi
  000a4	8d 44 24 2c	 lea	 eax, DWORD PTR _rectfull$[esp+96]
  000a8	6a 00		 push	 0
  000aa	50		 push	 eax
$L50078:
  000ab	ff d5		 call	 ebp

; 1760 : 	}
; 1761 :  
; 1762 :     char buffer[20];
; 1763 : 	int x;
; 1764 : 	int y;
; 1765 : 
; 1766 : 	if (horz) {

  000ad	84 db		 test	 bl, bl

; 1767 : 		//wsprintf(buffer,"%d %%",percent);
; 1768 : 		wsprintf(buffer,"",percent);

  000af	57		 push	 edi
  000b0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
  000b5	74 2c		 je	 SHORT $L49584
  000b7	8d 4c 24 48	 lea	 ecx, DWORD PTR _buffer$[esp+92]
  000bb	51		 push	 ecx
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 1769 : 		x=int(rect.right/2);

  000c2	8b 44 24 24	 mov	 eax, DWORD PTR _rect$[esp+104]
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1770 : 		y=int(rect.bottom*0.9);

  000c9	db 44 24 1c	 fild	 DWORD PTR _rect$[esp+96]
  000cd	99		 cdq
  000ce	dc 0d 00 00 00
	00		 fmul	 QWORD PTR $T50077
  000d4	2b c2		 sub	 eax, edx
  000d6	8b d8		 mov	 ebx, eax
  000d8	d1 fb		 sar	 ebx, 1
  000da	e8 00 00 00 00	 call	 __ftol
  000df	8b e8		 mov	 ebp, eax

; 1771 : 	} else {

  000e1	eb 24		 jmp	 SHORT $L49585
$L49584:

; 1772 : 		//wsprintf(buffer,"%d %%",percent);
; 1773 : 		wsprintf(buffer,"",percent);

  000e3	8d 54 24 48	 lea	 edx, DWORD PTR _buffer$[esp+92]
  000e7	52		 push	 edx
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 1774 : 		x=int(rect.right/2);

  000ee	8b 44 24 24	 mov	 eax, DWORD PTR _rect$[esp+104]
  000f2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f5	99		 cdq
  000f6	2b c2		 sub	 eax, edx
  000f8	8b d8		 mov	 ebx, eax

; 1775 : 		y=int(rect.bottom/2);

  000fa	8b 44 24 1c	 mov	 eax, DWORD PTR _rect$[esp+96]
  000fe	99		 cdq
  000ff	2b c2		 sub	 eax, edx
  00101	8b e8		 mov	 ebp, eax
  00103	d1 fb		 sar	 ebx, 1
  00105	d1 fd		 sar	 ebp, 1
$L49585:

; 1776 : 	}
; 1777 :  
; 1778 :     HDC hdc=GetDC(hwnd);

  00107	8b 44 24 58	 mov	 eax, DWORD PTR _hwnd$[esp+80]
  0010b	50		 push	 eax
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4
  00112	8b f0		 mov	 esi, eax

; 1779 :  
; 1780 :     SetTextAlign(hdc,TA_CENTER | TA_BASELINE);

  00114	6a 1e		 push	 30			; 0000001eH
  00116	56		 push	 esi
  00117	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTextAlign@8

; 1781 :  
; 1782 :     // full rectangle
; 1783 :     SetTextColor(hdc,crColorText);

  0011d	8b 4c 24 68	 mov	 ecx, DWORD PTR _crColorText$[esp+80]
  00121	51		 push	 ecx
  00122	56		 push	 esi
  00123	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTextColor@8

; 1784 :     SetBkColor  (hdc,crColorBar);

  00129	8b 54 24 64	 mov	 edx, DWORD PTR _crColorBar$[esp+80]
  0012d	52		 push	 edx
  0012e	56		 push	 esi
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8

; 1785 :     ExtTextOut  (hdc,x,y,ETO_CLIPPED | ETO_OPAQUE,
; 1786 :             &rectfull, buffer,strlen(buffer),NULL);

  00135	8d 7c 24 40	 lea	 edi, DWORD PTR _buffer$[esp+84]
  00139	83 c9 ff	 or	 ecx, -1
  0013c	33 c0		 xor	 eax, eax
  0013e	6a 00		 push	 0
  00140	f2 ae		 repne scasb
  00142	f7 d1		 not	 ecx
  00144	49		 dec	 ecx
  00145	8d 44 24 44	 lea	 eax, DWORD PTR _buffer$[esp+88]
  00149	51		 push	 ecx
  0014a	8d 4c 24 28	 lea	 ecx, DWORD PTR _rectfull$[esp+92]
  0014e	50		 push	 eax
  0014f	51		 push	 ecx
  00150	6a 06		 push	 6
  00152	55		 push	 ebp
  00153	53		 push	 ebx
  00154	56		 push	 esi
  00155	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExtTextOutA@32

; 1787 :  
; 1788 :     // empty rectangle
; 1789 :     SetTextColor(hdc,crColorBar);

  0015b	8b 54 24 64	 mov	 edx, DWORD PTR _crColorBar$[esp+80]
  0015f	52		 push	 edx
  00160	56		 push	 esi
  00161	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTextColor@8

; 1790 :     SetBkColor  (hdc,crColorText);

  00167	8b 44 24 68	 mov	 eax, DWORD PTR _crColorText$[esp+80]
  0016b	50		 push	 eax
  0016c	56		 push	 esi
  0016d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8

; 1791 :     ExtTextOut  (hdc,x,y,ETO_CLIPPED | ETO_OPAQUE,
; 1792 :             &rectempty,buffer,strlen(buffer),NULL);

  00173	8d 7c 24 40	 lea	 edi, DWORD PTR _buffer$[esp+84]
  00177	83 c9 ff	 or	 ecx, -1
  0017a	33 c0		 xor	 eax, eax
  0017c	6a 00		 push	 0
  0017e	f2 ae		 repne scasb
  00180	f7 d1		 not	 ecx
  00182	49		 dec	 ecx
  00183	8d 54 24 34	 lea	 edx, DWORD PTR _rectempty$[esp+88]
  00187	51		 push	 ecx
  00188	8d 4c 24 48	 lea	 ecx, DWORD PTR _buffer$[esp+92]
  0018c	51		 push	 ecx
  0018d	52		 push	 edx
  0018e	6a 06		 push	 6
  00190	55		 push	 ebp
  00191	53		 push	 ebx
  00192	56		 push	 esi
  00193	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExtTextOutA@32

; 1793 :  
; 1794 :     ReleaseDC(hwnd,hdc);

  00199	8b 44 24 58	 mov	 eax, DWORD PTR _hwnd$[esp+80]
  0019d	56		 push	 esi
  0019e	50		 push	 eax
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
  001a5	5b		 pop	 ebx
  001a6	5d		 pop	 ebp
  001a7	5f		 pop	 edi
$L49571:

; 1795 : }

  001a8	5e		 pop	 esi
  001a9	83 c4 44	 add	 esp, 68			; 00000044H
  001ac	c3		 ret	 0
?DrawBarEx@@YAXPAUHWND__@@H_NKK@Z ENDP			; DrawBarEx
_TEXT	ENDS
PUBLIC	?DisplayContextMenu@@YGXPAUHWND__@@UtagPOINT@@@Z ; DisplayContextMenu
EXTRN	__imp__LoadMenuA@8:NEAR
EXTRN	__imp__DestroyMenu@4:NEAR
EXTRN	__imp__GetSubMenu@8:NEAR
EXTRN	__imp__TrackPopupMenu@28:NEAR
;	COMDAT ?DisplayContextMenu@@YGXPAUHWND__@@UtagPOINT@@@Z
_TEXT	SEGMENT
_hwnd$ = 8
_pt$ = 12
?DisplayContextMenu@@YGXPAUHWND__@@UtagPOINT@@@Z PROC NEAR ; DisplayContextMenu, COMDAT

; 1807 :     HMENU hmenu;            // top-level menu 
; 1808 :     HMENU hmenuTrackPopup;  // shortcut menu 
; 1809 :  
; 1810 :     // Load the menu resource. 
; 1811 :      if ((hmenu = LoadMenu(g_hInst, MAKEINTRESOURCE(IDR_MENU1))) == NULL) 

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hInst@@3PAUHINSTANCE__@@A ; g_hInst
  00005	57		 push	 edi
  00006	6a 7c		 push	 124			; 0000007cH
  00008	50		 push	 eax
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadMenuA@8
  0000f	8b f8		 mov	 edi, eax
  00011	85 ff		 test	 edi, edi
  00013	74 35		 je	 SHORT $L49589
  00015	56		 push	 esi

; 1812 :         return; 
; 1813 :  
; 1814 :     // TrackPopupMenu cannot display the menu bar so get 
; 1815 :     // the handle of the first shortcut menu. 
; 1816 :     hmenuTrackPopup = GetSubMenu(hmenu, 0); 

  00016	6a 00		 push	 0
  00018	57		 push	 edi
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSubMenu@8

; 1817 :  
; 1818 :     // Display the shortcut menu. Track the right mouse 
; 1819 :     // button. 
; 1820 :     TrackPopupMenu(hmenuTrackPopup, 
; 1821 :             TPM_LEFTALIGN | TPM_RIGHTBUTTON, 
; 1822 :             pt.x, pt.y, 0, hwnd, NULL); 

  0001f	6a 00		 push	 0
  00021	8b f0		 mov	 esi, eax
  00023	8b 4c 24 10	 mov	 ecx, DWORD PTR _hwnd$[esp+8]
  00027	8b 54 24 18	 mov	 edx, DWORD PTR _pt$[esp+12]
  0002b	8b 44 24 14	 mov	 eax, DWORD PTR _pt$[esp+8]
  0002f	51		 push	 ecx
  00030	6a 00		 push	 0
  00032	52		 push	 edx
  00033	50		 push	 eax
  00034	6a 02		 push	 2
  00036	56		 push	 esi
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TrackPopupMenu@28

; 1823 :  
; 1824 :     // Destroy the menu. 
; 1825 :     DestroyMenu(hmenu);

  0003d	57		 push	 edi
  0003e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__DestroyMenu@4
  00044	ff d7		 call	 edi

; 1826 : 
; 1827 : 	// Destroy the menu. 
; 1828 :     DestroyMenu(hmenuTrackPopup); 

  00046	56		 push	 esi
  00047	ff d7		 call	 edi
  00049	5e		 pop	 esi
$L49589:

; 1829 : } 

  0004a	5f		 pop	 edi
  0004b	c2 0c 00	 ret	 12			; 0000000cH
?DisplayContextMenu@@YGXPAUHWND__@@UtagPOINT@@@Z ENDP	; DisplayContextMenu
_TEXT	ENDS
;	COMDAT ?DisplayContextMenu2@@YGXPAUHWND__@@UtagPOINT@@@Z
_TEXT	SEGMENT
_hwnd$ = 8
_pt$ = 12
?DisplayContextMenu2@@YGXPAUHWND__@@UtagPOINT@@@Z PROC NEAR ; DisplayContextMenu2, COMDAT

; 1840 :     HMENU hmenu;            // top-level menu 
; 1841 :     HMENU hmenuTrackPopup;  // shortcut menu
; 1842 : 
; 1843 : 	// ownerdraw menu item has probably f*cked up no-dismissal area: right-clicking
; 1844 : 	// just under menu will not dismiss it. Let's do that ourselves
; 1845 : 	// Don't work...
; 1846 : 	RECT rc;
; 1847 : 	rc.left   = 0;
; 1848 :     rc.top    = 0;
; 1849 :     rc.right  = 0;
; 1850 :     rc.bottom = 0;
; 1851 : 
; 1852 : 
; 1853 : 
; 1854 :  
; 1855 :     // Load the menu resource. 
; 1856 :      if ((hmenu = LoadMenu(g_hInst, MAKEINTRESOURCE(IDR_MENU2))) == NULL) 

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hInst@@3PAUHINSTANCE__@@A ; g_hInst
  00005	57		 push	 edi
  00006	6a 7e		 push	 126			; 0000007eH
  00008	50		 push	 eax
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadMenuA@8
  0000f	8b f8		 mov	 edi, eax
  00011	85 ff		 test	 edi, edi
  00013	74 57		 je	 SHORT $L49598
  00015	56		 push	 esi

; 1857 :         return; 
; 1858 :  
; 1859 :     // TrackPopupMenu cannot display the menu bar so get 
; 1860 :     // the handle of the first shortcut menu. 
; 1861 :     hmenuTrackPopup = GetSubMenu(hmenu, 0);

  00016	6a 00		 push	 0
  00018	57		 push	 edi
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSubMenu@8

; 1862 : 	g_hmenuTrackPopupTray = hmenuTrackPopup;
; 1863 : 
; 1864 : 	// add ownerdrawn item 
; 1865 : 	//InsertMenu(hmenuTrackPopup, 0, MF_BYPOSITION|MF_STRING, 0, "Rrr");
; 1866 : 	//InsertMenu(hmenuTrackPopup, 0, MF_BYPOSITION|MF_BITMAP, 0, NULL);
; 1867 : 	InsertMenu(hmenuTrackPopup, 0, MF_BYPOSITION|MF_DISABLED|MF_OWNERDRAW, 0, NULL);

  0001f	6a 00		 push	 0
  00021	6a 00		 push	 0
  00023	8b f0		 mov	 esi, eax
  00025	68 02 05 00 00	 push	 1282			; 00000502H
  0002a	6a 00		 push	 0
  0002c	56		 push	 esi
  0002d	89 35 00 00 00
	00		 mov	 DWORD PTR ?g_hmenuTrackPopupTray@@3PAUHMENU__@@A, esi ; g_hmenuTrackPopupTray
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InsertMenuA@20

; 1868 :  
; 1869 :     // Display the shortcut menu. Track the right mouse 
; 1870 :     // button. 
; 1871 :     TrackPopupMenu(hmenuTrackPopup, 
; 1872 :             TPM_LEFTALIGN | TPM_RIGHTBUTTON, 
; 1873 :             pt.x, pt.y, 0, hwnd, NULL);

  00039	6a 00		 push	 0
  0003b	8b 4c 24 10	 mov	 ecx, DWORD PTR _hwnd$[esp+8]
  0003f	8b 54 24 18	 mov	 edx, DWORD PTR _pt$[esp+12]
  00043	8b 44 24 14	 mov	 eax, DWORD PTR _pt$[esp+8]
  00047	51		 push	 ecx
  00048	6a 00		 push	 0
  0004a	52		 push	 edx
  0004b	50		 push	 eax
  0004c	6a 02		 push	 2
  0004e	56		 push	 esi
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TrackPopupMenu@28

; 1874 : 
; 1875 : 	g_hmenuTrackPopupTray = NULL;
; 1876 :  
; 1877 :     // Destroy the menu. 
; 1878 :     DestroyMenu(hmenu); 

  00055	57		 push	 edi
  00056	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__DestroyMenu@4
  0005c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_hmenuTrackPopupTray@@3PAUHMENU__@@A, 0 ; g_hmenuTrackPopupTray
  00066	ff d7		 call	 edi

; 1879 : 
; 1880 : 	// Destroy the menu. 
; 1881 :     DestroyMenu(hmenuTrackPopup); 

  00068	56		 push	 esi
  00069	ff d7		 call	 edi
  0006b	5e		 pop	 esi
$L49598:

; 1882 : }

  0006c	5f		 pop	 edi
  0006d	c2 0c 00	 ret	 12			; 0000000cH
?DisplayContextMenu2@@YGXPAUHWND__@@UtagPOINT@@@Z ENDP	; DisplayContextMenu2
_TEXT	ENDS
PUBLIC	??_C@_04PMPB@QQQ?$CB?$AA@			; `string'
PUBLIC	??_C@_04MBDE@qqq?$CB?$AA@			; `string'
PUBLIC	?KeyboardProc@@YGJHIJ@Z				; KeyboardProc
EXTRN	__imp__VkKeyScanA@4:NEAR
EXTRN	__imp__CallNextHookEx@16:NEAR
;	COMDAT ??_C@_04PMPB@QQQ?$CB?$AA@
; File E:\interface\TxintguiSDK\Bigpush\bigpush.cpp
_DATA	SEGMENT
??_C@_04PMPB@QQQ?$CB?$AA@ DB 'QQQ!', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04MBDE@qqq?$CB?$AA@
_DATA	SEGMENT
??_C@_04MBDE@qqq?$CB?$AA@ DB 'qqq!', 00H		; `string'
_DATA	ENDS
;	COMDAT ?KeyboardProc@@YGJHIJ@Z
_TEXT	SEGMENT
_code$ = 8
_wParam$ = 12
_lParam$ = 16
?KeyboardProc@@YGJHIJ@Z PROC NEAR			; KeyboardProc, COMDAT

; 1889 : 	if (code < 0)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _code$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7d 1a		 jge	 SHORT $L49610

; 1890 : 		return CallNextHookEx(hHook, code, wParam, lParam) ;

  00008	8b 4c 24 0c	 mov	 ecx, DWORD PTR _lParam$[esp-4]
  0000c	8b 54 24 08	 mov	 edx, DWORD PTR _wParam$[esp-4]
  00010	51		 push	 ecx
  00011	52		 push	 edx
  00012	50		 push	 eax
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hHook@@3PAUHHOOK__@@A ; hHook
  00018	50		 push	 eax
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallNextHookEx@16

; 1897 : 
; 1898 : }

  0001f	c2 0c 00	 ret	 12			; 0000000cH
$L49610:

; 1891 : 
; 1892 : 	if (wParam == (WPARAM)VkKeyScan('q')) {

  00022	6a 71		 push	 113			; 00000071H
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VkKeyScanA@4
  0002a	0f bf c8	 movsx	 ecx, ax
  0002d	39 4c 24 08	 cmp	 DWORD PTR _wParam$[esp-4], ecx
  00031	75 1e		 jne	 SHORT $L49613

; 1893 : 		if (!(lParam & 0x80000000))

  00033	f7 44 24 0c 00
	00 00 80	 test	 DWORD PTR _lParam$[esp-4], -2147483648 ; 80000000H
  0003b	75 14		 jne	 SHORT $L49613

; 1894 : 			MessageBox(NULL,"qqq!","QQQ!",MB_OK);

  0003d	6a 00		 push	 0
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04PMPB@QQQ?$CB?$AA@ ; `string'
  00044	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04MBDE@qqq?$CB?$AA@ ; `string'
  00049	6a 00		 push	 0
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
$L49613:

; 1895 : 	}
; 1896 : 	return 0;

  00051	33 c0		 xor	 eax, eax

; 1897 : 
; 1898 : }

  00053	c2 0c 00	 ret	 12			; 0000000cH
?KeyboardProc@@YGJHIJ@Z ENDP				; KeyboardProc
_TEXT	ENDS
PUBLIC	?MessageProc@@YGJHIJ@Z				; MessageProc
;	COMDAT ?MessageProc@@YGJHIJ@Z
_TEXT	SEGMENT
_code$ = 8
_wParam$ = 12
_lParam$ = 16
?MessageProc@@YGJHIJ@Z PROC NEAR			; MessageProc, COMDAT

; 1904 : 	if (code < 0)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _code$[esp-4]

; 1905 : 		return CallNextHookEx(hHook, code, wParam, lParam) ;

  00004	8b 4c 24 0c	 mov	 ecx, DWORD PTR _lParam$[esp-4]
  00008	85 c0		 test	 eax, eax
  0000a	7d 16		 jge	 SHORT $L49620
  0000c	8b 54 24 08	 mov	 edx, DWORD PTR _wParam$[esp-4]
  00010	51		 push	 ecx
  00011	52		 push	 edx
  00012	50		 push	 eax
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hHook@@3PAUHHOOK__@@A ; hHook
  00018	50		 push	 eax
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallNextHookEx@16

; 1916 : }

  0001f	c2 0c 00	 ret	 12			; 0000000cH
$L49620:

; 1906 : 
; 1907 : 	switch ( ((LPMSG)lParam)->message) 

  00022	81 79 04 00 01
	00 00		 cmp	 DWORD PTR [ecx+4], 256	; 00000100H
  00029	75 14		 jne	 SHORT $L49623

; 1908 : 	{
; 1909 : 		case WM_KEYDOWN:
; 1910 : 			//if (wParam == (WPARAM)VkKeyScan('q')) //???????
; 1911 : 				MessageBox(NULL,"qqq!","QQQ!",MB_OK);

  0002b	6a 00		 push	 0
  0002d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04PMPB@QQQ?$CB?$AA@ ; `string'
  00032	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04MBDE@qqq?$CB?$AA@ ; `string'
  00037	6a 00		 push	 0
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
$L49623:

; 1912 : 			break;
; 1913 : 
; 1914 : 	}
; 1915 : 	return 0;

  0003f	33 c0		 xor	 eax, eax

; 1916 : }

  00041	c2 0c 00	 ret	 12			; 0000000cH
?MessageProc@@YGJHIJ@Z ENDP				; MessageProc
_TEXT	ENDS
PUBLIC	??_C@_0BB@FNBH@tooltips_class32?$AA@		; `string'
PUBLIC	?DoCreateDialogTooltip@@YAHXZ			; DoCreateDialogTooltip
PUBLIC	?EnumChildProc@@YAHPAUHWND__@@J@Z		; EnumChildProc
PUBLIC	?GetMsgProc@@YGJHIJ@Z				; GetMsgProc
EXTRN	__imp__InitCommonControls@0:NEAR
EXTRN	__imp__EnumChildWindows@12:NEAR
EXTRN	__imp__SetWindowsHookExA@16:NEAR
EXTRN	__imp__GetCurrentThreadId@0:NEAR
EXTRN	__imp__CreateWindowExA@48:NEAR
;	COMDAT ??_C@_0BB@FNBH@tooltips_class32?$AA@
; File E:\interface\TxintguiSDK\Bigpush\bigpush.cpp
_DATA	SEGMENT
??_C@_0BB@FNBH@tooltips_class32?$AA@ DB 'tooltips_class32', 00H ; `string'
_DATA	ENDS
;	COMDAT ?DoCreateDialogTooltip@@YAHXZ
_TEXT	SEGMENT
?DoCreateDialogTooltip@@YAHXZ PROC NEAR			; DoCreateDialogTooltip, COMDAT

; 1926 :     // Ensure that the common control DLL is loaded, and create 
; 1927 :     // a ToolTip control.
; 1928 : 	InitCommonControls();

  00000	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitCommonControls@0

; 1929 : 	
; 1930 :     g_hwndTT = CreateWindowEx(0, TOOLTIPS_CLASS, (LPSTR) NULL, 
; 1931 :         TTS_ALWAYSTIP, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
; 1932 :         CW_USEDEFAULT, g_hwndDlg, (HMENU) NULL, g_hinst, NULL);

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hinst@@3PAUHINSTANCE__@@A ; g_hinst
  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hwndDlg@@3PAUHWND__@@A ; g_hwndDlg
  00011	6a 00		 push	 0
  00013	50		 push	 eax
  00014	6a 00		 push	 0
  00016	51		 push	 ecx
  00017	68 00 00 00 80	 push	 -2147483648		; 80000000H
  0001c	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00021	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00026	68 00 00 00 80	 push	 -2147483648		; 80000000H
  0002b	6a 01		 push	 1
  0002d	6a 00		 push	 0
  0002f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@FNBH@tooltips_class32?$AA@ ; `string'
  00034	6a 00		 push	 0
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateWindowExA@48

; 1933 : 	
; 1934 :     if (g_hwndTT == NULL)         

  0003c	85 c0		 test	 eax, eax
  0003e	a3 00 00 00 00	 mov	 DWORD PTR ?g_hwndTT@@3PAUHWND__@@A, eax ; g_hwndTT
  00043	75 01		 jne	 SHORT $L49636

; 1950 : 		return FALSE;
; 1951 : 	
; 1952 : 	return TRUE; 
; 1953 : }

  00045	c3		 ret	 0
$L49636:

; 1935 : 		return FALSE; 
; 1936 : 	
; 1937 :     // Enumerate the child windows to register them with the ToolTip
; 1938 :     // control. 
; 1939 :     if (!EnumChildWindows(g_hwndDlg, (WNDENUMPROC)EnumChildProc, 0)) 

  00046	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hwndDlg@@3PAUHWND__@@A ; g_hwndDlg
  0004c	6a 00		 push	 0
  0004e	68 00 00 00 00	 push	 OFFSET FLAT:?EnumChildProc@@YAHPAUHWND__@@J@Z ; EnumChildProc
  00053	52		 push	 edx
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnumChildWindows@12
  0005a	85 c0		 test	 eax, eax
  0005c	75 01		 jne	 SHORT $L49638

; 1950 : 		return FALSE;
; 1951 : 	
; 1952 : 	return TRUE; 
; 1953 : }

  0005e	c3		 ret	 0
$L49638:

; 1940 :         return FALSE;
; 1941 : 	
; 1942 :     // Install a hook procedure to monitor the message stream for mouse 
; 1943 :     // messages intended for the controls in the dialog box.
; 1944 : 	// NOTE NOTE NOTE: the hook MUST be unhooked before doing a new
; 1945 : 	// DoCreateDialogTooltip(void) or we'll CRASH
; 1946 :     g_hhk = SetWindowsHookEx(WH_GETMESSAGE, (HOOKPROC)GetMsgProc, 
; 1947 :         (HINSTANCE)NULL, GetCurrentThreadId()); 

  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0
  00065	50		 push	 eax
  00066	6a 00		 push	 0
  00068	68 00 00 00 00	 push	 OFFSET FLAT:?GetMsgProc@@YGJHIJ@Z ; GetMsgProc
  0006d	6a 03		 push	 3
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowsHookExA@16

; 1948 : 	
; 1949 :     if (g_hhk == (HHOOK) NULL)         

  00075	33 c9		 xor	 ecx, ecx
  00077	a3 00 00 00 00	 mov	 DWORD PTR ?g_hhk@@3PAUHHOOK__@@A, eax ; g_hhk
  0007c	85 c0		 test	 eax, eax
  0007e	0f 95 c1	 setne	 cl
  00081	8b c1		 mov	 eax, ecx

; 1950 : 		return FALSE;
; 1951 : 	
; 1952 : 	return TRUE; 
; 1953 : }

  00083	c3		 ret	 0
?DoCreateDialogTooltip@@YAHXZ ENDP			; DoCreateDialogTooltip
_TEXT	ENDS
PUBLIC	??_C@_06MJBA@STATIC?$AA@			; `string'
EXTRN	__imp__lstrcmpA@8:NEAR
EXTRN	__imp__GetClassNameA@12:NEAR
;	COMDAT ??_C@_06MJBA@STATIC?$AA@
; File E:\interface\TxintguiSDK\Bigpush\bigpush.cpp
_DATA	SEGMENT
??_C@_06MJBA@STATIC?$AA@ DB 'STATIC', 00H		; `string'
_DATA	ENDS
;	COMDAT ?EnumChildProc@@YAHPAUHWND__@@J@Z
_TEXT	SEGMENT
_hwndCtrl$ = 8
_ti$ = -108
_szClass$ = -64
?EnumChildProc@@YAHPAUHWND__@@J@Z PROC NEAR		; EnumChildProc, COMDAT

; 1966 : {     

  00000	83 ec 6c	 sub	 esp, 108		; 0000006cH

; 1967 : 	TOOLINFO ti; 
; 1968 :     char szClass[64];      
; 1969 : 	
; 1970 : 	// Skip static controls. 
; 1971 :     GetClassName(hwndCtrl, szClass, sizeof(szClass));

  00003	8d 44 24 2c	 lea	 eax, DWORD PTR _szClass$[esp+108]
  00007	56		 push	 esi
  00008	8b 74 24 74	 mov	 esi, DWORD PTR _hwndCtrl$[esp+108]
  0000c	6a 40		 push	 64			; 00000040H
  0000e	50		 push	 eax
  0000f	56		 push	 esi
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClassNameA@12

; 1972 : 	
; 1973 :     if (lstrcmp(szClass, "STATIC")) {

  00016	8d 4c 24 30	 lea	 ecx, DWORD PTR _szClass$[esp+112]
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06MJBA@STATIC?$AA@ ; `string'
  0001f	51		 push	 ecx
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpA@8
  00026	85 c0		 test	 eax, eax
  00028	74 47		 je	 SHORT $L49648

; 1974 : 
; 1975 : 		ti.cbSize = sizeof(TOOLINFO); 
; 1976 :         ti.uFlags = TTF_IDISHWND;
; 1977 : 		ti.hwnd = g_hwndDlg; 
; 1978 :         ti.uId = (UINT) hwndCtrl;
; 1979 : 		ti.hinst = 0; 
; 1980 :         ti.lpszText = LPSTR_TEXTCALLBACK;
; 1981 : 		
; 1982 :         SendMessage(g_hwndTT, TTM_ADDTOOL, 0, 
; 1983 :             (LPARAM) (LPTOOLINFO) &ti);     

  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hwndTT@@3PAUHWND__@@A ; g_hwndTT
  00030	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hwndDlg@@3PAUHWND__@@A ; g_hwndDlg
  00036	8d 44 24 04	 lea	 eax, DWORD PTR _ti$[esp+112]
  0003a	c7 44 24 04 2c
	00 00 00	 mov	 DWORD PTR _ti$[esp+112], 44 ; 0000002cH
  00042	50		 push	 eax
  00043	6a 00		 push	 0
  00045	68 04 04 00 00	 push	 1028			; 00000404H
  0004a	51		 push	 ecx
  0004b	c7 44 24 18 01
	00 00 00	 mov	 DWORD PTR _ti$[esp+132], 1
  00053	89 54 24 1c	 mov	 DWORD PTR _ti$[esp+136], edx
  00057	89 74 24 20	 mov	 DWORD PTR _ti$[esp+140], esi
  0005b	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR _ti$[esp+160], 0
  00063	c7 44 24 38 ff
	ff ff ff	 mov	 DWORD PTR _ti$[esp+164], -1
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
$L49648:

; 1984 : 	}
; 1985 : 	
; 1986 : 	return TRUE; 

  00071	b8 01 00 00 00	 mov	 eax, 1

; 1987 : }

  00076	5e		 pop	 esi
  00077	83 c4 6c	 add	 esp, 108		; 0000006cH
  0007a	c3		 ret	 0
?EnumChildProc@@YAHPAUHWND__@@J@Z ENDP			; EnumChildProc
_TEXT	ENDS
EXTRN	__imp__IsChild@8:NEAR
;	COMDAT ?GetMsgProc@@YGJHIJ@Z
_TEXT	SEGMENT
_nCode$ = 8
_wParam$ = 12
_lParam$ = 16
_msg$49669 = -28
?GetMsgProc@@YGJHIJ@Z PROC NEAR				; GetMsgProc, COMDAT

; 2003 : { 

  00000	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00003	56		 push	 esi

; 2004 :     MSG *lpmsg;
; 2005 : 	lpmsg = (MSG *) lParam;
; 2006 : 	
; 2007 :     if (nCode < 0 || !(IsChild(g_hwndDlg, lpmsg->hwnd))) 

  00004	8b 74 24 2c	 mov	 esi, DWORD PTR _lParam$[esp+28]
  00008	57		 push	 edi
  00009	8b 7c 24 28	 mov	 edi, DWORD PTR _nCode$[esp+32]
  0000d	85 ff		 test	 edi, edi
  0000f	7c 7a		 jl	 SHORT $L49662
  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hwndDlg@@3PAUHWND__@@A ; g_hwndDlg
  00019	50		 push	 eax
  0001a	51		 push	 ecx
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsChild@8
  00021	85 c0		 test	 eax, eax
  00023	74 66		 je	 SHORT $L49662

; 2009 : 	
; 2010 :     switch (lpmsg->message) {

  00025	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00028	8d 88 00 fe ff
	ff		 lea	 ecx, DWORD PTR [eax-512]
  0002e	83 f9 05	 cmp	 ecx, 5
  00031	77 3c		 ja	 SHORT $L49668
  00033	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L50087[ecx*4]
$L49667:

; 2011 : 		case WM_MOUSEMOVE: 
; 2012 :         case WM_LBUTTONDOWN:
; 2013 : 		case WM_LBUTTONUP: 
; 2014 :         case WM_RBUTTONDOWN:
; 2015 : 		case WM_RBUTTONUP: 
; 2016 :             if (g_hwndTT != NULL) {

  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hwndTT@@3PAUHWND__@@A ; g_hwndTT
  00040	85 c9		 test	 ecx, ecx
  00042	74 2b		 je	 SHORT $L49668

; 2017 : 				MSG msg;  
; 2018 :                 msg.lParam  = lpmsg->lParam; 

  00044	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]

; 2019 :                 msg.wParam  = lpmsg->wParam; 
; 2020 :                 msg.message = lpmsg->message;

  00047	89 44 24 0c	 mov	 DWORD PTR _msg$49669[esp+40], eax
  0004b	89 54 24 14	 mov	 DWORD PTR _msg$49669[esp+48], edx
  0004f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 2021 : 				msg.hwnd    = lpmsg->hwnd; 

  00052	8b 06		 mov	 eax, DWORD PTR [esi]
  00054	89 54 24 10	 mov	 DWORD PTR _msg$49669[esp+44], edx

; 2022 :                 SendMessage(g_hwndTT, TTM_RELAYEVENT, 0, 
; 2023 :                     (LPARAM) (LPMSG) &msg);

  00058	8d 54 24 08	 lea	 edx, DWORD PTR _msg$49669[esp+36]
  0005c	89 44 24 08	 mov	 DWORD PTR _msg$49669[esp+36], eax
  00060	52		 push	 edx
  00061	6a 00		 push	 0
  00063	68 07 04 00 00	 push	 1031			; 00000407H
  00068	51		 push	 ecx
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
$L49668:

; 2024 : 			}
; 2025 : 			break; 
; 2026 :         default:
; 2027 : 			break;
; 2028 : 	} 
; 2029 :     return (CallNextHookEx(g_hhk, nCode, wParam, lParam));

  0006f	8b 44 24 2c	 mov	 eax, DWORD PTR _wParam$[esp+32]
  00073	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hhk@@3PAUHHOOK__@@A ; g_hhk
  00079	56		 push	 esi
  0007a	50		 push	 eax
  0007b	57		 push	 edi
  0007c	51		 push	 ecx
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallNextHookEx@16

; 2030 : }

  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	83 c4 1c	 add	 esp, 28			; 0000001cH
  00088	c2 0c 00	 ret	 12			; 0000000cH
$L49662:

; 2008 :         return (CallNextHookEx(g_hhk, nCode, wParam, lParam));

  0008b	8b 54 24 2c	 mov	 edx, DWORD PTR _wParam$[esp+32]
  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hhk@@3PAUHHOOK__@@A ; g_hhk
  00094	56		 push	 esi
  00095	52		 push	 edx
  00096	57		 push	 edi
  00097	50		 push	 eax
  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallNextHookEx@16

; 2030 : }

  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	83 c4 1c	 add	 esp, 28			; 0000001cH
  000a3	c2 0c 00	 ret	 12			; 0000000cH
  000a6	8b ff		 npad	 2
$L50087:
  000a8	00 00 00 00	 DD	 $L49667
  000ac	00 00 00 00	 DD	 $L49667
  000b0	00 00 00 00	 DD	 $L49667
  000b4	00 00 00 00	 DD	 $L49668
  000b8	00 00 00 00	 DD	 $L49667
  000bc	00 00 00 00	 DD	 $L49667
?GetMsgProc@@YGJHIJ@Z ENDP				; GetMsgProc
_TEXT	ENDS
PUBLIC	??_C@_0BB@DKKO@Show?1Hide?5Values?$AA@		; `string'
PUBLIC	??_C@_0P@PPNG@Center?5Sliders?$AA@		; `string'
PUBLIC	??_C@_09HOKM@Set?5Color?$AA@			; `string'
PUBLIC	?OnWMNotify@@YAXJ@Z				; OnWMNotify
EXTRN	__imp__GetDlgCtrlID@4:NEAR
;	COMDAT ??_C@_0BB@DKKO@Show?1Hide?5Values?$AA@
; File E:\interface\TxintguiSDK\Bigpush\bigpush.cpp
_DATA	SEGMENT
??_C@_0BB@DKKO@Show?1Hide?5Values?$AA@ DB 'Show/Hide Values', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@PPNG@Center?5Sliders?$AA@
_DATA	SEGMENT
??_C@_0P@PPNG@Center?5Sliders?$AA@ DB 'Center Sliders', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_09HOKM@Set?5Color?$AA@
_DATA	SEGMENT
??_C@_09HOKM@Set?5Color?$AA@ DB 'Set Color', 00H	; `string'
_DATA	ENDS
;	COMDAT ?OnWMNotify@@YAXJ@Z
_TEXT	SEGMENT
_lParam$ = 8
?OnWMNotify@@YAXJ@Z PROC NEAR				; OnWMNotify, COMDAT

; 2043 : 	LPTOOLTIPTEXT lpttt;
; 2044 : 	int idCtrl;
; 2045 : 
; 2046 : 	// big tool..erm..tits
; 2047 : 	//POINT pt;
; 2048 : 	//GetCursorPos(&pt);
; 2049 : 	//MoveWindow(g_hwndTT, pt.x, pt.y+GetSystemMetrics(SM_CYSMICON)+2, 500, 200, true);
; 2050 : 	
; 2051 : 	// multi-line tooltips: use TTM_SETMAXTIPWIDTH and \r\n or \n
; 2052 : 	SendMessage(g_hwndTT, TTM_SETMAXTIPWIDTH, 0, 300);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hwndTT@@3PAUHWND__@@A ; g_hwndTT
  00005	56		 push	 esi
  00006	68 2c 01 00 00	 push	 300			; 0000012cH
  0000b	6a 00		 push	 0
  0000d	68 18 04 00 00	 push	 1048			; 00000418H
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 2053 : 	//SendMessage(g_hwndTT, TTM_SETTIPBKCOLOR, RGB(255,0,0), 0);
; 2054 : 	//SendMessage(g_hwndTT, TTM_SETTIPTEXTCOLOR, RGB(255,255,255), 0);
; 2055 : 	
; 2056 : 	
; 2057 : 
; 2058 :     if ((((LPNMHDR) lParam)->code) == TTN_NEEDTEXT) { 

  00019	8b 74 24 08	 mov	 esi, DWORD PTR _lParam$[esp]
  0001d	81 7e 08 f8 fd
	ff ff		 cmp	 DWORD PTR [esi+8], -520	; fffffdf8H
  00024	75 34		 jne	 SHORT $L49683

; 2059 :         idCtrl = GetDlgCtrlID((HWND) ((LPNMHDR) lParam)->idFrom); 

  00026	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00029	51		 push	 ecx
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgCtrlID@4

; 2060 :         lpttt = (LPTOOLTIPTEXT) lParam;
; 2061 : 		
; 2062 : 		switch (idCtrl)

  00030	2d 89 04 00 00	 sub	 eax, 1161		; 00000489H
  00035	74 1c		 je	 SHORT $L49690
  00037	83 e8 02	 sub	 eax, 2
  0003a	74 0e		 je	 SHORT $L49688
  0003c	83 e8 28	 sub	 eax, 40			; 00000028H
  0003f	75 19		 jne	 SHORT $L49683

; 2063 : 		{/* 
; 2064 :             case ID_HORZSCROLL: 
; 2065 :                 lpttt->lpszText = "A horizontal scroll bar."; 
; 2066 :                 return;
; 2067 : 			case ID_CHECK: 
; 2068 :                 lpttt->lpszText = "A check box.";
; 2069 : 				return;  
; 2070 :             case ID_EDIT:
; 2071 : 				lpttt->lpszText = "An edit control."; 
; 2072 :                 return;*/
; 2073 : 		case IDC_CHECKPERCENT:
; 2074 : 				lpttt->lpszText = "Show/Hide Values"; 

  00041	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], OFFSET FLAT:??_C@_0BB@DKKO@Show?1Hide?5Values?$AA@ ; `string'

; 2081 :                 return;
; 2082 : 		/*case IDC_PROGRESSVERT1:
; 2083 : 		case IDC_PROGRESSVERT2:
; 2084 : 		case IDC_PROGRESSVERT3:
; 2085 : 		case IDC_PROGRESSVERT4:
; 2086 : 		case IDC_PROGRESSVERT5:
; 2087 : 		case IDC_PROGRESSVERT6:
; 2088 : 		case IDC_PROGRESSVERT7:
; 2089 : 		case IDC_PROGRESSVERT8:
; 2090 : 		case IDC_PROGRESSVERT9:
; 2091 : 		case IDC_PROGRESSVERT10:
; 2092 : 				lpttt->lpszText = "Set Individual Color: rigth-click or double-click"; 
; 2093 :                 return;*/
; 2094 : 
; 2095 : 		// should be done in separate tooltip procedure for the main dialog window
; 2096 : 		/*case IDC_CALIBRATE:
; 2097 : 				lpttt->lpszText = "Calibrate the transmitter: press Calibrate, \n"
; 2098 : 								  "move all the sticks through their extreme positions, \n" 
; 2099 : 								  "press Done when ready"; 
; 2100 :                 return;*/
; 2101 :         }
; 2102 :     }
; 2103 : 	return;
; 2104 : }

  00048	5e		 pop	 esi
  00049	c3		 ret	 0
$L49688:

; 2075 :                 return;
; 2076 : 		case IDC_BUTTONCENTER:
; 2077 : 				lpttt->lpszText = "Center Sliders"; 

  0004a	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], OFFSET FLAT:??_C@_0P@PPNG@Center?5Sliders?$AA@ ; `string'

; 2081 :                 return;
; 2082 : 		/*case IDC_PROGRESSVERT1:
; 2083 : 		case IDC_PROGRESSVERT2:
; 2084 : 		case IDC_PROGRESSVERT3:
; 2085 : 		case IDC_PROGRESSVERT4:
; 2086 : 		case IDC_PROGRESSVERT5:
; 2087 : 		case IDC_PROGRESSVERT6:
; 2088 : 		case IDC_PROGRESSVERT7:
; 2089 : 		case IDC_PROGRESSVERT8:
; 2090 : 		case IDC_PROGRESSVERT9:
; 2091 : 		case IDC_PROGRESSVERT10:
; 2092 : 				lpttt->lpszText = "Set Individual Color: rigth-click or double-click"; 
; 2093 :                 return;*/
; 2094 : 
; 2095 : 		// should be done in separate tooltip procedure for the main dialog window
; 2096 : 		/*case IDC_CALIBRATE:
; 2097 : 				lpttt->lpszText = "Calibrate the transmitter: press Calibrate, \n"
; 2098 : 								  "move all the sticks through their extreme positions, \n" 
; 2099 : 								  "press Done when ready"; 
; 2100 :                 return;*/
; 2101 :         }
; 2102 :     }
; 2103 : 	return;
; 2104 : }

  00051	5e		 pop	 esi
  00052	c3		 ret	 0
$L49690:

; 2078 :                 return;
; 2079 : 		case IDC_BUTTONCOLOR:
; 2080 : 				lpttt->lpszText = "Set Color"; 

  00053	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], OFFSET FLAT:??_C@_09HOKM@Set?5Color?$AA@ ; `string'
$L49683:

; 2081 :                 return;
; 2082 : 		/*case IDC_PROGRESSVERT1:
; 2083 : 		case IDC_PROGRESSVERT2:
; 2084 : 		case IDC_PROGRESSVERT3:
; 2085 : 		case IDC_PROGRESSVERT4:
; 2086 : 		case IDC_PROGRESSVERT5:
; 2087 : 		case IDC_PROGRESSVERT6:
; 2088 : 		case IDC_PROGRESSVERT7:
; 2089 : 		case IDC_PROGRESSVERT8:
; 2090 : 		case IDC_PROGRESSVERT9:
; 2091 : 		case IDC_PROGRESSVERT10:
; 2092 : 				lpttt->lpszText = "Set Individual Color: rigth-click or double-click"; 
; 2093 :                 return;*/
; 2094 : 
; 2095 : 		// should be done in separate tooltip procedure for the main dialog window
; 2096 : 		/*case IDC_CALIBRATE:
; 2097 : 				lpttt->lpszText = "Calibrate the transmitter: press Calibrate, \n"
; 2098 : 								  "move all the sticks through their extreme positions, \n" 
; 2099 : 								  "press Done when ready"; 
; 2100 :                 return;*/
; 2101 :         }
; 2102 :     }
; 2103 : 	return;
; 2104 : }

  0005a	5e		 pop	 esi
  0005b	c3		 ret	 0
?OnWMNotify@@YAXJ@Z ENDP				; OnWMNotify
_TEXT	ENDS
PUBLIC	??_C@_0CI@DLAF@Could?5not?5get?5Sys?5Dir?0?5Error?5cod@ ; `string'
PUBLIC	??_C@_03IGFH@QQQ?$AA@				; `string'
PUBLIC	??_C@_04CHPO@?2?2?4?2?$AA@			; `string'
PUBLIC	??_C@_01PCFE@?2?$AA@				; `string'
PUBLIC	??_C@_0EF@OCJG@VxD?5loaded?5but?5device?5does?5not?5s@ ; `string'
PUBLIC	??_C@_0EH@JCD@Could?5not?5find?5VxD?5or?5it?5is?5not?5@ ; `string'
EXTRN	__imp__CreateFileA@28:NEAR
EXTRN	__imp__GetSystemDirectoryA@8:NEAR
;	COMDAT ??_C@_0CI@DLAF@Could?5not?5get?5Sys?5Dir?0?5Error?5cod@
; File E:\interface\TxintguiSDK\Bigpush\bigpush.cpp
_DATA	SEGMENT
??_C@_0CI@DLAF@Could?5not?5get?5Sys?5Dir?0?5Error?5cod@ DB 'Could not get'
	DB	' Sys Dir, Error code: %ld', 0aH, 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_03IGFH@QQQ?$AA@
_DATA	SEGMENT
??_C@_03IGFH@QQQ?$AA@ DB 'QQQ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CHPO@?2?2?4?2?$AA@
_DATA	SEGMENT
??_C@_04CHPO@?2?2?4?2?$AA@ DB '\\.\', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_01PCFE@?2?$AA@
_DATA	SEGMENT
??_C@_01PCFE@?2?$AA@ DB '\', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EF@OCJG@VxD?5loaded?5but?5device?5does?5not?5s@
_DATA	SEGMENT
??_C@_0EF@OCJG@VxD?5loaded?5but?5device?5does?5not?5s@ DB 'VxD loaded but'
	DB	' device does not support DeviceIOCTL, Error code: %ld', 0aH, 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EH@JCD@Could?5not?5find?5VxD?5or?5it?5is?5not?5@
_DATA	SEGMENT
??_C@_0EH@JCD@Could?5not?5find?5VxD?5or?5it?5is?5not?5@ DB 'Could not fin'
	DB	'd VxD or it is not dynamically loadable, Error code: %ld', 0aH
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT ?LoadVxD@@YAXXZ
_TEXT	SEGMENT
_msg$ = -512
?LoadVxD@@YAXXZ PROC NEAR				; LoadVxD, COMDAT

; 2114 : {

  00000	81 ec 00 02 00
	00		 sub	 esp, 512		; 00000200H
  00006	53		 push	 ebx
  00007	55		 push	 ebp
  00008	56		 push	 esi
  00009	57		 push	 edi

; 2115 : 	char msg[512];
; 2116 : 
; 2117 : 	if ( !GetSystemDirectory(lpBuffer, MAX_PATH) ) {

  0000a	68 04 01 00 00	 push	 260			; 00000104H
  0000f	68 00 00 00 00	 push	 OFFSET FLAT:?lpBuffer@@3PADA ; lpBuffer
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemDirectoryA@8
  0001a	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__GetLastError@0
  00020	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__MessageBoxA@16
  00026	85 c0		 test	 eax, eax
  00028	75 2f		 jne	 SHORT $L49694

; 2118 : 		dwErrorCode = GetLastError();

  0002a	ff d5		 call	 ebp
  0002c	a3 00 00 00 00	 mov	 DWORD PTR ?dwErrorCode@@3KA, eax ; dwErrorCode

; 2119 : 		sprintf(msg, "Could not get Sys Dir, Error code: %ld\n", dwErrorCode);

  00031	50		 push	 eax
  00032	8d 44 24 14	 lea	 eax, DWORD PTR _msg$[esp+532]
  00036	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CI@DLAF@Could?5not?5get?5Sys?5Dir?0?5Error?5cod@ ; `string'
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 _sprintf
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2120 : 		MessageBox(NULL,msg,"QQQ",MB_ICONWARNING);

  00044	8d 4c 24 10	 lea	 ecx, DWORD PTR _msg$[esp+528]
  00048	6a 30		 push	 48			; 00000030H
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03IGFH@QQQ?$AA@ ; `string'
  0004f	51		 push	 ecx
  00050	6a 00		 push	 0
  00052	ff d3		 call	 ebx

; 2121 : 	} else {

  00054	e9 a7 00 00 00	 jmp	 $L49697
$L49694:

; 2122 : 		strcpy(strVxDFilePath, "\\\\.\\");

  00059	83 c9 ff	 or	 ecx, -1
  0005c	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:??_C@_04CHPO@?2?2?4?2?$AA@ ; `string'
  00061	33 c0		 xor	 eax, eax
  00063	f2 ae		 repne scasb
  00065	f7 d1		 not	 ecx
  00067	2b f9		 sub	 edi, ecx
  00069	8b d1		 mov	 edx, ecx
  0006b	8b f7		 mov	 esi, edi
  0006d	c1 e9 02	 shr	 ecx, 2
  00070	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:?strVxDFilePath@@3PADA ; strVxDFilePath
  00075	f3 a5		 rep movsd
  00077	8b ca		 mov	 ecx, edx
  00079	83 e1 03	 and	 ecx, 3
  0007c	f3 a4		 rep movsb

; 2123 : 		strcat(strVxDFilePath, lpBuffer);

  0007e	83 c9 ff	 or	 ecx, -1
  00081	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:?lpBuffer@@3PADA ; lpBuffer
  00086	f2 ae		 repne scasb
  00088	f7 d1		 not	 ecx
  0008a	2b f9		 sub	 edi, ecx
  0008c	8b d1		 mov	 edx, ecx
  0008e	8b f7		 mov	 esi, edi
  00090	83 c9 ff	 or	 ecx, -1
  00093	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:?strVxDFilePath@@3PADA ; strVxDFilePath
  00098	f2 ae		 repne scasb
  0009a	8b ca		 mov	 ecx, edx
  0009c	4f		 dec	 edi
  0009d	c1 e9 02	 shr	 ecx, 2
  000a0	f3 a5		 rep movsd
  000a2	8b ca		 mov	 ecx, edx
  000a4	83 e1 03	 and	 ecx, 3
  000a7	f3 a4		 rep movsb

; 2124 : 		strcat(strVxDFilePath, "\\");

  000a9	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:??_C@_01PCFE@?2?$AA@ ; `string'
  000ae	83 c9 ff	 or	 ecx, -1
  000b1	f2 ae		 repne scasb
  000b3	f7 d1		 not	 ecx
  000b5	2b f9		 sub	 edi, ecx
  000b7	8b f7		 mov	 esi, edi
  000b9	8b d1		 mov	 edx, ecx
  000bb	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:?strVxDFilePath@@3PADA ; strVxDFilePath
  000c0	83 c9 ff	 or	 ecx, -1
  000c3	f2 ae		 repne scasb
  000c5	8b ca		 mov	 ecx, edx
  000c7	4f		 dec	 edi
  000c8	c1 e9 02	 shr	 ecx, 2
  000cb	f3 a5		 rep movsd
  000cd	8b ca		 mov	 ecx, edx
  000cf	83 e1 03	 and	 ecx, 3
  000d2	f3 a4		 rep movsb

; 2125 : 		strcat(strVxDFilePath, strVxDFileName);         

  000d4	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?strVxDFileName@@3PADA ; strVxDFileName
  000da	83 c9 ff	 or	 ecx, -1
  000dd	f2 ae		 repne scasb
  000df	f7 d1		 not	 ecx
  000e1	2b f9		 sub	 edi, ecx
  000e3	8b f7		 mov	 esi, edi
  000e5	8b d1		 mov	 edx, ecx
  000e7	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:?strVxDFilePath@@3PADA ; strVxDFilePath
  000ec	83 c9 ff	 or	 ecx, -1
  000ef	f2 ae		 repne scasb
  000f1	8b ca		 mov	 ecx, edx
  000f3	4f		 dec	 edi
  000f4	c1 e9 02	 shr	 ecx, 2
  000f7	f3 a5		 rep movsd
  000f9	8b ca		 mov	 ecx, edx
  000fb	83 e1 03	 and	 ecx, 3
  000fe	f3 a4		 rep movsb
$L49697:

; 2126 : 	}   
; 2127 : 
; 2128 : 	// Dynamically load and prepare to call VMYXD
; 2129 : 	// The CREATE_NEW flag is not necessary
; 2130 : 	// Note: if we have added version info into the vxd with adrc2vxd we will only see
; 2131 : 	// that info in System Information if we load the vxd from the Windows\System dir
; 2132 : 	//hVxD = CreateFile("\\\\.\\C:\\Windows\\System\\Vmyxd.vxd", 0,0,0,
; 2133 : 	//                    CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
; 2134 : 	
; 2135 : 	hVxD = CreateFile(strVxDFilePath, 0, 0, NULL, 0, FILE_FLAG_DELETE_ON_CLOSE, NULL);

  00100	6a 00		 push	 0
  00102	68 00 00 00 04	 push	 67108864		; 04000000H
  00107	6a 00		 push	 0
  00109	6a 00		 push	 0
  0010b	6a 00		 push	 0
  0010d	6a 00		 push	 0
  0010f	68 00 00 00 00	 push	 OFFSET FLAT:?strVxDFilePath@@3PADA ; strVxDFilePath
  00114	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28

; 2136 : 
; 2137 : 	
; 2138 : 	// Note: this is only possible if the vxd is registered in the Registry
; 2139 : 	//hVxD = CreateFile("\\\\.\\VMYXD", 0,0,0,
; 2140 : 	//                    CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
; 2141 : 
; 2142 : 	if ( hVxD == INVALID_HANDLE_VALUE )

  0011a	83 f8 ff	 cmp	 eax, -1
  0011d	a3 00 00 00 00	 mov	 DWORD PTR ?hVxD@@3PAXA, eax ; hVxD
  00122	75 4c		 jne	 SHORT $L49704

; 2143 : 	{
; 2144 : 		
; 2145 : 		dwErrorCode = GetLastError();

  00124	ff d5		 call	 ebp

; 2146 : 		if ( dwErrorCode == ERROR_NOT_SUPPORTED )

  00126	83 f8 32	 cmp	 eax, 50			; 00000032H
  00129	a3 00 00 00 00	 mov	 DWORD PTR ?dwErrorCode@@3KA, eax ; dwErrorCode
  0012e	75 28		 jne	 SHORT $L49702

; 2147 : 		{
; 2148 : 			sprintf(msg, "VxD loaded but device does not support DeviceIOCTL, Error code: %ld\n", dwErrorCode);

  00130	50		 push	 eax
  00131	8d 44 24 14	 lea	 eax, DWORD PTR _msg$[esp+532]
  00135	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EF@OCJG@VxD?5loaded?5but?5device?5does?5not?5s@ ; `string'
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 _sprintf
  00140	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2149 : 			MessageBox(NULL,msg,"QQQ",MB_ICONWARNING);

  00143	8d 4c 24 10	 lea	 ecx, DWORD PTR _msg$[esp+528]
  00147	6a 30		 push	 48			; 00000030H
  00149	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03IGFH@QQQ?$AA@ ; `string'
  0014e	51		 push	 ecx
  0014f	6a 00		 push	 0
  00151	ff d3		 call	 ebx
  00153	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dwErrorCode@@3KA ; dwErrorCode
$L49702:

; 2150 : 
; 2151 : 			//printf("\nHit any key to quit\n");
; 2152 : 			//while ( !_kbhit() );
; 2153 : 		}
; 2154 : 		if ( dwErrorCode == ERROR_FILE_NOT_FOUND )

  00158	83 f8 02	 cmp	 eax, 2
  0015b	75 13		 jne	 SHORT $L49704

; 2155 : 		{
; 2156 : 			sprintf(msg, "Could not find VxD or it is not dynamically loadable, Error code: %ld\n", dwErrorCode);

  0015d	50		 push	 eax
  0015e	8d 54 24 14	 lea	 edx, DWORD PTR _msg$[esp+532]
  00162	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EH@JCD@Could?5not?5find?5VxD?5or?5it?5is?5not?5@ ; `string'
  00167	52		 push	 edx
  00168	e8 00 00 00 00	 call	 _sprintf
  0016d	83 c4 0c	 add	 esp, 12			; 0000000cH
$L49704:

; 2157 : 			//MessageBox(NULL,msg,"QQQ",MB_ICONWARNING);
; 2158 : 
; 2159 : 			//printf("\nHit any key to quit\n");
; 2160 : 			//while ( !_kbhit() );
; 2161 : 		}
; 2162 : 	}
; 2163 : }

  00170	5f		 pop	 edi
  00171	5e		 pop	 esi
  00172	5d		 pop	 ebp
  00173	5b		 pop	 ebx
  00174	81 c4 00 02 00
	00		 add	 esp, 512		; 00000200H
  0017a	c3		 ret	 0
?LoadVxD@@YAXXZ ENDP					; LoadVxD
_TEXT	ENDS
PUBLIC	??_C@_0CG@CLKC@Software?2Blacksphere?2R?1C?5Sim?5Sik@ ; `string'
PUBLIC	??_C@_0M@OOAA@g_bChInv?$FL1?$FN?$AA@		; `string'
PUBLIC	??_C@_0M@NFPP@g_bChInv?$FL2?$FN?$AA@		; `string'
PUBLIC	??_C@_0M@MDFF@g_bChInv?$FL3?$FN?$AA@		; `string'
PUBLIC	??_C@_0M@KCAA@g_bChInv?$FL4?$FN?$AA@		; `string'
PUBLIC	??_C@_0M@LEKK@g_bChInv?$FL5?$FN?$AA@		; `string'
PUBLIC	?RegistryRead@@YAXXZ				; RegistryRead
PUBLIC	??_C@_0M@IPFF@g_bChInv?$FL6?$FN?$AA@		; `string'
PUBLIC	??_C@_0M@JJPP@g_bChInv?$FL7?$FN?$AA@		; `string'
PUBLIC	??_C@_0M@ENPO@g_bChInv?$FL8?$FN?$AA@		; `string'
PUBLIC	??_C@_0M@FLFE@g_bChInv?$FL9?$FN?$AA@		; `string'
PUBLIC	??_C@_0N@COIO@g_bChInv?$FL10?$FN?$AA@		; `string'
EXTRN	__imp__RegCloseKey@4:NEAR
EXTRN	__imp__RegOpenKeyExA@20:NEAR
EXTRN	__imp__RegQueryValueExA@24:NEAR
;	COMDAT ??_C@_0CG@CLKC@Software?2Blacksphere?2R?1C?5Sim?5Sik@
; File E:\interface\TxintguiSDK\Bigpush\bigpush.cpp
_DATA	SEGMENT
??_C@_0CG@CLKC@Software?2Blacksphere?2R?1C?5Sim?5Sik@ DB 'Software\Blacks'
	DB	'phere\R/C Sim Sikorsky', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@OOAA@g_bChInv?$FL1?$FN?$AA@
_DATA	SEGMENT
??_C@_0M@OOAA@g_bChInv?$FL1?$FN?$AA@ DB 'g_bChInv[1]', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@NFPP@g_bChInv?$FL2?$FN?$AA@
_DATA	SEGMENT
??_C@_0M@NFPP@g_bChInv?$FL2?$FN?$AA@ DB 'g_bChInv[2]', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@MDFF@g_bChInv?$FL3?$FN?$AA@
_DATA	SEGMENT
??_C@_0M@MDFF@g_bChInv?$FL3?$FN?$AA@ DB 'g_bChInv[3]', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@KCAA@g_bChInv?$FL4?$FN?$AA@
_DATA	SEGMENT
??_C@_0M@KCAA@g_bChInv?$FL4?$FN?$AA@ DB 'g_bChInv[4]', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@LEKK@g_bChInv?$FL5?$FN?$AA@
_DATA	SEGMENT
??_C@_0M@LEKK@g_bChInv?$FL5?$FN?$AA@ DB 'g_bChInv[5]', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@IPFF@g_bChInv?$FL6?$FN?$AA@
_DATA	SEGMENT
??_C@_0M@IPFF@g_bChInv?$FL6?$FN?$AA@ DB 'g_bChInv[6]', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@JJPP@g_bChInv?$FL7?$FN?$AA@
_DATA	SEGMENT
??_C@_0M@JJPP@g_bChInv?$FL7?$FN?$AA@ DB 'g_bChInv[7]', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@ENPO@g_bChInv?$FL8?$FN?$AA@
_DATA	SEGMENT
??_C@_0M@ENPO@g_bChInv?$FL8?$FN?$AA@ DB 'g_bChInv[8]', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@FLFE@g_bChInv?$FL9?$FN?$AA@
_DATA	SEGMENT
??_C@_0M@FLFE@g_bChInv?$FL9?$FN?$AA@ DB 'g_bChInv[9]', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@COIO@g_bChInv?$FL10?$FN?$AA@
_DATA	SEGMENT
??_C@_0N@COIO@g_bChInv?$FL10?$FN?$AA@ DB 'g_bChInv[10]', 00H ; `string'
_DATA	ENDS
;	COMDAT ?RegistryRead@@YAXXZ
_TEXT	SEGMENT
_hKey$ = -4
_cbData$ = -12
_b$ = -8
?RegistryRead@@YAXXZ PROC NEAR				; RegistryRead, COMDAT

; 2178 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2179 :     HKEY  hKey;
; 2180 : 	//BYTE  lpData[512];
; 2181 : 	DWORD cbData;
; 2182 : 	//DWORD dw;
; 2183 : 	BOOL b;
; 2184 : 	//FLOAT f;
; 2185 : 	//LONG  lRet;
; 2186 : 
; 2187 : 	// read registry
; 2188 : 	if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Software\\Blacksphere\\R/C Sim Sikorsky",
; 2189 : 				0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS )

  00003	8d 44 24 08	 lea	 eax, DWORD PTR _hKey$[esp+12]
  00007	50		 push	 eax
  00008	6a 01		 push	 1
  0000a	6a 00		 push	 0
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@CLKC@Software?2Blacksphere?2R?1C?5Sim?5Sik@ ; `string'
  00011	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  0001c	85 c0		 test	 eax, eax
  0001e	0f 85 cd 01 00
	00		 jne	 $L49711
  00024	57		 push	 edi

; 2190 : 	{
; 2191 : 
; 2192 : 		// read g_bChInv[1]
; 2193 : 		cbData = sizeof(b);
; 2194 : 		if ( RegQueryValueEx( hKey, "g_bChInv[1]", NULL, NULL,
; 2195 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )

  00025	8d 4c 24 04	 lea	 ecx, DWORD PTR _cbData$[esp+16]
  00029	56		 push	 esi
  0002a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__RegQueryValueExA@24
  00030	8d 54 24 0c	 lea	 edx, DWORD PTR _b$[esp+20]
  00034	51		 push	 ecx
  00035	52		 push	 edx
  00036	50		 push	 eax
  00037	50		 push	 eax
  00038	8b 44 24 20	 mov	 eax, DWORD PTR _hKey$[esp+36]
  0003c	bf 04 00 00 00	 mov	 edi, 4
  00041	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@OOAA@g_bChInv?$FL1?$FN?$AA@ ; `string'
  00046	50		 push	 eax
  00047	89 7c 24 20	 mov	 DWORD PTR _cbData$[esp+44], edi
  0004b	ff d6		 call	 esi
  0004d	85 c0		 test	 eax, eax
  0004f	75 0a		 jne	 SHORT $L49714

; 2196 : 		{
; 2197 : 			g_bChInv[1] = b;

  00051	8b 4c 24 0c	 mov	 ecx, DWORD PTR _b$[esp+20]
  00055	89 0d 04 00 00
	00		 mov	 DWORD PTR ?g_bChInv@@3PAKA+4, ecx
$L49714:

; 2198 : 		}
; 2199 : 
; 2200 : 		// read g_bChInv[2]
; 2201 : 		cbData = sizeof(b);
; 2202 : 		if ( RegQueryValueEx( hKey, "g_bChInv[2]", NULL, NULL,
; 2203 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )

  0005b	8b 4c 24 10	 mov	 ecx, DWORD PTR _hKey$[esp+20]
  0005f	8d 54 24 08	 lea	 edx, DWORD PTR _cbData$[esp+20]
  00063	8d 44 24 0c	 lea	 eax, DWORD PTR _b$[esp+20]
  00067	52		 push	 edx
  00068	50		 push	 eax
  00069	6a 00		 push	 0
  0006b	6a 00		 push	 0
  0006d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@NFPP@g_bChInv?$FL2?$FN?$AA@ ; `string'
  00072	51		 push	 ecx
  00073	89 7c 24 20	 mov	 DWORD PTR _cbData$[esp+44], edi
  00077	ff d6		 call	 esi
  00079	85 c0		 test	 eax, eax
  0007b	75 0a		 jne	 SHORT $L49717

; 2204 : 		{
; 2205 : 			g_bChInv[2] = b;

  0007d	8b 54 24 0c	 mov	 edx, DWORD PTR _b$[esp+20]
  00081	89 15 08 00 00
	00		 mov	 DWORD PTR ?g_bChInv@@3PAKA+8, edx
$L49717:

; 2206 : 		}
; 2207 : 
; 2208 : 		// read g_bChInv[3]
; 2209 : 		cbData = sizeof(b);
; 2210 : 		if ( RegQueryValueEx( hKey, "g_bChInv[3]", NULL, NULL,
; 2211 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )

  00087	8b 54 24 10	 mov	 edx, DWORD PTR _hKey$[esp+20]
  0008b	8d 44 24 08	 lea	 eax, DWORD PTR _cbData$[esp+20]
  0008f	8d 4c 24 0c	 lea	 ecx, DWORD PTR _b$[esp+20]
  00093	50		 push	 eax
  00094	51		 push	 ecx
  00095	6a 00		 push	 0
  00097	6a 00		 push	 0
  00099	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@MDFF@g_bChInv?$FL3?$FN?$AA@ ; `string'
  0009e	52		 push	 edx
  0009f	89 7c 24 20	 mov	 DWORD PTR _cbData$[esp+44], edi
  000a3	ff d6		 call	 esi
  000a5	85 c0		 test	 eax, eax
  000a7	75 09		 jne	 SHORT $L49720

; 2212 : 		{
; 2213 : 			g_bChInv[3] = b;

  000a9	8b 44 24 0c	 mov	 eax, DWORD PTR _b$[esp+20]
  000ad	a3 0c 00 00 00	 mov	 DWORD PTR ?g_bChInv@@3PAKA+12, eax
$L49720:

; 2214 : 		}
; 2215 : 
; 2216 : 		// read g_bChInv[4]
; 2217 : 		cbData = sizeof(b);
; 2218 : 		if ( RegQueryValueEx( hKey, "g_bChInv[4]", NULL, NULL,
; 2219 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )

  000b2	8b 44 24 10	 mov	 eax, DWORD PTR _hKey$[esp+20]
  000b6	8d 4c 24 08	 lea	 ecx, DWORD PTR _cbData$[esp+20]
  000ba	8d 54 24 0c	 lea	 edx, DWORD PTR _b$[esp+20]
  000be	51		 push	 ecx
  000bf	52		 push	 edx
  000c0	6a 00		 push	 0
  000c2	6a 00		 push	 0
  000c4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@KCAA@g_bChInv?$FL4?$FN?$AA@ ; `string'
  000c9	50		 push	 eax
  000ca	89 7c 24 20	 mov	 DWORD PTR _cbData$[esp+44], edi
  000ce	ff d6		 call	 esi
  000d0	85 c0		 test	 eax, eax
  000d2	75 0a		 jne	 SHORT $L49723

; 2220 : 		{
; 2221 : 			g_bChInv[4] = b;

  000d4	8b 4c 24 0c	 mov	 ecx, DWORD PTR _b$[esp+20]
  000d8	89 0d 10 00 00
	00		 mov	 DWORD PTR ?g_bChInv@@3PAKA+16, ecx
$L49723:

; 2222 : 		}
; 2223 : 
; 2224 : 		// read g_bChInv[5]
; 2225 : 		cbData = sizeof(b);
; 2226 : 		if ( RegQueryValueEx( hKey, "g_bChInv[5]", NULL, NULL,
; 2227 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )

  000de	8b 4c 24 10	 mov	 ecx, DWORD PTR _hKey$[esp+20]
  000e2	8d 54 24 08	 lea	 edx, DWORD PTR _cbData$[esp+20]
  000e6	8d 44 24 0c	 lea	 eax, DWORD PTR _b$[esp+20]
  000ea	52		 push	 edx
  000eb	50		 push	 eax
  000ec	6a 00		 push	 0
  000ee	6a 00		 push	 0
  000f0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@LEKK@g_bChInv?$FL5?$FN?$AA@ ; `string'
  000f5	51		 push	 ecx
  000f6	89 7c 24 20	 mov	 DWORD PTR _cbData$[esp+44], edi
  000fa	ff d6		 call	 esi
  000fc	85 c0		 test	 eax, eax
  000fe	75 0a		 jne	 SHORT $L49726

; 2228 : 		{
; 2229 : 			g_bChInv[5] = b;

  00100	8b 54 24 0c	 mov	 edx, DWORD PTR _b$[esp+20]
  00104	89 15 14 00 00
	00		 mov	 DWORD PTR ?g_bChInv@@3PAKA+20, edx
$L49726:

; 2230 : 		}
; 2231 : 
; 2232 : 		// read g_bChInv[6]
; 2233 : 		cbData = sizeof(b);
; 2234 : 		if ( RegQueryValueEx( hKey, "g_bChInv[6]", NULL, NULL,
; 2235 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )

  0010a	8b 54 24 10	 mov	 edx, DWORD PTR _hKey$[esp+20]
  0010e	8d 44 24 08	 lea	 eax, DWORD PTR _cbData$[esp+20]
  00112	8d 4c 24 0c	 lea	 ecx, DWORD PTR _b$[esp+20]
  00116	50		 push	 eax
  00117	51		 push	 ecx
  00118	6a 00		 push	 0
  0011a	6a 00		 push	 0
  0011c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@IPFF@g_bChInv?$FL6?$FN?$AA@ ; `string'
  00121	52		 push	 edx
  00122	89 7c 24 20	 mov	 DWORD PTR _cbData$[esp+44], edi
  00126	ff d6		 call	 esi
  00128	85 c0		 test	 eax, eax
  0012a	75 09		 jne	 SHORT $L49729

; 2236 : 		{
; 2237 : 			g_bChInv[6] = b;

  0012c	8b 44 24 0c	 mov	 eax, DWORD PTR _b$[esp+20]
  00130	a3 18 00 00 00	 mov	 DWORD PTR ?g_bChInv@@3PAKA+24, eax
$L49729:

; 2238 : 		}
; 2239 : 
; 2240 : 		// read g_bChInv[7]
; 2241 : 		cbData = sizeof(b);
; 2242 : 		if ( RegQueryValueEx( hKey, "g_bChInv[7]", NULL, NULL,
; 2243 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )

  00135	8b 44 24 10	 mov	 eax, DWORD PTR _hKey$[esp+20]
  00139	8d 4c 24 08	 lea	 ecx, DWORD PTR _cbData$[esp+20]
  0013d	8d 54 24 0c	 lea	 edx, DWORD PTR _b$[esp+20]
  00141	51		 push	 ecx
  00142	52		 push	 edx
  00143	6a 00		 push	 0
  00145	6a 00		 push	 0
  00147	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@JJPP@g_bChInv?$FL7?$FN?$AA@ ; `string'
  0014c	50		 push	 eax
  0014d	89 7c 24 20	 mov	 DWORD PTR _cbData$[esp+44], edi
  00151	ff d6		 call	 esi
  00153	85 c0		 test	 eax, eax
  00155	75 0a		 jne	 SHORT $L49732

; 2244 : 		{
; 2245 : 			g_bChInv[7] = b;

  00157	8b 4c 24 0c	 mov	 ecx, DWORD PTR _b$[esp+20]
  0015b	89 0d 1c 00 00
	00		 mov	 DWORD PTR ?g_bChInv@@3PAKA+28, ecx
$L49732:

; 2246 : 		}
; 2247 : 
; 2248 : 		// read g_bChInv[8]
; 2249 : 		cbData = sizeof(b);
; 2250 : 		if ( RegQueryValueEx( hKey, "g_bChInv[8]", NULL, NULL,
; 2251 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )

  00161	8b 4c 24 10	 mov	 ecx, DWORD PTR _hKey$[esp+20]
  00165	8d 54 24 08	 lea	 edx, DWORD PTR _cbData$[esp+20]
  00169	8d 44 24 0c	 lea	 eax, DWORD PTR _b$[esp+20]
  0016d	52		 push	 edx
  0016e	50		 push	 eax
  0016f	6a 00		 push	 0
  00171	6a 00		 push	 0
  00173	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@ENPO@g_bChInv?$FL8?$FN?$AA@ ; `string'
  00178	51		 push	 ecx
  00179	89 7c 24 20	 mov	 DWORD PTR _cbData$[esp+44], edi
  0017d	ff d6		 call	 esi
  0017f	85 c0		 test	 eax, eax
  00181	75 0a		 jne	 SHORT $L49735

; 2252 : 		{
; 2253 : 			g_bChInv[8] = b;

  00183	8b 54 24 0c	 mov	 edx, DWORD PTR _b$[esp+20]
  00187	89 15 20 00 00
	00		 mov	 DWORD PTR ?g_bChInv@@3PAKA+32, edx
$L49735:

; 2254 : 		}
; 2255 : 
; 2256 : 		// read g_bChInv[9]
; 2257 : 		cbData = sizeof(b);
; 2258 : 		if ( RegQueryValueEx( hKey, "g_bChInv[9]", NULL, NULL,
; 2259 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )

  0018d	8b 54 24 10	 mov	 edx, DWORD PTR _hKey$[esp+20]
  00191	8d 44 24 08	 lea	 eax, DWORD PTR _cbData$[esp+20]
  00195	8d 4c 24 0c	 lea	 ecx, DWORD PTR _b$[esp+20]
  00199	50		 push	 eax
  0019a	51		 push	 ecx
  0019b	6a 00		 push	 0
  0019d	6a 00		 push	 0
  0019f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@FLFE@g_bChInv?$FL9?$FN?$AA@ ; `string'
  001a4	52		 push	 edx
  001a5	89 7c 24 20	 mov	 DWORD PTR _cbData$[esp+44], edi
  001a9	ff d6		 call	 esi
  001ab	85 c0		 test	 eax, eax
  001ad	75 09		 jne	 SHORT $L49738

; 2260 : 		{
; 2261 : 			g_bChInv[9] = b;

  001af	8b 44 24 0c	 mov	 eax, DWORD PTR _b$[esp+20]
  001b3	a3 24 00 00 00	 mov	 DWORD PTR ?g_bChInv@@3PAKA+36, eax
$L49738:

; 2262 : 		}
; 2263 : 
; 2264 : 		// read g_bChInv[10]
; 2265 : 		cbData = sizeof(b);
; 2266 : 		if ( RegQueryValueEx( hKey, "g_bChInv[10]", NULL, NULL,
; 2267 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )

  001b8	8b 44 24 10	 mov	 eax, DWORD PTR _hKey$[esp+20]
  001bc	8d 4c 24 08	 lea	 ecx, DWORD PTR _cbData$[esp+20]
  001c0	8d 54 24 0c	 lea	 edx, DWORD PTR _b$[esp+20]
  001c4	51		 push	 ecx
  001c5	52		 push	 edx
  001c6	6a 00		 push	 0
  001c8	6a 00		 push	 0
  001ca	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@COIO@g_bChInv?$FL10?$FN?$AA@ ; `string'
  001cf	50		 push	 eax
  001d0	89 7c 24 20	 mov	 DWORD PTR _cbData$[esp+44], edi
  001d4	ff d6		 call	 esi
  001d6	85 c0		 test	 eax, eax
  001d8	75 0a		 jne	 SHORT $L49741

; 2268 : 		{
; 2269 : 			g_bChInv[10] = b;

  001da	8b 4c 24 0c	 mov	 ecx, DWORD PTR _b$[esp+20]
  001de	89 0d 28 00 00
	00		 mov	 DWORD PTR ?g_bChInv@@3PAKA+40, ecx
$L49741:

; 2270 : 		}
; 2271 : 
; 2272 : /*
; 2273 : 		// read g_bRegWindowSize
; 2274 : 		cbData = sizeof(b);
; 2275 : 		if ( RegQueryValueEx( hKey, "g_bRegWindowSize", NULL, NULL,
; 2276 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )
; 2277 : 		{
; 2278 : 			g_bRegWindowSize = b;
; 2279 : 		}
; 2280 : 
; 2281 : 		// read g_bRegFullScreen
; 2282 : 		cbData = sizeof(b);
; 2283 : 		if ( RegQueryValueEx( hKey, "g_bRegFullScreen", NULL, NULL,
; 2284 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )
; 2285 : 		{
; 2286 : 			g_bRegFullScreen = b;
; 2287 : 		}
; 2288 : 
; 2289 : 		// read g_bRegSplashScreen
; 2290 : 		cbData = sizeof(b);
; 2291 : 		if ( RegQueryValueEx( hKey, "g_bRegSplashScreen", NULL, NULL,
; 2292 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )
; 2293 : 		{
; 2294 : 			g_bRegSplashScreen = b;
; 2295 : 			SPLASHSCREEN = g_bRegSplashScreen;
; 2296 : 			m_bSplashScreenShowing = g_bRegSplashScreen;
; 2297 : 		}
; 2298 : 
; 2299 : 
; 2300 : 		// read g_dwRegModeWidth
; 2301 : 		cbData = sizeof(dw);
; 2302 : 		if ( RegQueryValueEx( hKey, "g_dwRegModeWidth", NULL, NULL,
; 2303 : 			(LPBYTE)&dw, &cbData ) == ERROR_SUCCESS )
; 2304 : 		{
; 2305 : 			g_dwRegModeWidth = dw;
; 2306 : 		}
; 2307 : 
; 2308 : 		// read g_dwRegModeHeight
; 2309 : 		cbData = sizeof(dw);
; 2310 : 		if ( RegQueryValueEx( hKey, "g_dwRegModeHeight", NULL, NULL,
; 2311 : 			(LPBYTE)&dw, &cbData ) == ERROR_SUCCESS )
; 2312 : 		{
; 2313 : 			g_dwRegModeHeight = dw;
; 2314 : 		}
; 2315 : 
; 2316 : 		// read g_dwRegModeRGBBitCount
; 2317 : 		cbData = sizeof(dw);
; 2318 : 		if ( RegQueryValueEx( hKey, "g_dwRegModeRGBBitCount", NULL, NULL,
; 2319 : 			(LPBYTE)&dw, &cbData ) == ERROR_SUCCESS )
; 2320 : 		{
; 2321 : 			g_dwRegModeRGBBitCount = dw;
; 2322 : 		}
; 2323 : 
; 2324 : 
; 2325 : 		// read g_bRegLoadVxD
; 2326 : 		cbData = sizeof(b);
; 2327 : 		if ( RegQueryValueEx( hKey, "g_bRegLoadVxD", NULL, NULL,
; 2328 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )
; 2329 : 		{
; 2330 : 			g_bRegLoadVxD = b;
; 2331 : 		}
; 2332 : 
; 2333 : 		// read g_bRegWelcomeVxD
; 2334 : 		cbData = sizeof(b);
; 2335 : 		if ( RegQueryValueEx( hKey, "g_bRegWelcomeVxD", NULL, NULL,
; 2336 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )
; 2337 : 		{
; 2338 : 			g_bRegWelcomeVxD = b;
; 2339 : 		}
; 2340 : 
; 2341 : 		// read g_bRegGoodbyeVxD
; 2342 : 		cbData = sizeof(b);
; 2343 : 		if ( RegQueryValueEx( hKey, "g_bRegGoodbyeVxD", NULL, NULL,
; 2344 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )
; 2345 : 		{
; 2346 : 			g_bRegGoodbyeVxD = b;
; 2347 : 		}
; 2348 : 
; 2349 : 
; 2350 : 		// read m_bSound
; 2351 : 		cbData = sizeof(b);
; 2352 : 		if ( RegQueryValueEx( hKey, "m_bSound", NULL, NULL,
; 2353 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )
; 2354 : 		{
; 2355 : 			m_bSound = b;
; 2356 : 		}
; 2357 : 
; 2358 : 		// read m_bShowPPMarks
; 2359 : 		cbData = sizeof(b);
; 2360 : 		if ( RegQueryValueEx( hKey, "m_bShowPPMarks", NULL, NULL,
; 2361 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )
; 2362 : 		{
; 2363 : 			m_bShowPPMarks = b;
; 2364 : 		}
; 2365 : 
; 2366 : 
; 2367 : 		// read g_bUseKeyboard
; 2368 : 		cbData = sizeof(b);
; 2369 : 		if ( RegQueryValueEx( hKey, "g_bUseKeyboard", NULL, NULL,
; 2370 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )
; 2371 : 		{
; 2372 : 			g_bUseKeyboard = b;
; 2373 : 		}
; 2374 : 
; 2375 : 		// read g_bUseMouse
; 2376 : 		cbData = sizeof(b);
; 2377 : 		if ( RegQueryValueEx( hKey, "g_bUseMouse", NULL, NULL,
; 2378 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )
; 2379 : 		{
; 2380 : 			g_bUseMouse = b;
; 2381 : 		}
; 2382 : 
; 2383 : 		// read g_bUseJoystick
; 2384 : 		cbData = sizeof(b);
; 2385 : 		if ( RegQueryValueEx( hKey, "g_bUseJoystick", NULL, NULL,
; 2386 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )
; 2387 : 		{
; 2388 : 			g_bUseJoystick = b;
; 2389 : 		}
; 2390 : 
; 2391 : 		// read g_bUseTransmitter
; 2392 : 		cbData = sizeof(b);
; 2393 : 		if ( RegQueryValueEx( hKey, "g_bUseTransmitter", NULL, NULL,
; 2394 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )
; 2395 : 		{
; 2396 : 			g_bUseTransmitter = b;
; 2397 : 		}
; 2398 : 
; 2399 : 
; 2400 : 		// read INIT_X
; 2401 : 		cbData = sizeof(f);
; 2402 : 		if ( RegQueryValueEx( hKey, "INIT_X", NULL, NULL,
; 2403 : 			(LPBYTE)&f, &cbData ) == ERROR_SUCCESS )
; 2404 : 		{
; 2405 : 			INIT_X = f;
; 2406 : 		}
; 2407 : 
; 2408 : 		// read INIT_Y
; 2409 : 		cbData = sizeof(f);
; 2410 : 		if ( RegQueryValueEx( hKey, "INIT_Y", NULL, NULL,
; 2411 : 			(LPBYTE)&f, &cbData ) == ERROR_SUCCESS )
; 2412 : 		{
; 2413 : 			INIT_Y = f;
; 2414 : 		}
; 2415 : 
; 2416 : 		// read INIT_Z
; 2417 : 		cbData = sizeof(f);
; 2418 : 		if ( RegQueryValueEx( hKey, "INIT_Z", NULL, NULL,
; 2419 : 			(LPBYTE)&f, &cbData ) == ERROR_SUCCESS )
; 2420 : 		{
; 2421 : 			INIT_Z = f;
; 2422 : 		}
; 2423 : 
; 2424 : 		// read INIT_RADS_Y
; 2425 : 		cbData = sizeof(f);
; 2426 : 		if ( RegQueryValueEx( hKey, "INIT_RADS_Y", NULL, NULL,
; 2427 : 			(LPBYTE)&f, &cbData ) == ERROR_SUCCESS )
; 2428 : 		{
; 2429 : 			INIT_RADS_Y = f;
; 2430 : 		}
; 2431 : 
; 2432 : 		// read m_bShowChannels
; 2433 : 		cbData = sizeof(b);
; 2434 : 		if ( RegQueryValueEx( hKey, "m_bShowChannels", NULL, NULL,
; 2435 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )
; 2436 : 		{
; 2437 : 			m_bShowChannels = b;
; 2438 : 		}
; 2439 : */
; 2440 : 
; 2441 : 
; 2442 : 
; 2443 : 
; 2444 : 		RegCloseKey(hKey);

  001e4	8b 54 24 10	 mov	 edx, DWORD PTR _hKey$[esp+20]
  001e8	52		 push	 edx
  001e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  001ef	5e		 pop	 esi
  001f0	5f		 pop	 edi
$L49711:

; 2445 : 	}
; 2446 : }

  001f1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f4	c3		 ret	 0
?RegistryRead@@YAXXZ ENDP				; RegistryRead
_TEXT	ENDS
PUBLIC	?RegistryWrite@@YAXXZ				; RegistryWrite
PUBLIC	??_C@_05LCAF@Class?$AA@				; `string'
EXTRN	__imp__RegCreateKeyExA@36:NEAR
EXTRN	__imp__RegSetValueExA@24:NEAR
;	COMDAT ??_C@_05LCAF@Class?$AA@
; File E:\interface\TxintguiSDK\Bigpush\bigpush.cpp
_DATA	SEGMENT
??_C@_05LCAF@Class?$AA@ DB 'Class', 00H			; `string'
_DATA	ENDS
;	COMDAT ?RegistryWrite@@YAXXZ
_TEXT	SEGMENT
_hKey$ = -8
_dwDisposition$ = -4
_b$ = -12
?RegistryWrite@@YAXXZ PROC NEAR				; RegistryWrite, COMDAT

; 2455 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2456 :     HKEY  hKey;
; 2457 : 	//BYTE  lpData[80];
; 2458 : 	//DWORD cbData = sizeof(lpData);
; 2459 : 	DWORD dwDisposition;
; 2460 : 	//DWORD dw;
; 2461 : 	BOOL b;
; 2462 : 	//FLOAT f;
; 2463 : 
; 2464 : 	
; 2465 : 
; 2466 : 	if ( RegCreateKeyEx(HKEY_LOCAL_MACHINE, "Software\\Blacksphere\\R/C Sim Sikorsky",
; 2467 : 			0, "Class", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
; 2468 : 			&hKey, &dwDisposition) == ERROR_SUCCESS )

  00003	8d 44 24 08	 lea	 eax, DWORD PTR _dwDisposition$[esp+12]
  00007	8d 4c 24 04	 lea	 ecx, DWORD PTR _hKey$[esp+12]
  0000b	50		 push	 eax
  0000c	51		 push	 ecx
  0000d	6a 00		 push	 0
  0000f	68 3f 00 0f 00	 push	 983103			; 000f003fH
  00014	6a 00		 push	 0
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05LCAF@Class?$AA@ ; `string'
  0001b	6a 00		 push	 0
  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@CLKC@Software?2Blacksphere?2R?1C?5Sim?5Sik@ ; `string'
  00022	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCreateKeyExA@36
  0002d	85 c0		 test	 eax, eax
  0002f	0f 85 5d 01 00
	00		 jne	 $L49748

; 2469 : 	{
; 2470 : 		//MessageBox(NULL,"Registry open","QQQ",MB_OK);
; 2471 : 
; 2472 : 		
; 2473 : 		// write g_bChInv[1]
; 2474 : 		b = g_bChInv[1];
; 2475 : 		RegSetValueEx(hKey, "g_bChInv[1]", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));

  00035	8b 4c 24 04	 mov	 ecx, DWORD PTR _hKey$[esp+12]
  00039	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?g_bChInv@@3PAKA+4
  0003f	56		 push	 esi
  00040	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__RegSetValueExA@24
  00046	8d 44 24 04	 lea	 eax, DWORD PTR _b$[esp+16]
  0004a	6a 04		 push	 4
  0004c	50		 push	 eax
  0004d	6a 04		 push	 4
  0004f	6a 00		 push	 0
  00051	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@OOAA@g_bChInv?$FL1?$FN?$AA@ ; `string'
  00056	51		 push	 ecx
  00057	89 54 24 1c	 mov	 DWORD PTR _b$[esp+40], edx
  0005b	ff d6		 call	 esi

; 2476 : 
; 2477 : 		// write g_bChInv[2]
; 2478 : 		b = g_bChInv[2];
; 2479 : 		RegSetValueEx(hKey, "g_bChInv[2]", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));

  0005d	8b 4c 24 08	 mov	 ecx, DWORD PTR _hKey$[esp+16]
  00061	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ?g_bChInv@@3PAKA+8
  00067	8d 44 24 04	 lea	 eax, DWORD PTR _b$[esp+16]
  0006b	6a 04		 push	 4
  0006d	50		 push	 eax
  0006e	6a 04		 push	 4
  00070	6a 00		 push	 0
  00072	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@NFPP@g_bChInv?$FL2?$FN?$AA@ ; `string'
  00077	51		 push	 ecx
  00078	89 54 24 1c	 mov	 DWORD PTR _b$[esp+40], edx
  0007c	ff d6		 call	 esi

; 2480 : 
; 2481 : 		// write g_bChInv[3]
; 2482 : 		b = g_bChInv[3];
; 2483 : 		RegSetValueEx(hKey, "g_bChInv[3]", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));

  0007e	8b 4c 24 08	 mov	 ecx, DWORD PTR _hKey$[esp+16]
  00082	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?g_bChInv@@3PAKA+12
  00088	8d 44 24 04	 lea	 eax, DWORD PTR _b$[esp+16]
  0008c	6a 04		 push	 4
  0008e	50		 push	 eax
  0008f	6a 04		 push	 4
  00091	6a 00		 push	 0
  00093	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@MDFF@g_bChInv?$FL3?$FN?$AA@ ; `string'
  00098	51		 push	 ecx
  00099	89 54 24 1c	 mov	 DWORD PTR _b$[esp+40], edx
  0009d	ff d6		 call	 esi

; 2484 : 
; 2485 : 		// write g_bChInv[4]
; 2486 : 		b = g_bChInv[4];
; 2487 : 		RegSetValueEx(hKey, "g_bChInv[4]", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));

  0009f	8b 4c 24 08	 mov	 ecx, DWORD PTR _hKey$[esp+16]
  000a3	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR ?g_bChInv@@3PAKA+16
  000a9	8d 44 24 04	 lea	 eax, DWORD PTR _b$[esp+16]
  000ad	6a 04		 push	 4
  000af	50		 push	 eax
  000b0	6a 04		 push	 4
  000b2	6a 00		 push	 0
  000b4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@KCAA@g_bChInv?$FL4?$FN?$AA@ ; `string'
  000b9	51		 push	 ecx
  000ba	89 54 24 1c	 mov	 DWORD PTR _b$[esp+40], edx
  000be	ff d6		 call	 esi

; 2488 : 
; 2489 : 		// write g_bChInv[5]
; 2490 : 		b = g_bChInv[5];
; 2491 : 		RegSetValueEx(hKey, "g_bChInv[5]", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));

  000c0	8b 4c 24 08	 mov	 ecx, DWORD PTR _hKey$[esp+16]
  000c4	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?g_bChInv@@3PAKA+20
  000ca	8d 44 24 04	 lea	 eax, DWORD PTR _b$[esp+16]
  000ce	6a 04		 push	 4
  000d0	50		 push	 eax
  000d1	6a 04		 push	 4
  000d3	6a 00		 push	 0
  000d5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@LEKK@g_bChInv?$FL5?$FN?$AA@ ; `string'
  000da	51		 push	 ecx
  000db	89 54 24 1c	 mov	 DWORD PTR _b$[esp+40], edx
  000df	ff d6		 call	 esi

; 2492 : 
; 2493 : 		// write g_bChInv[6]
; 2494 : 		b = g_bChInv[6];
; 2495 : 		RegSetValueEx(hKey, "g_bChInv[6]", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));

  000e1	8b 4c 24 08	 mov	 ecx, DWORD PTR _hKey$[esp+16]
  000e5	8b 15 18 00 00
	00		 mov	 edx, DWORD PTR ?g_bChInv@@3PAKA+24
  000eb	8d 44 24 04	 lea	 eax, DWORD PTR _b$[esp+16]
  000ef	6a 04		 push	 4
  000f1	50		 push	 eax
  000f2	6a 04		 push	 4
  000f4	6a 00		 push	 0
  000f6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@IPFF@g_bChInv?$FL6?$FN?$AA@ ; `string'
  000fb	51		 push	 ecx
  000fc	89 54 24 1c	 mov	 DWORD PTR _b$[esp+40], edx
  00100	ff d6		 call	 esi

; 2496 : 
; 2497 : 		// write g_bChInv[7]
; 2498 : 		b = g_bChInv[7];
; 2499 : 		RegSetValueEx(hKey, "g_bChInv[7]", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));

  00102	8b 4c 24 08	 mov	 ecx, DWORD PTR _hKey$[esp+16]
  00106	8b 15 1c 00 00
	00		 mov	 edx, DWORD PTR ?g_bChInv@@3PAKA+28
  0010c	8d 44 24 04	 lea	 eax, DWORD PTR _b$[esp+16]
  00110	6a 04		 push	 4
  00112	50		 push	 eax
  00113	6a 04		 push	 4
  00115	6a 00		 push	 0
  00117	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@JJPP@g_bChInv?$FL7?$FN?$AA@ ; `string'
  0011c	51		 push	 ecx
  0011d	89 54 24 1c	 mov	 DWORD PTR _b$[esp+40], edx
  00121	ff d6		 call	 esi

; 2500 : 
; 2501 : 		// write g_bChInv[8]
; 2502 : 		b = g_bChInv[8];

  00123	8b 15 20 00 00
	00		 mov	 edx, DWORD PTR ?g_bChInv@@3PAKA+32
  00129	89 54 24 04	 mov	 DWORD PTR _b$[esp+16], edx

; 2503 : 		RegSetValueEx(hKey, "g_bChInv[8]", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));

  0012d	8b 4c 24 08	 mov	 ecx, DWORD PTR _hKey$[esp+16]
  00131	8d 44 24 04	 lea	 eax, DWORD PTR _b$[esp+16]
  00135	6a 04		 push	 4
  00137	50		 push	 eax
  00138	6a 04		 push	 4
  0013a	6a 00		 push	 0
  0013c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@ENPO@g_bChInv?$FL8?$FN?$AA@ ; `string'
  00141	51		 push	 ecx
  00142	ff d6		 call	 esi

; 2504 : 
; 2505 : 		// write g_bChInv[9]
; 2506 : 		b = g_bChInv[9];
; 2507 : 		RegSetValueEx(hKey, "g_bChInv[9]", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));

  00144	8b 4c 24 08	 mov	 ecx, DWORD PTR _hKey$[esp+16]
  00148	8b 15 24 00 00
	00		 mov	 edx, DWORD PTR ?g_bChInv@@3PAKA+36
  0014e	8d 44 24 04	 lea	 eax, DWORD PTR _b$[esp+16]
  00152	6a 04		 push	 4
  00154	50		 push	 eax
  00155	6a 04		 push	 4
  00157	6a 00		 push	 0
  00159	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@FLFE@g_bChInv?$FL9?$FN?$AA@ ; `string'
  0015e	51		 push	 ecx
  0015f	89 54 24 1c	 mov	 DWORD PTR _b$[esp+40], edx
  00163	ff d6		 call	 esi

; 2508 : 
; 2509 : 		// write g_bChInv[10]
; 2510 : 		b = g_bChInv[10];
; 2511 : 		RegSetValueEx(hKey, "g_bChInv[10]", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));

  00165	8b 4c 24 08	 mov	 ecx, DWORD PTR _hKey$[esp+16]
  00169	8b 15 28 00 00
	00		 mov	 edx, DWORD PTR ?g_bChInv@@3PAKA+40
  0016f	8d 44 24 04	 lea	 eax, DWORD PTR _b$[esp+16]
  00173	6a 04		 push	 4
  00175	50		 push	 eax
  00176	6a 04		 push	 4
  00178	6a 00		 push	 0
  0017a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@COIO@g_bChInv?$FL10?$FN?$AA@ ; `string'
  0017f	51		 push	 ecx
  00180	89 54 24 1c	 mov	 DWORD PTR _b$[esp+40], edx
  00184	ff d6		 call	 esi

; 2512 : 
; 2513 : 
; 2514 : /*
; 2515 : 		// write x
; 2516 : 		_itoa(x, (char *)lpData, 10);
; 2517 : 		if ( RegSetValueEx(hKey, "1_x", 0, REG_SZ, 
; 2518 : 				(CONST BYTE*)lpData, sizeof(*lpData)) == ERROR_SUCCESS )
; 2519 : 		{
; 2520 : 			//MessageBox(NULL,"Registry write x","QQQ",MB_OK);
; 2521 : 		}
; 2522 : 
; 2523 : 		// write y
; 2524 : 		_itoa(y, (char *)lpData, 10);
; 2525 : 		RegSetValueEx(hKey, "1_y", 0, REG_SZ, 
; 2526 : 				(CONST BYTE*)lpData, sizeof(*lpData));
; 2527 : 
; 2528 : 		// write w
; 2529 : 		_itoa(w, (char *)lpData, 10);
; 2530 : 		RegSetValueEx(hKey, "1_w", 0, REG_SZ, 
; 2531 : 				(CONST BYTE*)lpData, sizeof(*lpData));
; 2532 : 
; 2533 : 		// write h
; 2534 : 		_itoa(h, (char *)lpData, 10);
; 2535 : 		RegSetValueEx(hKey, "1_h", 0, REG_SZ, 
; 2536 : 				(CONST BYTE*)lpData, sizeof(*lpData) );
; 2537 : */
; 2538 : 
; 2539 : /*	
; 2540 : 		// Better use DWORD instead of strings here
; 2541 : 		// write x
; 2542 : 		dw = x;
; 2543 : 		if ( RegSetValueEx(hKey, "1_x", 0, REG_DWORD, 
; 2544 : 				(LPBYTE)&dw, sizeof(dw)) == ERROR_SUCCESS )
; 2545 : 		{
; 2546 : 			//MessageBox(NULL,"Registry write x","QQQ",MB_OK);
; 2547 : 		}
; 2548 : 
; 2549 : 		// write y
; 2550 : 		dw = y;
; 2551 : 		RegSetValueEx(hKey, "1_y", 0, REG_DWORD, (LPBYTE)&dw, sizeof(dw));
; 2552 : 
; 2553 : 		// write w
; 2554 : 		dw = w;
; 2555 : 		RegSetValueEx(hKey, "1_w", 0, REG_DWORD, (LPBYTE)&dw, sizeof(dw));
; 2556 : 
; 2557 : 		// write h
; 2558 : 		dw = h;
; 2559 : 		RegSetValueEx(hKey, "1_h", 0, REG_DWORD, (LPBYTE)&dw, sizeof(dw));
; 2560 : 
; 2561 : 
; 2562 : 		// write g_bRegWindowSize
; 2563 : 		b = g_bRegWindowSize;
; 2564 : 		RegSetValueEx(hKey, "g_bRegWindowSize", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));
; 2565 : 		
; 2566 : 		// write g_bRegFullScreen
; 2567 : 		b = g_bRegFullScreen;
; 2568 : 		RegSetValueEx(hKey, "g_bRegFullScreen", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));
; 2569 : 
; 2570 : 		// write g_bRegSplashScreen
; 2571 : 		b = g_bRegSplashScreen;
; 2572 : 		RegSetValueEx(hKey, "g_bRegSplashScreen", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));
; 2573 : 
; 2574 : 
; 2575 : 		// write g_dwRegModeWidth
; 2576 : 		dw = g_dwRegModeWidth;
; 2577 : 		RegSetValueEx(hKey, "g_dwRegModeWidth", 0, REG_DWORD, (LPBYTE)&dw, sizeof(dw));
; 2578 : 
; 2579 : 		// write g_dwRegModeHeight
; 2580 : 		dw = g_dwRegModeHeight;
; 2581 : 		RegSetValueEx(hKey, "g_dwRegModeHeight", 0, REG_DWORD, (LPBYTE)&dw, sizeof(dw));
; 2582 : 
; 2583 : 		// write g_dwRegModeRGBBitCount
; 2584 : 		dw = g_dwRegModeRGBBitCount;
; 2585 : 		RegSetValueEx(hKey, "g_dwRegModeRGBBitCount", 0, REG_DWORD, (LPBYTE)&dw, sizeof(dw));
; 2586 : 
; 2587 :  
; 2588 : 		// write g_bRegLoadVxD
; 2589 : 		b = g_bRegLoadVxD;
; 2590 : 		RegSetValueEx(hKey, "g_bRegLoadVxD", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));
; 2591 : 
; 2592 : 		// write g_bRegWelcomeVxD
; 2593 : 		b = g_bRegWelcomeVxD;
; 2594 : 		RegSetValueEx(hKey, "g_bRegWelcomeVxD", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));
; 2595 : 
; 2596 : 		// write g_bRegGoodbyeVxD
; 2597 : 		b = g_bRegGoodbyeVxD;
; 2598 : 		RegSetValueEx(hKey, "g_bRegGoodbyeVxD", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));
; 2599 : 
; 2600 : 
; 2601 : 		// write m_bSound
; 2602 : 		b = m_bSound;
; 2603 : 		RegSetValueEx(hKey, "m_bSound", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));
; 2604 : 
; 2605 : 		// write m_bShowPPMarks
; 2606 : 		b = m_bShowPPMarks;
; 2607 : 		RegSetValueEx(hKey, "m_bShowPPMarks", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));
; 2608 : 
; 2609 : 
; 2610 : 		// write g_bUseKeyboard
; 2611 : 		b = g_bUseKeyboard;
; 2612 : 		RegSetValueEx(hKey, "g_bUseKeyboard", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));
; 2613 : 
; 2614 : 		// write g_bUseMouse
; 2615 : 		b = g_bUseMouse;
; 2616 : 		RegSetValueEx(hKey, "g_bUseMouse", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));
; 2617 : 
; 2618 : 		// write g_bUseJoystick
; 2619 : 		b = g_bUseJoystick;
; 2620 : 		RegSetValueEx(hKey, "g_bUseJoystick", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));
; 2621 : 
; 2622 : 		// write g_bUseTransmitter
; 2623 : 		b = g_bUseTransmitter;
; 2624 : 		RegSetValueEx(hKey, "g_bUseTransmitter", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));
; 2625 : 
; 2626 : 
; 2627 : 		// NOTE: must write REG_BINARY for floats!!!!!!
; 2628 : 		// write INIT_X
; 2629 : 		f = INIT_X;
; 2630 : 		RegSetValueEx(hKey, "INIT_X", 0, REG_BINARY, (LPBYTE)&f, sizeof(f));
; 2631 : 
; 2632 : 		// write INIT_Y
; 2633 : 		f = INIT_Y;
; 2634 : 		RegSetValueEx(hKey, "INIT_Y", 0, REG_BINARY, (LPBYTE)&f, sizeof(f));
; 2635 : 
; 2636 : 		// write INIT_Z
; 2637 : 		f = INIT_Z;
; 2638 : 		RegSetValueEx(hKey, "INIT_Z", 0, REG_BINARY, (LPBYTE)&f, sizeof(f));
; 2639 : 
; 2640 : 		// write INIT_RADS_Y
; 2641 : 		f = INIT_RADS_Y;
; 2642 : 		RegSetValueEx(hKey, "INIT_RADS_Y", 0, REG_BINARY, (LPBYTE)&f, sizeof(f));
; 2643 : 
; 2644 : 		// write m_bShowChannels
; 2645 : 		b = m_bShowChannels;
; 2646 : 		RegSetValueEx(hKey, "m_bShowChannels", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));
; 2647 : */
; 2648 : 
; 2649 : 
; 2650 : 
; 2651 : 		RegCloseKey(hKey);

  00186	8b 54 24 08	 mov	 edx, DWORD PTR _hKey$[esp+16]
  0018a	52		 push	 edx
  0018b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  00191	5e		 pop	 esi
$L49748:

; 2652 : 	}
; 2653 : }

  00192	83 c4 0c	 add	 esp, 12			; 0000000cH
  00195	c3		 ret	 0
?RegistryWrite@@YAXXZ ENDP				; RegistryWrite
_TEXT	ENDS
PUBLIC	??_C@_0P@GDON@g_bAlwaysOnTop?$AA@		; `string'
PUBLIC	??_C@_0O@BLFF@g_bShowInTray?$AA@		; `string'
PUBLIC	??_C@_0BD@DMGJ@g_bAnimateTrayIcon?$AA@		; `string'
;	COMDAT ??_C@_0P@GDON@g_bAlwaysOnTop?$AA@
; File E:\interface\TxintguiSDK\Bigpush\bigpush.cpp
_DATA	SEGMENT
??_C@_0P@GDON@g_bAlwaysOnTop?$AA@ DB 'g_bAlwaysOnTop', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@BLFF@g_bShowInTray?$AA@
_DATA	SEGMENT
??_C@_0O@BLFF@g_bShowInTray?$AA@ DB 'g_bShowInTray', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@DMGJ@g_bAnimateTrayIcon?$AA@
_DATA	SEGMENT
??_C@_0BD@DMGJ@g_bAnimateTrayIcon?$AA@ DB 'g_bAnimateTrayIcon', 00H ; `string'
_DATA	ENDS
;	COMDAT ?RegistryRead2@@YAXXZ
_TEXT	SEGMENT
_hKey$ = -4
_cbData$ = -12
_b$ = -8
?RegistryRead2@@YAXXZ PROC NEAR				; RegistryRead2, COMDAT

; 2663 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2664 :     HKEY  hKey;
; 2665 : 	//BYTE  lpData[512];
; 2666 : 	DWORD cbData;
; 2667 : 	//DWORD dw;
; 2668 : 	BOOL b;
; 2669 : 	//FLOAT f;
; 2670 : 	//LONG  lRet;
; 2671 : 
; 2672 : 	// read registry
; 2673 : 	if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Software\\Blacksphere\\R/C Sim Sikorsky",
; 2674 : 				0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS )

  00003	8d 44 24 08	 lea	 eax, DWORD PTR _hKey$[esp+12]
  00007	50		 push	 eax
  00008	6a 01		 push	 1
  0000a	6a 00		 push	 0
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@CLKC@Software?2Blacksphere?2R?1C?5Sim?5Sik@ ; `string'
  00011	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  0001c	85 c0		 test	 eax, eax
  0001e	0f 85 a0 00 00
	00		 jne	 $L49765

; 2675 : 	{
; 2676 : 
; 2677 : 		// read g_bAlwaysOnTop
; 2678 : 		cbData = sizeof(b);
; 2679 : 		if ( RegQueryValueEx( hKey, "g_bAlwaysOnTop", NULL, NULL,
; 2680 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )

  00024	8d 4c 24 00	 lea	 ecx, DWORD PTR _cbData$[esp+12]
  00028	56		 push	 esi
  00029	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__RegQueryValueExA@24
  0002f	8d 54 24 08	 lea	 edx, DWORD PTR _b$[esp+16]
  00033	51		 push	 ecx
  00034	52		 push	 edx
  00035	50		 push	 eax
  00036	50		 push	 eax
  00037	8b 44 24 1c	 mov	 eax, DWORD PTR _hKey$[esp+32]
  0003b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@GDON@g_bAlwaysOnTop?$AA@ ; `string'
  00040	50		 push	 eax
  00041	c7 44 24 1c 04
	00 00 00	 mov	 DWORD PTR _cbData$[esp+40], 4
  00049	ff d6		 call	 esi
  0004b	85 c0		 test	 eax, eax
  0004d	75 0a		 jne	 SHORT $L49767

; 2681 : 		{
; 2682 : 			g_bAlwaysOnTop = b;

  0004f	8b 4c 24 08	 mov	 ecx, DWORD PTR _b$[esp+16]
  00053	89 0d 00 00 00
	00		 mov	 DWORD PTR ?g_bAlwaysOnTop@@3KA, ecx ; g_bAlwaysOnTop
$L49767:

; 2683 : 		}
; 2684 : 
; 2685 : 		// read g_bShowInTray
; 2686 : 		cbData = sizeof(b);
; 2687 : 		if ( RegQueryValueEx( hKey, "g_bShowInTray", NULL, NULL,
; 2688 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )

  00059	8b 4c 24 0c	 mov	 ecx, DWORD PTR _hKey$[esp+16]
  0005d	8d 54 24 04	 lea	 edx, DWORD PTR _cbData$[esp+16]
  00061	8d 44 24 08	 lea	 eax, DWORD PTR _b$[esp+16]
  00065	52		 push	 edx
  00066	50		 push	 eax
  00067	6a 00		 push	 0
  00069	6a 00		 push	 0
  0006b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@BLFF@g_bShowInTray?$AA@ ; `string'
  00070	51		 push	 ecx
  00071	c7 44 24 1c 04
	00 00 00	 mov	 DWORD PTR _cbData$[esp+40], 4
  00079	ff d6		 call	 esi
  0007b	85 c0		 test	 eax, eax
  0007d	75 0a		 jne	 SHORT $L49770

; 2689 : 		{
; 2690 : 			g_bShowInTray = b;

  0007f	8b 54 24 08	 mov	 edx, DWORD PTR _b$[esp+16]
  00083	89 15 00 00 00
	00		 mov	 DWORD PTR ?g_bShowInTray@@3KA, edx ; g_bShowInTray
$L49770:

; 2691 : 		}
; 2692 : 
; 2693 : 		// read g_bAnimateTrayIcon
; 2694 : 		cbData = sizeof(b);
; 2695 : 		if ( RegQueryValueEx( hKey, "g_bAnimateTrayIcon", NULL, NULL,
; 2696 : 			(LPBYTE)&b, &cbData ) == ERROR_SUCCESS )

  00089	8b 54 24 0c	 mov	 edx, DWORD PTR _hKey$[esp+16]
  0008d	8d 44 24 04	 lea	 eax, DWORD PTR _cbData$[esp+16]
  00091	8d 4c 24 08	 lea	 ecx, DWORD PTR _b$[esp+16]
  00095	50		 push	 eax
  00096	51		 push	 ecx
  00097	6a 00		 push	 0
  00099	6a 00		 push	 0
  0009b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@DMGJ@g_bAnimateTrayIcon?$AA@ ; `string'
  000a0	52		 push	 edx
  000a1	c7 44 24 1c 04
	00 00 00	 mov	 DWORD PTR _cbData$[esp+40], 4
  000a9	ff d6		 call	 esi
  000ab	85 c0		 test	 eax, eax
  000ad	75 09		 jne	 SHORT $L49773

; 2697 : 		{
; 2698 : 			g_bAnimateTrayIcon = b;

  000af	8b 44 24 08	 mov	 eax, DWORD PTR _b$[esp+16]
  000b3	a3 00 00 00 00	 mov	 DWORD PTR ?g_bAnimateTrayIcon@@3KA, eax ; g_bAnimateTrayIcon
$L49773:

; 2699 : 		}
; 2700 : 
; 2701 : 
; 2702 : 		RegCloseKey(hKey);

  000b8	8b 4c 24 0c	 mov	 ecx, DWORD PTR _hKey$[esp+16]
  000bc	51		 push	 ecx
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  000c3	5e		 pop	 esi
$L49765:

; 2703 : 	}
; 2704 : }

  000c4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c7	c3		 ret	 0
?RegistryRead2@@YAXXZ ENDP				; RegistryRead2
_TEXT	ENDS
;	COMDAT ?RegistryWrite2@@YAXXZ
_TEXT	SEGMENT
_hKey$ = -8
_dwDisposition$ = -4
_b$ = -12
?RegistryWrite2@@YAXXZ PROC NEAR			; RegistryWrite2, COMDAT

; 2713 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2714 :     HKEY  hKey;
; 2715 : 	//BYTE  lpData[80];
; 2716 : 	//DWORD cbData = sizeof(lpData);
; 2717 : 	DWORD dwDisposition;
; 2718 : 	//DWORD dw;
; 2719 : 	BOOL b;
; 2720 : 	//FLOAT f;
; 2721 : 
; 2722 : 	
; 2723 : 
; 2724 : 	if ( RegCreateKeyEx(HKEY_LOCAL_MACHINE, "Software\\Blacksphere\\R/C Sim Sikorsky",
; 2725 : 			0, "Class", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
; 2726 : 			&hKey, &dwDisposition) == ERROR_SUCCESS )

  00003	8d 44 24 08	 lea	 eax, DWORD PTR _dwDisposition$[esp+12]
  00007	8d 4c 24 04	 lea	 ecx, DWORD PTR _hKey$[esp+12]
  0000b	50		 push	 eax
  0000c	51		 push	 ecx
  0000d	6a 00		 push	 0
  0000f	68 3f 00 0f 00	 push	 983103			; 000f003fH
  00014	6a 00		 push	 0
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05LCAF@Class?$AA@ ; `string'
  0001b	6a 00		 push	 0
  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@CLKC@Software?2Blacksphere?2R?1C?5Sim?5Sik@ ; `string'
  00022	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCreateKeyExA@36
  0002d	85 c0		 test	 eax, eax
  0002f	75 76		 jne	 SHORT $L49780

; 2727 : 	{
; 2728 : 	
; 2729 : 		// write g_bAlwaysOnTop
; 2730 : 		b = g_bAlwaysOnTop;
; 2731 : 		RegSetValueEx(hKey, "g_bAlwaysOnTop", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));

  00031	8b 4c 24 04	 mov	 ecx, DWORD PTR _hKey$[esp+12]
  00035	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_bAlwaysOnTop@@3KA ; g_bAlwaysOnTop
  0003b	56		 push	 esi
  0003c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__RegSetValueExA@24
  00042	8d 44 24 04	 lea	 eax, DWORD PTR _b$[esp+16]
  00046	6a 04		 push	 4
  00048	50		 push	 eax
  00049	6a 04		 push	 4
  0004b	6a 00		 push	 0
  0004d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@GDON@g_bAlwaysOnTop?$AA@ ; `string'
  00052	51		 push	 ecx
  00053	89 54 24 1c	 mov	 DWORD PTR _b$[esp+40], edx
  00057	ff d6		 call	 esi

; 2732 : 
; 2733 : 		// write g_bShowInTray
; 2734 : 		b = g_bShowInTray;
; 2735 : 		RegSetValueEx(hKey, "g_bShowInTray", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));

  00059	8b 4c 24 08	 mov	 ecx, DWORD PTR _hKey$[esp+16]
  0005d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_bShowInTray@@3KA ; g_bShowInTray
  00063	8d 44 24 04	 lea	 eax, DWORD PTR _b$[esp+16]
  00067	6a 04		 push	 4
  00069	50		 push	 eax
  0006a	6a 04		 push	 4
  0006c	6a 00		 push	 0
  0006e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@BLFF@g_bShowInTray?$AA@ ; `string'
  00073	51		 push	 ecx
  00074	89 54 24 1c	 mov	 DWORD PTR _b$[esp+40], edx
  00078	ff d6		 call	 esi

; 2736 : 
; 2737 : 		// write g_bAnimateTrayIcon
; 2738 : 		b = g_bAnimateTrayIcon;
; 2739 : 		RegSetValueEx(hKey, "g_bAnimateTrayIcon", 0, REG_DWORD, (LPBYTE)&b, sizeof(b));

  0007a	8b 4c 24 08	 mov	 ecx, DWORD PTR _hKey$[esp+16]
  0007e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_bAnimateTrayIcon@@3KA ; g_bAnimateTrayIcon
  00084	8d 44 24 04	 lea	 eax, DWORD PTR _b$[esp+16]
  00088	6a 04		 push	 4
  0008a	50		 push	 eax
  0008b	6a 04		 push	 4
  0008d	6a 00		 push	 0
  0008f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@DMGJ@g_bAnimateTrayIcon?$AA@ ; `string'
  00094	51		 push	 ecx
  00095	89 54 24 1c	 mov	 DWORD PTR _b$[esp+40], edx
  00099	ff d6		 call	 esi

; 2740 : 
; 2741 : 
; 2742 : 
; 2743 : 		RegCloseKey(hKey);

  0009b	8b 54 24 08	 mov	 edx, DWORD PTR _hKey$[esp+16]
  0009f	52		 push	 edx
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  000a6	5e		 pop	 esi
$L49780:

; 2744 : 	}
; 2745 : }

  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000aa	c3		 ret	 0
?RegistryWrite2@@YAXXZ ENDP				; RegistryWrite2
_TEXT	ENDS
PUBLIC	??_C@_0BC@ODK@g_hWndCalibration?$AA@		; `string'
;	COMDAT ??_C@_0BC@ODK@g_hWndCalibration?$AA@
; File E:\interface\TxintguiSDK\Bigpush\bigpush.cpp
_DATA	SEGMENT
??_C@_0BC@ODK@g_hWndCalibration?$AA@ DB 'g_hWndCalibration', 00H ; `string'
_DATA	ENDS
;	COMDAT ?RegistryRead3@@YAXXZ
_TEXT	SEGMENT
_hKey$ = -12
_cbData$ = -8
_dw$ = -4
?RegistryRead3@@YAXXZ PROC NEAR				; RegistryRead3, COMDAT

; 2756 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2757 :     HKEY  hKey;
; 2758 : 	//BYTE  lpData[512];
; 2759 : 	DWORD cbData;
; 2760 : 	DWORD dw;
; 2761 : 	//BOOL b;
; 2762 : 	//FLOAT f;
; 2763 : 	//LONG  lRet;
; 2764 : 
; 2765 : 	// read registry
; 2766 : 	if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Software\\Blacksphere\\R/C Sim Sikorsky",
; 2767 : 				0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS )

  00003	8d 44 24 00	 lea	 eax, DWORD PTR _hKey$[esp+12]
  00007	50		 push	 eax
  00008	6a 01		 push	 1
  0000a	6a 00		 push	 0
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@CLKC@Software?2Blacksphere?2R?1C?5Sim?5Sik@ ; `string'
  00011	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  0001c	85 c0		 test	 eax, eax
  0001e	75 3d		 jne	 SHORT $L49789

; 2768 : 	{
; 2769 : 
; 2770 : 		// read g_hWndCalibration
; 2771 : 		cbData = sizeof(dw);
; 2772 : 		if ( RegQueryValueEx( hKey, "g_hWndCalibration", NULL, NULL,
; 2773 : 			(LPBYTE)&dw, &cbData ) == ERROR_SUCCESS )

  00020	8d 4c 24 04	 lea	 ecx, DWORD PTR _cbData$[esp+12]
  00024	8d 54 24 08	 lea	 edx, DWORD PTR _dw$[esp+12]
  00028	51		 push	 ecx
  00029	52		 push	 edx
  0002a	50		 push	 eax
  0002b	50		 push	 eax
  0002c	8b 44 24 10	 mov	 eax, DWORD PTR _hKey$[esp+28]
  00030	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@ODK@g_hWndCalibration?$AA@ ; `string'
  00035	50		 push	 eax
  00036	c7 44 24 1c 04
	00 00 00	 mov	 DWORD PTR _cbData$[esp+36], 4
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  00044	85 c0		 test	 eax, eax
  00046	75 0a		 jne	 SHORT $L49791

; 2774 : 		{
; 2775 : 			g_hWndCalibration = dw;

  00048	8b 4c 24 08	 mov	 ecx, DWORD PTR _dw$[esp+12]
  0004c	89 0d 00 00 00
	00		 mov	 DWORD PTR ?g_hWndCalibration@@3KA, ecx ; g_hWndCalibration
$L49791:

; 2776 : 		}
; 2777 : 
; 2778 : 
; 2779 : 		RegCloseKey(hKey);

  00052	8b 54 24 00	 mov	 edx, DWORD PTR _hKey$[esp+12]
  00056	52		 push	 edx
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$L49789:

; 2780 : 	}
; 2781 : }

  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00060	c3		 ret	 0
?RegistryRead3@@YAXXZ ENDP				; RegistryRead3
_TEXT	ENDS
;	COMDAT ?RegistryWrite3@@YAXXZ
_TEXT	SEGMENT
_hKey$ = -12
_dwDisposition$ = -4
_dw$ = -8
?RegistryWrite3@@YAXXZ PROC NEAR			; RegistryWrite3, COMDAT

; 2790 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2791 :     HKEY  hKey;
; 2792 : 	//BYTE  lpData[80];
; 2793 : 	//DWORD cbData = sizeof(lpData);
; 2794 : 	DWORD dwDisposition;
; 2795 : 	DWORD dw;
; 2796 : 	//BOOL b;
; 2797 : 	//FLOAT f;
; 2798 : 
; 2799 : 	
; 2800 : 
; 2801 : 	if ( RegCreateKeyEx(HKEY_LOCAL_MACHINE, "Software\\Blacksphere\\R/C Sim Sikorsky",
; 2802 : 			0, "Class", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
; 2803 : 			&hKey, &dwDisposition) == ERROR_SUCCESS )

  00003	8d 44 24 08	 lea	 eax, DWORD PTR _dwDisposition$[esp+12]
  00007	8d 4c 24 00	 lea	 ecx, DWORD PTR _hKey$[esp+12]
  0000b	50		 push	 eax
  0000c	51		 push	 ecx
  0000d	6a 00		 push	 0
  0000f	68 3f 00 0f 00	 push	 983103			; 000f003fH
  00014	6a 00		 push	 0
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05LCAF@Class?$AA@ ; `string'
  0001b	6a 00		 push	 0
  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@CLKC@Software?2Blacksphere?2R?1C?5Sim?5Sik@ ; `string'
  00022	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCreateKeyExA@36
  0002d	85 c0		 test	 eax, eax
  0002f	75 30		 jne	 SHORT $L49798

; 2804 : 	{
; 2805 : 	
; 2806 : 		// write g_hWndCalibration
; 2807 : 		dw = g_hWndCalibration;
; 2808 : 		RegSetValueEx(hKey, "g_hWndCalibration", 0, REG_DWORD, (LPBYTE)&dw, sizeof(dw));

  00031	8b 4c 24 00	 mov	 ecx, DWORD PTR _hKey$[esp+12]
  00035	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hWndCalibration@@3KA ; g_hWndCalibration
  0003b	8d 44 24 04	 lea	 eax, DWORD PTR _dw$[esp+12]
  0003f	6a 04		 push	 4
  00041	50		 push	 eax
  00042	6a 04		 push	 4
  00044	6a 00		 push	 0
  00046	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@ODK@g_hWndCalibration?$AA@ ; `string'
  0004b	51		 push	 ecx
  0004c	89 54 24 1c	 mov	 DWORD PTR _dw$[esp+36], edx
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24

; 2809 : 
; 2810 : 
; 2811 : 		RegCloseKey(hKey);

  00056	8b 54 24 00	 mov	 edx, DWORD PTR _hKey$[esp+12]
  0005a	52		 push	 edx
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$L49798:

; 2812 : 	}
; 2813 : }

  00061	83 c4 0c	 add	 esp, 12			; 0000000cH
  00064	c3		 ret	 0
?RegistryWrite3@@YAXXZ ENDP				; RegistryWrite3
_TEXT	ENDS
PUBLIC	??_C@_0P@MCDD@g_hWndSikorsky?$AA@		; `string'
;	COMDAT ??_C@_0P@MCDD@g_hWndSikorsky?$AA@
; File E:\interface\TxintguiSDK\Bigpush\bigpush.cpp
_DATA	SEGMENT
??_C@_0P@MCDD@g_hWndSikorsky?$AA@ DB 'g_hWndSikorsky', 00H ; `string'
_DATA	ENDS
;	COMDAT ?RegistryRead4@@YAXXZ
_TEXT	SEGMENT
_hKey$ = -12
_cbData$ = -8
_dw$ = -4
?RegistryRead4@@YAXXZ PROC NEAR				; RegistryRead4, COMDAT

; 2822 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2823 :     HKEY  hKey;
; 2824 : 	//BYTE  lpData[512];
; 2825 : 	DWORD cbData;
; 2826 : 	DWORD dw;
; 2827 : 	//BOOL b;
; 2828 : 	//FLOAT f;
; 2829 : 	//LONG  lRet;
; 2830 : 
; 2831 : 	// read registry
; 2832 : 	if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Software\\Blacksphere\\R/C Sim Sikorsky",
; 2833 : 				0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS )

  00003	8d 44 24 00	 lea	 eax, DWORD PTR _hKey$[esp+12]
  00007	50		 push	 eax
  00008	6a 01		 push	 1
  0000a	6a 00		 push	 0
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@CLKC@Software?2Blacksphere?2R?1C?5Sim?5Sik@ ; `string'
  00011	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  0001c	85 c0		 test	 eax, eax
  0001e	75 3d		 jne	 SHORT $L49805

; 2834 : 	{
; 2835 : 
; 2836 : 		// read g_hWndSikorsky
; 2837 : 		cbData = sizeof(dw);
; 2838 : 		if ( RegQueryValueEx( hKey, "g_hWndSikorsky", NULL, NULL,
; 2839 : 			(LPBYTE)&dw, &cbData ) == ERROR_SUCCESS )

  00020	8d 4c 24 04	 lea	 ecx, DWORD PTR _cbData$[esp+12]
  00024	8d 54 24 08	 lea	 edx, DWORD PTR _dw$[esp+12]
  00028	51		 push	 ecx
  00029	52		 push	 edx
  0002a	50		 push	 eax
  0002b	50		 push	 eax
  0002c	8b 44 24 10	 mov	 eax, DWORD PTR _hKey$[esp+28]
  00030	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@MCDD@g_hWndSikorsky?$AA@ ; `string'
  00035	50		 push	 eax
  00036	c7 44 24 1c 04
	00 00 00	 mov	 DWORD PTR _cbData$[esp+36], 4
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  00044	85 c0		 test	 eax, eax
  00046	75 0a		 jne	 SHORT $L49807

; 2840 : 		{
; 2841 : 			g_hWndSikorsky = dw;

  00048	8b 4c 24 08	 mov	 ecx, DWORD PTR _dw$[esp+12]
  0004c	89 0d 00 00 00
	00		 mov	 DWORD PTR ?g_hWndSikorsky@@3KA, ecx ; g_hWndSikorsky
$L49807:

; 2842 : 		}
; 2843 : 
; 2844 : 
; 2845 : 		RegCloseKey(hKey);

  00052	8b 54 24 00	 mov	 edx, DWORD PTR _hKey$[esp+12]
  00056	52		 push	 edx
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$L49805:

; 2846 : 	}
; 2847 : }

  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00060	c3		 ret	 0
?RegistryRead4@@YAXXZ ENDP				; RegistryRead4
_TEXT	ENDS
PUBLIC	?RegistryWrite4@@YAXXZ				; RegistryWrite4
;	COMDAT ?RegistryWrite4@@YAXXZ
_TEXT	SEGMENT
_hKey$ = -12
_dwDisposition$ = -4
_dw$ = -8
?RegistryWrite4@@YAXXZ PROC NEAR			; RegistryWrite4, COMDAT

; 2856 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2857 :     HKEY  hKey;
; 2858 : 	//BYTE  lpData[80];
; 2859 : 	//DWORD cbData = sizeof(lpData);
; 2860 : 	DWORD dwDisposition;
; 2861 : 	DWORD dw;
; 2862 : 	//BOOL b;
; 2863 : 	//FLOAT f;
; 2864 : 
; 2865 : 	
; 2866 : 
; 2867 : 	if ( RegCreateKeyEx(HKEY_LOCAL_MACHINE, "Software\\Blacksphere\\R/C Sim Sikorsky",
; 2868 : 			0, "Class", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
; 2869 : 			&hKey, &dwDisposition) == ERROR_SUCCESS )

  00003	8d 44 24 08	 lea	 eax, DWORD PTR _dwDisposition$[esp+12]
  00007	8d 4c 24 00	 lea	 ecx, DWORD PTR _hKey$[esp+12]
  0000b	50		 push	 eax
  0000c	51		 push	 ecx
  0000d	6a 00		 push	 0
  0000f	68 3f 00 0f 00	 push	 983103			; 000f003fH
  00014	6a 00		 push	 0
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05LCAF@Class?$AA@ ; `string'
  0001b	6a 00		 push	 0
  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@CLKC@Software?2Blacksphere?2R?1C?5Sim?5Sik@ ; `string'
  00022	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCreateKeyExA@36
  0002d	85 c0		 test	 eax, eax
  0002f	75 30		 jne	 SHORT $L49814

; 2870 : 	{
; 2871 : 
; 2872 : 		// write g_hWndSikorsky
; 2873 : 		dw = g_hWndSikorsky;
; 2874 : 		RegSetValueEx(hKey, "g_hWndSikorsky", 0, REG_DWORD, (LPBYTE)&dw, sizeof(dw));		

  00031	8b 4c 24 00	 mov	 ecx, DWORD PTR _hKey$[esp+12]
  00035	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hWndSikorsky@@3KA ; g_hWndSikorsky
  0003b	8d 44 24 04	 lea	 eax, DWORD PTR _dw$[esp+12]
  0003f	6a 04		 push	 4
  00041	50		 push	 eax
  00042	6a 04		 push	 4
  00044	6a 00		 push	 0
  00046	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@MCDD@g_hWndSikorsky?$AA@ ; `string'
  0004b	51		 push	 ecx
  0004c	89 54 24 1c	 mov	 DWORD PTR _dw$[esp+36], edx
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24

; 2875 : 
; 2876 : 
; 2877 : 		RegCloseKey(hKey);

  00056	8b 54 24 00	 mov	 edx, DWORD PTR _hKey$[esp+12]
  0005a	52		 push	 edx
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$L49814:

; 2878 : 	}
; 2879 : }

  00061	83 c4 0c	 add	 esp, 12			; 0000000cH
  00064	c3		 ret	 0
?RegistryWrite4@@YAXXZ ENDP				; RegistryWrite4
_TEXT	ENDS
PUBLIC	??_C@_0CA@JLAE@R?1C?5Sim?5Transmitter?5Calibration?$AA@ ; `string'
EXTRN	__imp__lstrcpynA@12:NEAR
EXTRN	__imp__Shell_NotifyIconA@8:NEAR
;	COMDAT ??_C@_0CA@JLAE@R?1C?5Sim?5Transmitter?5Calibration?$AA@
; File E:\interface\TxintguiSDK\Bigpush\bigpush.cpp
_DATA	SEGMENT
??_C@_0CA@JLAE@R?1C?5Sim?5Transmitter?5Calibration?$AA@ DB 'R/C Sim Trans'
	DB	'mitter Calibration', 00H			; `string'
_DATA	ENDS
;	COMDAT ?AddTaskBarIcon@@YAXPAUHWND__@@PAUHICON__@@@Z
_TEXT	SEGMENT
_hWnd$ = 8
_hIcon$ = 12
_icondaten$ = -88
?AddTaskBarIcon@@YAXPAUHWND__@@PAUHICON__@@@Z PROC NEAR	; AddTaskBarIcon, COMDAT

; 2890 : {

  00000	83 ec 58	 sub	 esp, 88			; 00000058H

; 2891 : 	NOTIFYICONDATA	icondaten;
; 2892 : 
; 2893 : 	icondaten.cbSize = sizeof(NOTIFYICONDATA);
; 2894 : 	icondaten.hWnd = hWnd;

  00003	8b 44 24 5c	 mov	 eax, DWORD PTR _hWnd$[esp+84]

; 2895 : 	icondaten.uID = IDI_ICON1;
; 2896 : 	icondaten.uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP;
; 2897 : 	icondaten.uCallbackMessage = MYWM_CLICKONTASKBARICON;
; 2898 : 	icondaten.hIcon = hIcon;

  00007	8b 4c 24 60	 mov	 ecx, DWORD PTR _hIcon$[esp+84]

; 2899 : 	lstrcpyn(icondaten.szTip, "R/C Sim Transmitter Calibration", 
; 2900 : 		sizeof("R/C Sim Transmitter Calibration"));

  0000b	6a 20		 push	 32			; 00000020H
  0000d	8d 54 24 1c	 lea	 edx, DWORD PTR _icondaten$[esp+116]
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@JLAE@R?1C?5Sim?5Transmitter?5Calibration?$AA@ ; `string'
  00016	52		 push	 edx
  00017	c7 44 24 0c 58
	00 00 00	 mov	 DWORD PTR _icondaten$[esp+100], 88 ; 00000058H
  0001f	89 44 24 10	 mov	 DWORD PTR _icondaten$[esp+104], eax
  00023	c7 44 24 14 84
	00 00 00	 mov	 DWORD PTR _icondaten$[esp+108], 132 ; 00000084H
  0002b	c7 44 24 18 07
	00 00 00	 mov	 DWORD PTR _icondaten$[esp+112], 7
  00033	c7 44 24 1c 01
	04 00 00	 mov	 DWORD PTR _icondaten$[esp+116], 1025 ; 00000401H
  0003b	89 4c 24 20	 mov	 DWORD PTR _icondaten$[esp+120], ecx
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpynA@12

; 2901 : 
; 2902 : 	Shell_NotifyIcon(NIM_ADD, &icondaten);

  00045	8d 44 24 00	 lea	 eax, DWORD PTR _icondaten$[esp+88]
  00049	50		 push	 eax
  0004a	6a 00		 push	 0
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Shell_NotifyIconA@8

; 2903 : }

  00052	83 c4 58	 add	 esp, 88			; 00000058H
  00055	c3		 ret	 0
?AddTaskBarIcon@@YAXPAUHWND__@@PAUHICON__@@@Z ENDP	; AddTaskBarIcon
_TEXT	ENDS
;	COMDAT ?DeleteTaskBarIcon@@YAXPAUHWND__@@@Z
_TEXT	SEGMENT
_hWnd$ = 8
_icondaten$ = -88
?DeleteTaskBarIcon@@YAXPAUHWND__@@@Z PROC NEAR		; DeleteTaskBarIcon, COMDAT

; 2910 : { 

  00000	83 ec 58	 sub	 esp, 88			; 00000058H

; 2911 : 	NOTIFYICONDATA icondaten;
; 2912 : 
; 2913 : 	icondaten.cbSize = sizeof(NOTIFYICONDATA);
; 2914 : 	icondaten.hWnd = hWnd;

  00003	8b 44 24 5c	 mov	 eax, DWORD PTR _hWnd$[esp+84]

; 2915 : 	icondaten.uID = IDI_ICON1;
; 2916 : 
; 2917 : 	Shell_NotifyIcon(NIM_DELETE, &icondaten);

  00007	8d 4c 24 00	 lea	 ecx, DWORD PTR _icondaten$[esp+88]
  0000b	51		 push	 ecx
  0000c	6a 02		 push	 2
  0000e	c7 44 24 08 58
	00 00 00	 mov	 DWORD PTR _icondaten$[esp+96], 88 ; 00000058H
  00016	89 44 24 0c	 mov	 DWORD PTR _icondaten$[esp+100], eax
  0001a	c7 44 24 10 84
	00 00 00	 mov	 DWORD PTR _icondaten$[esp+104], 132 ; 00000084H
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Shell_NotifyIconA@8

; 2918 : }

  00028	83 c4 58	 add	 esp, 88			; 00000058H
  0002b	c3		 ret	 0
?DeleteTaskBarIcon@@YAXPAUHWND__@@@Z ENDP		; DeleteTaskBarIcon
_TEXT	ENDS
;	COMDAT ?ModifyTaskBarIcon@@YAXPAUHWND__@@PAUHICON__@@PAD@Z
_TEXT	SEGMENT
_hWnd$ = 8
_hIcon$ = 12
_szTip$ = 16
_icondaten$ = -88
?ModifyTaskBarIcon@@YAXPAUHWND__@@PAUHICON__@@PAD@Z PROC NEAR ; ModifyTaskBarIcon, COMDAT

; 2925 : { 

  00000	83 ec 58	 sub	 esp, 88			; 00000058H

; 2926 : 	NOTIFYICONDATA icondaten;
; 2927 : 
; 2928 : 	icondaten.cbSize = sizeof(NOTIFYICONDATA);
; 2929 : 	icondaten.hWnd = hWnd;

  00003	8b 44 24 5c	 mov	 eax, DWORD PTR _hWnd$[esp+84]

; 2930 : 	icondaten.uID = IDI_ICON1;
; 2931 : 	icondaten.uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP;
; 2932 : 	icondaten.uCallbackMessage = MYWM_CLICKONTASKBARICON;
; 2933 : 	icondaten.hIcon = hIcon;
; 2934 : 	lstrcpyn(icondaten.szTip, szTip, 64);

  00007	8b 54 24 64	 mov	 edx, DWORD PTR _szTip$[esp+84]
  0000b	8b 4c 24 60	 mov	 ecx, DWORD PTR _hIcon$[esp+84]
  0000f	89 44 24 04	 mov	 DWORD PTR _icondaten$[esp+92], eax
  00013	6a 40		 push	 64			; 00000040H
  00015	8d 44 24 1c	 lea	 eax, DWORD PTR _icondaten$[esp+116]
  00019	52		 push	 edx
  0001a	50		 push	 eax
  0001b	c7 44 24 0c 58
	00 00 00	 mov	 DWORD PTR _icondaten$[esp+100], 88 ; 00000058H
  00023	c7 44 24 14 84
	00 00 00	 mov	 DWORD PTR _icondaten$[esp+108], 132 ; 00000084H
  0002b	c7 44 24 18 07
	00 00 00	 mov	 DWORD PTR _icondaten$[esp+112], 7
  00033	c7 44 24 1c 01
	04 00 00	 mov	 DWORD PTR _icondaten$[esp+116], 1025 ; 00000401H
  0003b	89 4c 24 20	 mov	 DWORD PTR _icondaten$[esp+120], ecx
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpynA@12

; 2935 : 
; 2936 : 	Shell_NotifyIcon(NIM_MODIFY, &icondaten);

  00045	8d 4c 24 00	 lea	 ecx, DWORD PTR _icondaten$[esp+88]
  00049	51		 push	 ecx
  0004a	6a 01		 push	 1
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Shell_NotifyIconA@8

; 2937 : }

  00052	83 c4 58	 add	 esp, 88			; 00000058H
  00055	c3		 ret	 0
?ModifyTaskBarIcon@@YAXPAUHWND__@@PAUHICON__@@PAD@Z ENDP ; ModifyTaskBarIcon
_TEXT	ENDS
END
